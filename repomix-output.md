This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-15 09:52:00

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.gitignore
extension
  media
    assets
      index-DOkYKv7m.css
    index.html
  package.json
  src
    extension.ts
    git.ts
    graph.ts
    lsp.ts
    util.ts
  tsconfig.json
final_review_gate.py
package.json
README.md
repomix-output.md
webview
  index.html
  package.json
  src
    App.tsx
    code
      CodeCard.tsx
      highlight.ts
    layout.ts
    main.tsx
    reactflow-node-types.tsx
    styles.css
  tsconfig.json
  vite.config.ts
```

# Repository Files


## .gitignore

```text
/final_review_gate.py
node_modules
```

## extension/media/assets/index-DOkYKv7m.css

```css
/* this gets exported as style.css and can be used for the default theming */
/* these are the necessary styles for React Flow, they get used by base.css and style.css */
.react-flow {
  direction: ltr;
}
.react-flow__container {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
}
.react-flow__pane {
  z-index: 1;
  cursor: -webkit-grab;
  cursor: grab;
}
.react-flow__pane.selection {
    cursor: pointer;
  }
.react-flow__pane.dragging {
    cursor: -webkit-grabbing;
    cursor: grabbing;
  }
.react-flow__viewport {
  transform-origin: 0 0;
  z-index: 2;
  pointer-events: none;
}
.react-flow__renderer {
  z-index: 4;
}
.react-flow__selection {
  z-index: 6;
}
.react-flow__nodesselection-rect:focus,
.react-flow__nodesselection-rect:focus-visible {
  outline: none;
}
.react-flow .react-flow__edges {
  pointer-events: none;
  overflow: visible;
}
.react-flow__edge-path,
.react-flow__connection-path {
  stroke: #b1b1b7;
  stroke-width: 1;
  fill: none;
}
.react-flow__edge {
  pointer-events: visibleStroke;
  cursor: pointer;
}
.react-flow__edge.animated path {
    stroke-dasharray: 5;
    -webkit-animation: dashdraw 0.5s linear infinite;
            animation: dashdraw 0.5s linear infinite;
  }
.react-flow__edge.animated path.react-flow__edge-interaction {
    stroke-dasharray: none;
    -webkit-animation: none;
            animation: none;
  }
.react-flow__edge.inactive {
    pointer-events: none;
  }
.react-flow__edge.selected,
  .react-flow__edge:focus,
  .react-flow__edge:focus-visible {
    outline: none;
  }
.react-flow__edge.selected .react-flow__edge-path,
  .react-flow__edge:focus .react-flow__edge-path,
  .react-flow__edge:focus-visible .react-flow__edge-path {
    stroke: #555;
  }
.react-flow__edge-textwrapper {
    pointer-events: all;
  }
.react-flow__edge-textbg {
    fill: white;
  }
.react-flow__edge .react-flow__edge-text {
    pointer-events: none;
    -webkit-user-select: none;
       -moz-user-select: none;
            user-select: none;
  }
.react-flow__connection {
  pointer-events: none;
}
.react-flow__connection .animated {
    stroke-dasharray: 5;
    -webkit-animation: dashdraw 0.5s linear infinite;
            animation: dashdraw 0.5s linear infinite;
  }
.react-flow__connectionline {
  z-index: 1001;
}
.react-flow__nodes {
  pointer-events: none;
  transform-origin: 0 0;
}
.react-flow__node {
  position: absolute;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
  pointer-events: all;
  transform-origin: 0 0;
  box-sizing: border-box;
  cursor: -webkit-grab;
  cursor: grab;
}
.react-flow__node.dragging {
    cursor: -webkit-grabbing;
    cursor: grabbing;
  }
.react-flow__nodesselection {
  z-index: 3;
  transform-origin: left top;
  pointer-events: none;
}
.react-flow__nodesselection-rect {
    position: absolute;
    pointer-events: all;
    cursor: -webkit-grab;
    cursor: grab;
  }
.react-flow__handle {
  position: absolute;
  pointer-events: none;
  min-width: 5px;
  min-height: 5px;
  width: 6px;
  height: 6px;
  background: #1a192b;
  border: 1px solid white;
  border-radius: 100%;
}
.react-flow__handle.connectionindicator {
    pointer-events: all;
    cursor: crosshair;
  }
.react-flow__handle-bottom {
    top: auto;
    left: 50%;
    bottom: -4px;
    transform: translate(-50%, 0);
  }
.react-flow__handle-top {
    left: 50%;
    top: -4px;
    transform: translate(-50%, 0);
  }
.react-flow__handle-left {
    top: 50%;
    left: -4px;
    transform: translate(0, -50%);
  }
.react-flow__handle-right {
    right: -4px;
    top: 50%;
    transform: translate(0, -50%);
  }
.react-flow__edgeupdater {
  cursor: move;
  pointer-events: all;
}
.react-flow__panel {
  position: absolute;
  z-index: 5;
  margin: 15px;
}
.react-flow__panel.top {
    top: 0;
  }
.react-flow__panel.bottom {
    bottom: 0;
  }
.react-flow__panel.left {
    left: 0;
  }
.react-flow__panel.right {
    right: 0;
  }
.react-flow__panel.center {
    left: 50%;
    transform: translateX(-50%);
  }
.react-flow__attribution {
  font-size: 10px;
  background: rgba(255, 255, 255, 0.5);
  padding: 2px 3px;
  margin: 0;
}
.react-flow__attribution a {
    text-decoration: none;
    color: #999;
  }
@-webkit-keyframes dashdraw {
  from {
    stroke-dashoffset: 10;
  }
}
@keyframes dashdraw {
  from {
    stroke-dashoffset: 10;
  }
}
.react-flow__edgelabel-renderer {
  position: absolute;
  width: 100%;
  height: 100%;
  pointer-events: none;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
}
.react-flow__edge.updating .react-flow__edge-path {
      stroke: #777;
    }
.react-flow__edge-text {
    font-size: 10px;
  }
.react-flow__node.selectable:focus,
  .react-flow__node.selectable:focus-visible {
    outline: none;
  }
.react-flow__node-default,
.react-flow__node-input,
.react-flow__node-output,
.react-flow__node-group {
  padding: 10px;
  border-radius: 3px;
  width: 150px;
  font-size: 12px;
  color: #222;
  text-align: center;
  border-width: 1px;
  border-style: solid;
  border-color: #1a192b;
  background-color: white;
}
.react-flow__node-default.selectable:hover, .react-flow__node-input.selectable:hover, .react-flow__node-output.selectable:hover, .react-flow__node-group.selectable:hover {
      box-shadow: 0 1px 4px 1px rgba(0, 0, 0, 0.08);
    }
.react-flow__node-default.selectable.selected,
    .react-flow__node-default.selectable:focus,
    .react-flow__node-default.selectable:focus-visible,
    .react-flow__node-input.selectable.selected,
    .react-flow__node-input.selectable:focus,
    .react-flow__node-input.selectable:focus-visible,
    .react-flow__node-output.selectable.selected,
    .react-flow__node-output.selectable:focus,
    .react-flow__node-output.selectable:focus-visible,
    .react-flow__node-group.selectable.selected,
    .react-flow__node-group.selectable:focus,
    .react-flow__node-group.selectable:focus-visible {
      box-shadow: 0 0 0 0.5px #1a192b;
    }
.react-flow__node-group {
  background-color: rgba(240, 240, 240, 0.25);
}
.react-flow__nodesselection-rect,
.react-flow__selection {
  background: rgba(0, 89, 220, 0.08);
  border: 1px dotted rgba(0, 89, 220, 0.8);
}
.react-flow__nodesselection-rect:focus,
  .react-flow__nodesselection-rect:focus-visible,
  .react-flow__selection:focus,
  .react-flow__selection:focus-visible {
    outline: none;
  }
.react-flow__controls {
  box-shadow: 0 0 2px 1px rgba(0, 0, 0, 0.08);
}
.react-flow__controls-button {
    border: none;
    background: #fefefe;
    border-bottom: 1px solid #eee;
    box-sizing: content-box;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 16px;
    height: 16px;
    cursor: pointer;
    -webkit-user-select: none;
       -moz-user-select: none;
            user-select: none;
    padding: 5px;
  }
.react-flow__controls-button:hover {
      background: #f4f4f4;
    }
.react-flow__controls-button svg {
      width: 100%;
      max-width: 12px;
      max-height: 12px;
    }
.react-flow__controls-button:disabled {
      pointer-events: none;
    }
.react-flow__controls-button:disabled svg {
        fill-opacity: 0.4;
      }
.react-flow__minimap {
  background-color: #fff;
}
.react-flow__minimap svg {
  display: block;
}
.react-flow__resize-control {
  position: absolute;
}
.react-flow__resize-control.left,
.react-flow__resize-control.right {
  cursor: ew-resize;
}
.react-flow__resize-control.top,
.react-flow__resize-control.bottom {
  cursor: ns-resize;
}
.react-flow__resize-control.top.left,
.react-flow__resize-control.bottom.right {
  cursor: nwse-resize;
}
.react-flow__resize-control.bottom.left,
.react-flow__resize-control.top.right {
  cursor: nesw-resize;
}
/* handle styles */
.react-flow__resize-control.handle {
  width: 4px;
  height: 4px;
  border: 1px solid #fff;
  border-radius: 1px;
  background-color: #3367d9;
  transform: translate(-50%, -50%);
}
.react-flow__resize-control.handle.left {
  left: 0;
  top: 50%;
}
.react-flow__resize-control.handle.right {
  left: 100%;
  top: 50%;
}
.react-flow__resize-control.handle.top {
  left: 50%;
  top: 0;
}
.react-flow__resize-control.handle.bottom {
  left: 50%;
  top: 100%;
}
.react-flow__resize-control.handle.top.left {
  left: 0;
}
.react-flow__resize-control.handle.bottom.left {
  left: 0;
}
.react-flow__resize-control.handle.top.right {
  left: 100%;
}
.react-flow__resize-control.handle.bottom.right {
  left: 100%;
}
/* line styles */
.react-flow__resize-control.line {
  border-color: #3367d9;
  border-width: 0;
  border-style: solid;
}
.react-flow__resize-control.line.left,
.react-flow__resize-control.line.right {
  width: 1px;
  transform: translate(-50%, 0);
  top: 0;
  height: 100%;
}
.react-flow__resize-control.line.left {
  left: 0;
  border-left-width: 1px;
}
.react-flow__resize-control.line.right {
  left: 100%;
  border-right-width: 1px;
}
.react-flow__resize-control.line.top,
.react-flow__resize-control.line.bottom {
  height: 1px;
  transform: translate(0, -50%);
  left: 0;
  width: 100%;
}
.react-flow__resize-control.line.top {
  top: 0;
  border-top-width: 1px;
}
.react-flow__resize-control.line.bottom {
  border-bottom-width: 1px;
  top: 100%;
}
:root {
    color-scheme: dark;
    --ease-smooth: cubic-bezier(0.22, 1, 0.36, 1);
    --zoom-duration: 320ms;
}

body,
html,
#root {
    margin: 0;
    height: 100%;
    background: #0b0e12;
    color: #cdd6f4;
    font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Inter, sans-serif;
}

.root {
    height: 100%;
}

.toolbar {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    display: flex;
    gap: 6px;
}

.toolbar button {
    background: #111827;
    border: 1px solid #1f2937;
    color: #e5e7eb;
    padding: 6px 10px;
    border-radius: 8px;
    cursor: pointer;
}

.file-node {
    width: 100%;
    height: 100%;
    background: #0d1117;
    border: 1px solid #1f2937;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 0 0 1px #0b1220 inset;
}

.file-node-header {
    background: #0b1220;
    padding: 6px 10px;
    font-weight: 600;
    font-size: 12px;
    letter-spacing: .3px;
    border-bottom: 1px solid #1f2937;
    cursor: grab;
}

.code-card {
    height: calc(100% - 30px);
    overflow: auto;
}

.code-card .file-title {
    display: none;
}

pre.hljs {
    margin: 0;
    padding: 8px 10px 8px 56px;
    /* leave space for gutter */
    font-size: 12px;
    line-height: 1.35;
    position: relative;
    counter-reset: line;
}

pre.hljs .code-line {
    display: block;
    counter-increment: line;
    position: relative;
}

pre.hljs .code-line::before {
    content: counter(line);
    position: absolute;
    left: -44px;
    width: 36px;
    text-align: right;
    color: #6b7280;
    opacity: 0.9;
}

pre.hljs .code-line.highlight {
    background: rgba(255, 214, 10, 0.15);
    outline: 1px solid rgba(255, 214, 10, 0.35);
}

pre.hljs.wrap {
    white-space: pre-wrap;
}

.preview {
    font-size: 11px;
    opacity: .8;
    padding: 8px;
}

/* Improve MiniMap visibility */
.react-flow__minimap {
    background: #0f1115 !important;
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.06) inset;
}

.react-flow__minimap-mask {
    fill: rgba(255, 255, 255, 0.06) !important;
}

.react-flow__minimap-node {
    fill: #4f46e5 !important;
    stroke: rgba(255, 255, 255, 0.2) !important;
}

/* Allow extreme zooming */
.react-flow__renderer,
.react-flow__viewport {
    will-change: transform;
}

/* Smooth node transitions for layout/elevation changes */
.react-flow__node {
    transition: transform 220ms cubic-bezier(0.22, 1, 0.36, 1), opacity 160ms ease;
    will-change: transform;
}

/* Disable transition while dragging to keep the interaction snappy */
.react-flow__node.no-animate {
    transition: none !important;
}

@media (prefers-reduced-motion: reduce) {
    .react-flow__node {
        transition: none !important;
    }
}

/* Smooth transform transitions for the React Flow viewport (zoom smoothing) */
.react-flow__viewport {
    transition: none;
}

.react-flow__viewport.zoom-smooth {
    transition: transform var(--zoom-duration) var(--ease-smooth);
}

/* Disable smoothing during pans/drags for snappy feel */
.react-flow__viewport.no-animate {
    transition: none !important;
}

/* Placeholder body shown when code is hidden for performance */
.node-placeholder-body {
    height: calc(100% - 30px);
    display: grid;
    place-items: center;
    color: #94a3b8;
    font-size: 12px;
    opacity: 0.9;
}

/* Defer offscreen work for heavy node content */
.code-card {
    content-visibility: auto;
    contain-intrinsic-size: 480px 280px;
    contain: layout paint size;
}

/* Promote nodes to their own layer to reduce flicker during viewport moves */
.file-node {
    backface-visibility: hidden;
    transform: translateZ(0);
}pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 1em
}
code.hljs {
  padding: 3px 5px
}
/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/
.hljs {
  color: #c9d1d9;
  background: #0d1117
}
.hljs-doctag,
.hljs-keyword,
.hljs-meta .hljs-keyword,
.hljs-template-tag,
.hljs-template-variable,
.hljs-type,
.hljs-variable.language_ {
  /* prettylights-syntax-keyword */
  color: #ff7b72
}
.hljs-title,
.hljs-title.class_,
.hljs-title.class_.inherited__,
.hljs-title.function_ {
  /* prettylights-syntax-entity */
  color: #d2a8ff
}
.hljs-attr,
.hljs-attribute,
.hljs-literal,
.hljs-meta,
.hljs-number,
.hljs-operator,
.hljs-variable,
.hljs-selector-attr,
.hljs-selector-class,
.hljs-selector-id {
  /* prettylights-syntax-constant */
  color: #79c0ff
}
.hljs-regexp,
.hljs-string,
.hljs-meta .hljs-string {
  /* prettylights-syntax-string */
  color: #a5d6ff
}
.hljs-built_in,
.hljs-symbol {
  /* prettylights-syntax-variable */
  color: #ffa657
}
.hljs-comment,
.hljs-code,
.hljs-formula {
  /* prettylights-syntax-comment */
  color: #8b949e
}
.hljs-name,
.hljs-quote,
.hljs-selector-tag,
.hljs-selector-pseudo {
  /* prettylights-syntax-entity-tag */
  color: #7ee787
}
.hljs-subst {
  /* prettylights-syntax-storage-modifier-import */
  color: #c9d1d9
}
.hljs-section {
  /* prettylights-syntax-markup-heading */
  color: #1f6feb;
  font-weight: bold
}
.hljs-bullet {
  /* prettylights-syntax-markup-list */
  color: #f2cc60
}
.hljs-emphasis {
  /* prettylights-syntax-markup-italic */
  color: #c9d1d9;
  font-style: italic
}
.hljs-strong {
  /* prettylights-syntax-markup-bold */
  color: #c9d1d9;
  font-weight: bold
}
.hljs-addition {
  /* prettylights-syntax-markup-inserted */
  color: #aff5b4;
  background-color: #033a16
}
.hljs-deletion {
  /* prettylights-syntax-markup-deleted */
  color: #ffdcd7;
  background-color: #67060c
}
.hljs-char.escape_,
.hljs-link,
.hljs-params,
.hljs-property,
.hljs-punctuation,
.hljs-tag {
  /* purposely ignored */
  
}
```

## extension/media/index.html

```html
<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; img-src vscode-resource: https: data:; style-src 'unsafe-inline' __CSP__; script-src __CSP__; font-src __CSP__; connect-src __CSP__;" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Code Canvas</title>
  <script type="module" crossorigin src="./assets/index-1u4Gp6IV.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-DOkYKv7m.css">
</head>

<body>
    <div id="root"></div>

</body>

</html>
```

## extension/package.json

```json
{
    "name": "code-canvas",
    "displayName": "Code Canvas",
    "publisher": "code-canvas",
    "version": "0.0.1",
    "engines": {
        "vscode": "^1.90.0"
    },
    "categories": [
        "Other"
    ],
    "activationEvents": [
        "onStartupFinished"
    ],
    "main": "dist/extension.js",
    "contributes": {
        "commands": [
            {
                "command": "codeCanvas.open",
                "title": "Code Canvas: Open"
            },
            {
                "command": "codeCanvas.openChanged",
                "title": "Code Canvas: Open Changed Files"
            },
            {
                "command": "codeCanvas.layout.custom",
                "title": "Code Canvas: Layout – Custom"
            },
            {
                "command": "codeCanvas.layout.dagre",
                "title": "Code Canvas: Layout – Dagre"
            },
            {
                "command": "codeCanvas.layout.elk",
                "title": "Code Canvas: Layout – ELK"
            },
            {
                "command": "codeCanvas.layout.force",
                "title": "Code Canvas: Layout – Force"
            },
            {
                "command": "codeCanvas.toggleRefs",
                "title": "Code Canvas: Toggle Refs"
            },
            {
                "command": "codeCanvas.seedFolder",
                "title": "Code Canvas: Open Folder as Seed"
            },
            {
                "command": "codeCanvas.loadMore",
                "title": "Code Canvas: Load 25 More"
            }
        ],
        "keybindings": [
            {
                "command": "codeCanvas.openChanged",
                "key": "shift+o"
            },
            {
                "command": "codeCanvas.loadMore",
                "key": "shift+plus"
            },
            {
                "command": "codeCanvas.layout.custom",
                "key": "shift+1"
            },
            {
                "command": "codeCanvas.layout.dagre",
                "key": "shift+2"
            },
            {
                "command": "codeCanvas.layout.elk",
                "key": "shift+3"
            },
            {
                "command": "codeCanvas.layout.force",
                "key": "shift+4"
            },
            {
                "command": "codeCanvas.toggleRefs",
                "key": "r"
            }
        ],
        "configuration": {
            "title": "Code Canvas",
            "properties": {
                "codeCanvas.maxNodes": {
                    "type": "number",
                    "default": 300,
                    "description": "Maximum nodes to render per subgraph."
                },
                "codeCanvas.excludeGlobs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "default": [
                        "**/node_modules/**",
                        "**/.venv/**",
                        "**/__pycache__/**",
                        "**/dist/**",
                        "**/build/**",
                        "**/.git/**"
                    ],
                    "description": "Extra glob patterns to exclude from indexing."
                },
                "codeCanvas.maxPreviewBytes": {
                    "type": "number",
                    "default": 100000,
                    "description": "Maximum number of bytes of file content to send to the webview for preview per file."
                },
                "codeCanvas.initialCap": {
                    "type": "number",
                    "default": 25,
                    "description": "Initial maximum number of nodes to show when first rendering a graph."
                }
            }
        }
    },
    "scripts": {
        "vscode:prepublish": "npm run build",
        "build": "tsup src/extension.ts --format cjs --dts --out-dir dist --external vscode",
        "watch": "tsup src/extension.ts --watch --format cjs --out-dir dist",
        "package": "vsce package"
    },
    "dependencies": {
        "fast-glob": "^3.3.2",
        "minimatch": "^9.0.5"
    },
    "devDependencies": {
        "@types/node": "^24.2.1",
        "@types/vscode": "^1.102.0",
        "@vscode/vsce": "^3.6.0",
        "tsup": "^8.5.0",
        "typescript": "^5.6"
    }
}
```

## extension/src/extension.ts

```typescript
﻿import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { htmlForWebview, Graph } from './util';
import { buildIndex, subgraph } from './graph';
import { getChangedFiles, watchGitState } from './git';
import * as lsp from './lsp';

let panel: vscode.WebviewPanel | undefined;
let idxPromise: ReturnType<typeof buildIndex> | undefined;
let lastSeeds: string[] = [];
let lastCap: number = 0;

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('codeCanvas.open', () => openPanel(context)),
        vscode.commands.registerCommand('codeCanvas.openChanged', async () => {
            await ensurePanel(context);
            const files = await getChangedFiles();
            panel?.webview.postMessage({ type: 'openChanged', files });
        }),
        vscode.commands.registerCommand('codeCanvas.layout.custom', () => panel?.webview.postMessage({ type: 'layout', algo: 'custom' })),
        vscode.commands.registerCommand('codeCanvas.layout.dagre', () => panel?.webview.postMessage({ type: 'layout', algo: 'dagre' })),
        vscode.commands.registerCommand('codeCanvas.layout.elk', () => panel?.webview.postMessage({ type: 'layout', algo: 'elk' })),
        vscode.commands.registerCommand('codeCanvas.layout.force', () => panel?.webview.postMessage({ type: 'layout', algo: 'force' })),
        vscode.commands.registerCommand('codeCanvas.toggleRefs', () => panel?.webview.postMessage({ type: 'toggleRefs' })),
        vscode.commands.registerCommand('codeCanvas.seedFolder', async () => {
            await ensurePanel(context);
            const picked = await vscode.window.showOpenDialog({ canSelectFiles: false, canSelectFolders: true, canSelectMany: false, openLabel: 'Use Folder as Seed' });
            if (!picked || !picked[0]) return;
            const folder = picked[0].fsPath;
            const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
            if (root && !idxPromise) idxPromise = buildIndex(root);
            const index = await idxPromise;
            if (!index) return;
            const folderNorm = path.resolve(folder);
            const seeds = Array.from(index.nodes).filter(p => isSubPath(folderNorm, p));
            if (!seeds.length) {
                vscode.window.showInformationMessage('Code Canvas: No files found under selected folder.');
                return;
            }
            const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
            const initialCapCfg: number = vscode.workspace.getConfiguration('codeCanvas').get('initialCap') ?? 25;
            const cap = Math.min(maxNodes, initialCapCfg);
            lastSeeds = seeds;
            lastCap = cap;
            const g: Graph = await subgraph(index, seeds, cap);
            panel?.webview.postMessage({ type: 'graph', graph: g });
        }),
        vscode.commands.registerCommand('codeCanvas.loadMore', async () => {
            await ensurePanel(context);
            if (!lastSeeds.length) return;
            const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
            if (root && !idxPromise) idxPromise = buildIndex(root);
            const index = await idxPromise;
            if (!index) return;
            const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
            const nextCap = Math.min(maxNodes, lastCap + 25);
            lastCap = nextCap;
            const g: Graph = await subgraph(index, lastSeeds, nextCap);
            panel?.webview.postMessage({ type: 'graph', graph: g });
        })
    );

    vscode.workspace.onDidChangeTextDocument(async (e) => {
        if (!panel) return;
        panel.webview.postMessage({ type: 'docChanged', file: e.document.uri.fsPath });
    });

    watchGitState(async () => {
        if (!panel) return;
        const files = await getChangedFiles();
        panel.webview.postMessage({ type: 'gitChanged', files });
    });
}

async function ensurePanel(context: vscode.ExtensionContext) { if (!panel) openPanel(context); }

function openPanel(context: vscode.ExtensionContext) {
    const column = vscode.ViewColumn.Beside;
    panel = vscode.window.createWebviewPanel('codeCanvas', 'Code Canvas', column, {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [vscode.Uri.joinPath(context.extensionUri, 'media')]
    });
    panel.webview.html = htmlForWebview(panel, context);
    panel.onDidDispose(() => panel = undefined);

    // kick off indexing
    const ws = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
    if (ws) idxPromise = buildIndex(ws);

    setTimeout(() => sendInitial(ws), 150);

    panel.webview.onDidReceiveMessage(async (msg) => {
        switch (msg.type) {
            case 'requestGraph': await sendInitial(ws); break;
            case 'expand': await sendExpansion(msg.ids || []); break;
            case 'loadMore': {
                const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
                if (root && !idxPromise) idxPromise = buildIndex(root);
                const index = await idxPromise;
                if (!index || !lastSeeds.length) break;
                const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
                const nextCap = Math.min(maxNodes, lastCap + 25);
                lastCap = nextCap;
                const g: Graph = await subgraph(index, lastSeeds, nextCap);
                panel?.webview.postMessage({ type: 'graph', graph: g });
                break;
            }
            case 'openFile': {
                const uri = vscode.Uri.file(msg.path);
                vscode.window.showTextDocument(uri, { preview: false });
                break;
            }
            case 'toggleEdges': {
                panel?.webview.postMessage({ type: 'toggleEdges' });
                break;
            }
            case 'requestChanged': {
                const files = await getChangedFiles();
                panel?.webview.postMessage({ type: 'changedFiles', files });
                break;
            }
            case 'requestRefs': {
                const { path, line, character } = msg;
                const uri = vscode.Uri.file(path);
                const refs = await lsp.getReferences(uri, new vscode.Position(line, character));
                panel?.webview.postMessage({ type: 'refs', at: { path, line, character }, refs });
                break;
            }
            case 'requestDefOpen': {
                const { path, line, character } = msg;
                const fromUri = vscode.Uri.file(path);
                const defs = await lsp.getDefinition(fromUri, new vscode.Position(line, character));
                const loc = Array.isArray(defs) ? defs[0] : defs;
                if (loc) {
                    let openUri: vscode.Uri | undefined;
                    let range: vscode.Range | undefined;
                    const anyLoc = loc as any;
                    if (anyLoc.targetUri) {
                        openUri = toUri(anyLoc.targetUri);
                        range = (anyLoc.targetSelectionRange || anyLoc.targetRange) as vscode.Range | undefined;
                    } else if (anyLoc.uri) {
                        openUri = toUri(anyLoc.uri);
                        range = anyLoc.range as vscode.Range | undefined;
                    }
                    if (openUri) await vscode.window.showTextDocument(openUri, { preview: false, selection: range });
                }
                break;
            }
            case 'requestCode': {
                const { path } = msg;
                const maxBytes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxPreviewBytes') ?? 100_000;
                const content = safeRead(path, maxBytes);
                panel?.webview.postMessage({ type: 'code', path, content });
                break;
            }
            case 'requestCodeMany': {
                const { paths } = msg as { paths: string[] };
                const maxBytes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxPreviewBytes') ?? 100_000;
                const entries = (paths || []).map(p => ({ path: p, content: safeRead(p, maxBytes) }));
                panel?.webview.postMessage({ type: 'codeMany', entries });
                break;
            }
        }
    });
}

async function sendInitial(ws?: string) {
    if (!panel) return;
    if (!ws) { panel.webview.postMessage({ type: 'empty', reason: 'no-workspace' }); return; }

    const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
    const initialCapCfg: number = vscode.workspace.getConfiguration('codeCanvas').get('initialCap') ?? 25;

    // seeds = active editor + changed files
    const active = vscode.window.activeTextEditor?.document.uri.fsPath;
    const changed = (await getChangedFiles()).slice(0, 5);
    const seeds = Array.from(new Set([active, ...changed].filter(Boolean) as string[]));

    panel.webview.postMessage({ type: 'progress', msg: 'Indexing…' });
    const index = await (idxPromise ?? buildIndex(ws));
    panel.webview.postMessage({ type: 'progress', msg: null });

    const initialCap = Math.min(maxNodes, initialCapCfg);
    lastSeeds = seeds;
    lastCap = initialCap;
    const g: Graph = await subgraph(index, seeds, initialCap);
    if (!g.nodes.length) panel.webview.postMessage({ type: 'empty', reason: 'no-matched-files' });
    else panel.webview.postMessage({ type: 'graph', graph: g });
}

async function sendExpansion(ids: string[]) {
    if (!panel) return;
    const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
    const index = await idxPromise;
    if (!index) return;
    const g: Graph = await subgraph(index, ids, maxNodes);
    panel?.webview.postMessage({ type: 'expandResult', graph: g });
}

export function deactivate() { }

function toUri(u: unknown): vscode.Uri | undefined {
    try {
        if (!u) return undefined;
        if (u instanceof vscode.Uri) return u;
        const anyU = u as any;
        if (typeof anyU === 'object' && typeof anyU.scheme === 'string') {
            return vscode.Uri.from(anyU);
        }
        if (typeof u === 'string') {
            const s = u as string;
            if (/^[a-zA-Z]:[\\/]/.test(s)) {
                return vscode.Uri.file(s);
            }
            return vscode.Uri.parse(s);
        }
    } catch { }
    return undefined;
}

function isSubPath(parent: string, child: string): boolean {
    try {
        const parentNorm = path.resolve(parent);
        const childNorm = path.resolve(child);
        if (process.platform === 'win32') {
            const p = parentNorm.replace(/[\\/]+$/, '') + path.sep; // ensure trailing sep
            const c = childNorm;
            return c.toLowerCase().startsWith(p.toLowerCase());
        } else {
            const p = parentNorm.endsWith(path.sep) ? parentNorm : parentNorm + path.sep;
            return childNorm.startsWith(p);
        }
    } catch {
        return false;
    }
}

function safeRead(p: string, _limit: number): string {
    try {
        return fs.readFileSync(p, 'utf8');
    } catch {
        return '';
    }
}
```

## extension/src/git.ts

```typescript
﻿import * as vscode from 'vscode';

export async function getChangedFiles(): Promise<string[]> {
    // Prefer Git extension API if available
    const gitExt = vscode.extensions.getExtension('vscode.git');
    if (gitExt) {
        const api = (gitExt.isActive ? gitExt.exports : await gitExt.activate()).getAPI(1);
        const repo = api.repositories[0];
        if (repo) {
            const files = [
                ...repo.state.workingTreeChanges,
                ...repo.state.mergeChanges,
                ...repo.state.indexChanges
            ].map(c => c.uri.fsPath);
            return Array.from(new Set(files));
        }
    }
    // Fallback: simple status parse
    try {
        const cp = await import('child_process');
        const { stdout } = cp.spawnSync('git', ['status', '--porcelain'], { encoding: 'utf8' });
        return stdout.split('\n').filter(Boolean).map(line => line.slice(3)).filter(Boolean);
    } catch { return []; }
}

export function watchGitState(onChange: () => void) {
    const gitExt = vscode.extensions.getExtension('vscode.git');
    if (!gitExt) return () => { };
    const add = async () => {
        const api = (gitExt.isActive ? gitExt.exports : await gitExt.activate()).getAPI(1);
        const repo = api.repositories[0];
        if (!repo) return () => { };
        const d1 = repo.state.onDidChange(onChange);
        const d2 = api.onDidOpenRepository(onChange);
        const d3 = api.onDidChangeState(onChange);
        return () => { d1.dispose(); d2.dispose(); d3.dispose(); };
    };
    add();
    return () => { };
}
```

## extension/src/graph.ts

```typescript
﻿import fg from 'fast-glob';
import * as path from 'path';
import * as fs from 'fs';
import * as vscode from 'vscode';
import type { Graph, EdgeLink } from './util';
import { getDocumentSymbols } from './lsp';

const JS_GLOB = ['**/*.{js,jsx,ts,tsx}'];
const PY_GLOB = ['**/*.py'];

// Normalize paths to a canonical absolute form used for all map/set keys
function normalizePath(p: string): string {
    try {
        let out = path.resolve(p);
        if (process.platform === 'win32') {
            out = path.normalize(out);
            // Lowercase drive letter for consistency
            out = out.replace(/^([A-Z]):\\/, (m, d) => `${d.toLowerCase()}:\\`);
        }
        return out;
    } catch {
        return p;
    }
}

type Index = {
    nodes: Set<string>;
    imports: Map<string, Set<string>>; // file -> imported file paths (resolved)
    importLines: Map<string, Map<string, number[]>>; // file -> (resolved -> lines)
    lang: Map<string, 'js' | 'ts' | 'py' | 'other'>;
    // Detailed import entries to enable symbol-level mapping
    importEntries: Map<string, { spec: string; line: number }[]>; // per source file
};

export async function buildIndex(root: string): Promise<Index> {
    const excludes: string[] = vscode.workspace.getConfiguration('codeCanvas').get('excludeGlobs') || [];
    const rawFiles = Array.from(new Set([
        ...await fg(JS_GLOB, { cwd: root, absolute: true, ignore: excludes }),
        ...await fg(PY_GLOB, { cwd: root, absolute: true, ignore: excludes }),
    ]));
    const files = rawFiles.map(f => normalizePath(f));

    const lang = new Map<string, 'js' | 'ts' | 'py' | 'other'>();
    for (const f of files) {
        const ext = path.extname(f).toLowerCase();
        lang.set(
            f,
            ext === '.py' ? 'py'
                : (ext === '.ts' || ext === '.tsx') ? 'ts'
                    : (ext === '.js' || ext === '.jsx') ? 'js'
                        : 'other'
        );
    }

    const imports = new Map<string, Set<string>>();
    const importLines = new Map<string, Map<string, number[]>>();
    const importEntries = new Map<string, { spec: string; line: number }[]>();
    for (const f of files) {
        const src = safeRead(f);
        const specs = lang.get(f) === 'py' ? parsePyImportsWithLines(src) : parseJsTsImportsWithLines(src);
        const targets = new Set<string>();
        const lineMap = new Map<string, number[]>();
        importEntries.set(f, specs);
        for (const { spec, line } of specs) {
            const r = lang.get(f) === 'py' ? resolvePy(root, f, spec) : resolveJsTs(root, f, spec);
            if (!r) continue;
            const rNorm = normalizePath(r);
            targets.add(rNorm);
            const arr = lineMap.get(rNorm) || [];
            arr.push(line);
            lineMap.set(rNorm, arr);
        }
        imports.set(f, targets);
        importLines.set(f, lineMap);
    }

    return { nodes: new Set(files), imports, importLines, lang, importEntries };
}

// Build a subgraph with BFS from seeds up to max nodes/edges.
export async function subgraph(index: Index, seeds: string[], maxNodes: number): Promise<Graph> {
    const seen = new Set<string>();
    const q: string[] = [];
    for (const s of seeds) {
        const sNorm = normalizePath(s);
        if (index.nodes.has(sNorm)) { seen.add(sNorm); q.push(sNorm); }
    }

    // If no valid seeds, pick up to 10 random-ish files to start
    if (q.length === 0) {
        for (const f of Array.from(index.nodes).slice(0, Math.min(10, index.nodes.size))) {
            seen.add(f); q.push(f);
        }
    }

    while (q.length && seen.size < maxNodes) {
        const cur = q.shift()!;
        const out = index.imports.get(cur) || new Set();
        for (const t of out) {
            if (seen.size >= maxNodes) break;
            const tNorm = normalizePath(t);
            if (!index.nodes.has(tNorm)) continue;
            if (!seen.has(tNorm)) { seen.add(tNorm); q.push(tNorm); }
        }
        // add a bit of reverse reachability (files importing cur)
        for (const [f, outs] of index.imports) {
            if (outs.has(cur) && !seen.has(f)) {
                if (seen.size >= maxNodes) break;
                seen.add(f); q.push(f);
            }
        }
    }

    const nodes = Array.from(seen).map(f => ({
        id: makeSafeId(f),
        label: path.basename(f),
        path: f,
        lang: (index.lang.get(f) || 'other') as any
    }));

    const nodeIdByPath = new Map<string, string>();
    for (const n of nodes) nodeIdByPath.set(n.path, n.id);

    const edges: Graph['edges'] = [];
    const symbolCache = new Map<string, Awaited<ReturnType<typeof getDocumentSymbols>>>();
    const getSymbols = async (file: string) => {
        if (!symbolCache.has(file)) {
            const uri = vscode.Uri.file(file);
            symbolCache.set(file, await getDocumentSymbols(uri));
        }
        return symbolCache.get(file)!;
    };

    for (const s of seen) {
        const lineMap = index.importLines.get(s) || new Map();
        const entries = index.importEntries.get(s) || [];
        for (const t of (index.imports.get(s) || new Set())) {
            if (seen.has(t)) {
                const sid = nodeIdByPath.get(s)!;
                const tid = nodeIdByPath.get(t)!;
                const lines = lineMap.get(t) || [];
                const sourceLine = lines.length ? lines[0] : undefined;

                // Compute per-symbol target lines for this src->t relationship
                const links: EdgeLink[] = [];
                try {
                    const syms = await getSymbols(t);
                    // Find all import statements for this target file and map names heuristically
                    for (const { spec, line } of entries) {
                        const resolved = (index.lang.get(s) === 'py') ? resolvePy(path.dirname(s), s, spec) : resolveJsTs(path.dirname(s), s, spec);
                        const resolvedNorm = resolved ? normalizePath(resolved) : undefined;
                        if (resolvedNorm !== t) continue;
                        // Heuristic: try to split last path part as module name, but prefer matching symbols by name presence in the source file near import
                        // For Phase 2 scope, we will not fully parse named specifiers; instead, map to best top-level symbol (class/func/var) if unique, else fallback 0
                        let targetLine = 0;
                        const topLevel = syms.filter(sy => sy.range?.start?.line != null);
                        if (topLevel.length === 1) targetLine = topLevel[0].range.start.line;
                        else if (topLevel.length > 1) {
                            // pick first non-trivial symbol (Class, Function) if present
                            const preferred = topLevel.find(sy => sy.kind === vscode.SymbolKind.Class || sy.kind === vscode.SymbolKind.Function || sy.kind === vscode.SymbolKind.Method) || topLevel[0];
                            targetLine = preferred.range.start.line;
                        }
                        links.push({ symbolName: undefined, targetLine });
                    }
                } catch {
                    // Fallback: keep empty links
                }

                edges.push({ id: `e_${hashString(s + '->' + t + '#' + (sourceLine ?? -1))}`, source: sid, target: tid, kind: 'import', sourceLine, targetLine: links[0]?.targetLine ?? 0, links });
            }
        }
    }

    return { nodes, edges };
}

function safeRead(p: string) { try { return fs.readFileSync(p, 'utf8'); } catch { return ''; } }

function parseJsTsImportsWithLines(code: string): { spec: string; line: number }[] {
    const out: { spec: string; line: number }[] = [];
    const patterns = [
        /import\s+[^'\"]+from\s+['\"]([^'\"]+)['\"]/g,
        /import\s+['\"]([^'\"]+)['\"]/g,
        /export\s+[^'\"]*\s+from\s+['\"]([^'\"]+)['\"]/g
    ];
    for (const r of patterns) {
        let m: RegExpExecArray | null;
        while ((m = r.exec(code))) {
            const idx = m.index ?? 0;
            const line = code.slice(0, idx).split('\n').length - 1;
            out.push({ spec: m[1], line });
        }
    }
    return out;
}
function parsePyImportsWithLines(code: string): { spec: string; line: number }[] {
    const out: { spec: string; line: number }[] = [];
    let m: RegExpExecArray | null;
    const r1 = /^\s*import\s+([\w\.]+)/gm;
    const r2 = /^\s*from\s+([\w\.]+)\s+import\s+[\w\*,\s]+/gm;
    while ((m = r1.exec(code))) {
        const idx = m.index ?? 0;
        const line = code.slice(0, idx).split('\n').length - 1;
        out.push({ spec: m[1], line });
    }
    while ((m = r2.exec(code))) {
        const idx = m.index ?? 0;
        const line = code.slice(0, idx).split('\n').length - 1;
        out.push({ spec: m[1], line });
    }
    return out;
}

function resolveJsTs(root: string, fromFile: string, spec: string): string | undefined {
    if (!spec.startsWith('.') && !spec.startsWith('/')) return; // skip packages
    const base = path.resolve(path.dirname(fromFile), spec);
    const tries = ['', '.ts', '.tsx', '.js', '.jsx', '/index.ts', '/index.tsx', '/index.js', '/index.jsx'];
    for (const t of tries) { const p = base + t; if (fs.existsSync(p)) return normalizePath(p); }
}
function resolvePy(root: string, _from: string, mod: string): string | undefined {
    const parts = mod.split('.');
    const candidates = [
        path.resolve(root, ...parts) + '.py',
        path.resolve(root, ...parts, '__init__.py')
    ];
    for (const p of candidates) if (fs.existsSync(p)) return normalizePath(p);
}

function hashString(input: string): string {
    let hash = 0 >>> 0;
    for (let i = 0; i < input.length; i++) {
        hash = (hash * 31 + input.charCodeAt(i)) >>> 0;
    }
    return hash.toString(36);
}

function makeSafeId(raw: string): string {
    const safe = raw.replace(/[^a-zA-Z0-9_-]/g, '_');
    return `n_${safe}_${hashString(raw)}`;
}
```

## extension/src/lsp.ts

```typescript
﻿import * as vscode from 'vscode';

export async function getReferences(uri: vscode.Uri, position: vscode.Position) {
    const locs = await vscode.commands.executeCommand<vscode.Location[]>(
        'vscode.executeReferenceProvider', uri, position
    );
    return (locs || []).map(l => ({
        uri: l.uri.toString(),
        range: { start: l.range.start, end: l.range.end }
    }));
}

export async function getDefinition(uri: vscode.Uri, position: vscode.Position) {
    const defs = await vscode.commands.executeCommand<any>('vscode.executeDefinitionProvider', uri, position);
    return defs;
}

export async function getCallHierarchyIncoming(uri: vscode.Uri, position: vscode.Position) {
    const items = await vscode.commands.executeCommand<any>('vscode.prepareCallHierarchy', uri, position);
    if (!items || !items[0]) return [];
    const incoming = await vscode.commands.executeCommand<any>('vscode.provideIncomingCalls', items[0]);
    return incoming || [];
}

export async function getCallHierarchyOutgoing(uri: vscode.Uri, position: vscode.Position) {
    const items = await vscode.commands.executeCommand<any>('vscode.prepareCallHierarchy', uri, position);
    if (!items || !items[0]) return [];
    const outgoing = await vscode.commands.executeCommand<any>('vscode.provideOutgoingCalls', items[0]);
    return outgoing || [];
}

export type FlatSymbol = { name: string; kind: vscode.SymbolKind; range: vscode.Range };

export async function getDocumentSymbols(uri: vscode.Uri): Promise<FlatSymbol[]> {
    try {
        const symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(
            'vscode.executeDocumentSymbolProvider', uri
        );
        if (!symbols || !Array.isArray(symbols)) return [];
        const out: FlatSymbol[] = [];
        const visit = (items: vscode.DocumentSymbol[]) => {
            for (const s of items) {
                out.push({ name: s.name, kind: s.kind, range: s.selectionRange || s.range });
                if (s.children && s.children.length) visit(s.children);
            }
        };
        visit(symbols);
        return out;
    } catch {
        return [];
    }
}
```

## extension/src/util.ts

```typescript
﻿import * as vscode from 'vscode';
import * as fs from 'fs';

export type GraphNode = {
    id: string;
    label: string;
    path: string;
    lang: 'ts' | 'js' | 'tsx' | 'jsx' | 'py' | 'other';
};

export type EdgeLink = { symbolName?: string; targetLine: number };

export type GraphEdge = {
    id: string;
    source: string;
    target: string;
    kind: 'import' | 'call' | 'ref';
    sourceLine?: number;
    targetLine?: number;
    links?: EdgeLink[];
};

export type Graph = { nodes: GraphNode[]; edges: GraphEdge[] };

/**
 * Load the built webview HTML and rewrite asset URLs for the VS Code webview.
 * Handles both "/assets/..." and "./assets/...".
 */
export function htmlForWebview(
    panel: vscode.WebviewPanel,
    context: vscode.ExtensionContext
) {
    const media = vscode.Uri.joinPath(context.extensionUri, 'media');
    const index = vscode.Uri.joinPath(media, 'index.html');
    let html = fs.readFileSync(index.fsPath, 'utf8');

    const fix = (p: string) =>
        panel.webview
            .asWebviewUri(vscode.Uri.joinPath(media, p))
            .toString();

    html = html
        // rewrite src/href="./assets/..." and "/assets/..."
        .replace(/((?:src|href)=["'])\.?\/assets\//g, (_m, p1) => `${p1}${fix('assets/')}`)
        .replace(/__CSP__/g, panel.webview.cspSource);

    return html;
}
```

## extension/tsconfig.json

```json
﻿{
    "compilerOptions": {
        "target": "ES2022",
        "lib": [
            "ES2022"
        ],
        "module": "ESNext",
        "moduleResolution": "Node",
        "strict": true,
        "allowSyntheticDefaultImports": true,
        "skipLibCheck": true,
        "outDir": "dist",
        "rootDir": "src",
        "types": [
            "vscode",
            "node"
        ]
    },
    "include": [
        "src/**/*.ts"
    ]
}
```

## final_review_gate.py

```python
# final_review_gate.py
import sys
import os

if __name__ == "__main__":
    # Try to make stdout unbuffered for more responsive interaction.
    # This might not work on all platforms or if stdout is not a TTY,
    # but it's a good practice for this kind of interactive script.
    try:
        sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', buffering=1)
    except Exception:
        pass # Ignore if unbuffering fails, e.g., in certain environments

    try:
        sys.stderr = os.fdopen(sys.stderr.fileno(), 'w', buffering=1)
    except Exception:
        pass # Ignore

    print("--- FINAL REVIEW GATE ACTIVE ---", flush=True)
    print("AI has completed its primary actions. Awaiting your review or further sub-prompts.", flush=True)
    print("Type your sub-prompt, or one of: 'TASK_COMPLETE', 'Done', 'Quit', 'q' to signal completion.", flush=True) # MODIFIED
    
    active_session = True
    while active_session:
        try:
            # Signal that the script is ready for input.
            # The AI doesn't need to parse this, but it's good for user visibility.
            print("REVIEW_GATE_AWAITING_INPUT:", end="", flush=True) 
            
            line = sys.stdin.readline()
            
            if not line:  # EOF
                print("--- REVIEW GATE: STDIN CLOSED (EOF), EXITING SCRIPT ---", flush=True)
                active_session = False
                break
            
            user_input = line.strip()

            # Check for exit conditions
            if user_input.upper() in ['TASK_COMPLETE', 'DONE', 'QUIT', 'Q']: # MODIFIED: Empty string no longer exits
                print(f"--- REVIEW GATE: USER SIGNALED COMPLETION WITH '{user_input.upper()}' ---", flush=True)
                active_session = False
                break
            elif user_input: # If there's any other non-empty input (and not a completion command)
                # This is the critical line the AI will "listen" for.
                print(f"USER_REVIEW_SUB_PROMPT: {user_input}", flush=True)
            # If user_input was empty (and not a completion command),
            # the loop simply continues, and "REVIEW_GATE_AWAITING_INPUT:" will be printed again.
            
        except KeyboardInterrupt:
            print("--- REVIEW GATE: SESSION INTERRUPTED BY USER (KeyboardInterrupt) ---", flush=True)
            active_session = False
            break
        except Exception as e:
            print(f"--- REVIEW GATE SCRIPT ERROR: {e} ---", flush=True)
            active_session = False
            break
            
    print("--- FINAL REVIEW GATE SCRIPT EXITED ---", flush=True)
```

## package.json

```json
{
  "name": "code-canvas",
  "private": true,
  "version": "1.0.0",
  "description": "Code Canvas",
  "main": "index.js",
  "scripts": {
    "build": "npm -w webview run build && npm -w extension run build",
    "watch": "npm -w webview run dev & npm -w extension run watch",
    "package": "npm -w extension run package"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "workspaces": [
    "webview",
    "extension"
  ],
  "overrides": {}
}
```

## README.md

```markdown
﻿# paste: README.md
```

## repomix-output.md

````````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-15 09:49:42

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.gitignore
extension
  media
    assets
      index-1u4Gp6IV.js
      index-DOkYKv7m.css
    index.html
  package.json
  src
    extension.ts
    git.ts
    graph.ts
    lsp.ts
    util.ts
  tsconfig.json
final_review_gate.py
package.json
README.md
repomix-output.md
webview
  index.html
  package.json
  src
    App.tsx
    code
      CodeCard.tsx
      highlight.ts
    layout.ts
    main.tsx
    reactflow-node-types.tsx
    styles.css
  tsconfig.json
  vite.config.ts
```

# Repository Files


## .gitignore

```text
/final_review_gate.py
node_modules
```

## extension/media/assets/index-DOkYKv7m.css

```css
/* this gets exported as style.css and can be used for the default theming */
/* these are the necessary styles for React Flow, they get used by base.css and style.css */
.react-flow {
  direction: ltr;
}
.react-flow__container {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
}
.react-flow__pane {
  z-index: 1;
  cursor: -webkit-grab;
  cursor: grab;
}
.react-flow__pane.selection {
    cursor: pointer;
  }
.react-flow__pane.dragging {
    cursor: -webkit-grabbing;
    cursor: grabbing;
  }
.react-flow__viewport {
  transform-origin: 0 0;
  z-index: 2;
  pointer-events: none;
}
.react-flow__renderer {
  z-index: 4;
}
.react-flow__selection {
  z-index: 6;
}
.react-flow__nodesselection-rect:focus,
.react-flow__nodesselection-rect:focus-visible {
  outline: none;
}
.react-flow .react-flow__edges {
  pointer-events: none;
  overflow: visible;
}
.react-flow__edge-path,
.react-flow__connection-path {
  stroke: #b1b1b7;
  stroke-width: 1;
  fill: none;
}
.react-flow__edge {
  pointer-events: visibleStroke;
  cursor: pointer;
}
.react-flow__edge.animated path {
    stroke-dasharray: 5;
    -webkit-animation: dashdraw 0.5s linear infinite;
            animation: dashdraw 0.5s linear infinite;
  }
.react-flow__edge.animated path.react-flow__edge-interaction {
    stroke-dasharray: none;
    -webkit-animation: none;
            animation: none;
  }
.react-flow__edge.inactive {
    pointer-events: none;
  }
.react-flow__edge.selected,
  .react-flow__edge:focus,
  .react-flow__edge:focus-visible {
    outline: none;
  }
.react-flow__edge.selected .react-flow__edge-path,
  .react-flow__edge:focus .react-flow__edge-path,
  .react-flow__edge:focus-visible .react-flow__edge-path {
    stroke: #555;
  }
.react-flow__edge-textwrapper {
    pointer-events: all;
  }
.react-flow__edge-textbg {
    fill: white;
  }
.react-flow__edge .react-flow__edge-text {
    pointer-events: none;
    -webkit-user-select: none;
       -moz-user-select: none;
            user-select: none;
  }
.react-flow__connection {
  pointer-events: none;
}
.react-flow__connection .animated {
    stroke-dasharray: 5;
    -webkit-animation: dashdraw 0.5s linear infinite;
            animation: dashdraw 0.5s linear infinite;
  }
.react-flow__connectionline {
  z-index: 1001;
}
.react-flow__nodes {
  pointer-events: none;
  transform-origin: 0 0;
}
.react-flow__node {
  position: absolute;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
  pointer-events: all;
  transform-origin: 0 0;
  box-sizing: border-box;
  cursor: -webkit-grab;
  cursor: grab;
}
.react-flow__node.dragging {
    cursor: -webkit-grabbing;
    cursor: grabbing;
  }
.react-flow__nodesselection {
  z-index: 3;
  transform-origin: left top;
  pointer-events: none;
}
.react-flow__nodesselection-rect {
    position: absolute;
    pointer-events: all;
    cursor: -webkit-grab;
    cursor: grab;
  }
.react-flow__handle {
  position: absolute;
  pointer-events: none;
  min-width: 5px;
  min-height: 5px;
  width: 6px;
  height: 6px;
  background: #1a192b;
  border: 1px solid white;
  border-radius: 100%;
}
.react-flow__handle.connectionindicator {
    pointer-events: all;
    cursor: crosshair;
  }
.react-flow__handle-bottom {
    top: auto;
    left: 50%;
    bottom: -4px;
    transform: translate(-50%, 0);
  }
.react-flow__handle-top {
    left: 50%;
    top: -4px;
    transform: translate(-50%, 0);
  }
.react-flow__handle-left {
    top: 50%;
    left: -4px;
    transform: translate(0, -50%);
  }
.react-flow__handle-right {
    right: -4px;
    top: 50%;
    transform: translate(0, -50%);
  }
.react-flow__edgeupdater {
  cursor: move;
  pointer-events: all;
}
.react-flow__panel {
  position: absolute;
  z-index: 5;
  margin: 15px;
}
.react-flow__panel.top {
    top: 0;
  }
.react-flow__panel.bottom {
    bottom: 0;
  }
.react-flow__panel.left {
    left: 0;
  }
.react-flow__panel.right {
    right: 0;
  }
.react-flow__panel.center {
    left: 50%;
    transform: translateX(-50%);
  }
.react-flow__attribution {
  font-size: 10px;
  background: rgba(255, 255, 255, 0.5);
  padding: 2px 3px;
  margin: 0;
}
.react-flow__attribution a {
    text-decoration: none;
    color: #999;
  }
@-webkit-keyframes dashdraw {
  from {
    stroke-dashoffset: 10;
  }
}
@keyframes dashdraw {
  from {
    stroke-dashoffset: 10;
  }
}
.react-flow__edgelabel-renderer {
  position: absolute;
  width: 100%;
  height: 100%;
  pointer-events: none;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
}
.react-flow__edge.updating .react-flow__edge-path {
      stroke: #777;
    }
.react-flow__edge-text {
    font-size: 10px;
  }
.react-flow__node.selectable:focus,
  .react-flow__node.selectable:focus-visible {
    outline: none;
  }
.react-flow__node-default,
.react-flow__node-input,
.react-flow__node-output,
.react-flow__node-group {
  padding: 10px;
  border-radius: 3px;
  width: 150px;
  font-size: 12px;
  color: #222;
  text-align: center;
  border-width: 1px;
  border-style: solid;
  border-color: #1a192b;
  background-color: white;
}
.react-flow__node-default.selectable:hover, .react-flow__node-input.selectable:hover, .react-flow__node-output.selectable:hover, .react-flow__node-group.selectable:hover {
      box-shadow: 0 1px 4px 1px rgba(0, 0, 0, 0.08);
    }
.react-flow__node-default.selectable.selected,
    .react-flow__node-default.selectable:focus,
    .react-flow__node-default.selectable:focus-visible,
    .react-flow__node-input.selectable.selected,
    .react-flow__node-input.selectable:focus,
    .react-flow__node-input.selectable:focus-visible,
    .react-flow__node-output.selectable.selected,
    .react-flow__node-output.selectable:focus,
    .react-flow__node-output.selectable:focus-visible,
    .react-flow__node-group.selectable.selected,
    .react-flow__node-group.selectable:focus,
    .react-flow__node-group.selectable:focus-visible {
      box-shadow: 0 0 0 0.5px #1a192b;
    }
.react-flow__node-group {
  background-color: rgba(240, 240, 240, 0.25);
}
.react-flow__nodesselection-rect,
.react-flow__selection {
  background: rgba(0, 89, 220, 0.08);
  border: 1px dotted rgba(0, 89, 220, 0.8);
}
.react-flow__nodesselection-rect:focus,
  .react-flow__nodesselection-rect:focus-visible,
  .react-flow__selection:focus,
  .react-flow__selection:focus-visible {
    outline: none;
  }
.react-flow__controls {
  box-shadow: 0 0 2px 1px rgba(0, 0, 0, 0.08);
}
.react-flow__controls-button {
    border: none;
    background: #fefefe;
    border-bottom: 1px solid #eee;
    box-sizing: content-box;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 16px;
    height: 16px;
    cursor: pointer;
    -webkit-user-select: none;
       -moz-user-select: none;
            user-select: none;
    padding: 5px;
  }
.react-flow__controls-button:hover {
      background: #f4f4f4;
    }
.react-flow__controls-button svg {
      width: 100%;
      max-width: 12px;
      max-height: 12px;
    }
.react-flow__controls-button:disabled {
      pointer-events: none;
    }
.react-flow__controls-button:disabled svg {
        fill-opacity: 0.4;
      }
.react-flow__minimap {
  background-color: #fff;
}
.react-flow__minimap svg {
  display: block;
}
.react-flow__resize-control {
  position: absolute;
}
.react-flow__resize-control.left,
.react-flow__resize-control.right {
  cursor: ew-resize;
}
.react-flow__resize-control.top,
.react-flow__resize-control.bottom {
  cursor: ns-resize;
}
.react-flow__resize-control.top.left,
.react-flow__resize-control.bottom.right {
  cursor: nwse-resize;
}
.react-flow__resize-control.bottom.left,
.react-flow__resize-control.top.right {
  cursor: nesw-resize;
}
/* handle styles */
.react-flow__resize-control.handle {
  width: 4px;
  height: 4px;
  border: 1px solid #fff;
  border-radius: 1px;
  background-color: #3367d9;
  transform: translate(-50%, -50%);
}
.react-flow__resize-control.handle.left {
  left: 0;
  top: 50%;
}
.react-flow__resize-control.handle.right {
  left: 100%;
  top: 50%;
}
.react-flow__resize-control.handle.top {
  left: 50%;
  top: 0;
}
.react-flow__resize-control.handle.bottom {
  left: 50%;
  top: 100%;
}
.react-flow__resize-control.handle.top.left {
  left: 0;
}
.react-flow__resize-control.handle.bottom.left {
  left: 0;
}
.react-flow__resize-control.handle.top.right {
  left: 100%;
}
.react-flow__resize-control.handle.bottom.right {
  left: 100%;
}
/* line styles */
.react-flow__resize-control.line {
  border-color: #3367d9;
  border-width: 0;
  border-style: solid;
}
.react-flow__resize-control.line.left,
.react-flow__resize-control.line.right {
  width: 1px;
  transform: translate(-50%, 0);
  top: 0;
  height: 100%;
}
.react-flow__resize-control.line.left {
  left: 0;
  border-left-width: 1px;
}
.react-flow__resize-control.line.right {
  left: 100%;
  border-right-width: 1px;
}
.react-flow__resize-control.line.top,
.react-flow__resize-control.line.bottom {
  height: 1px;
  transform: translate(0, -50%);
  left: 0;
  width: 100%;
}
.react-flow__resize-control.line.top {
  top: 0;
  border-top-width: 1px;
}
.react-flow__resize-control.line.bottom {
  border-bottom-width: 1px;
  top: 100%;
}
:root {
    color-scheme: dark;
    --ease-smooth: cubic-bezier(0.22, 1, 0.36, 1);
    --zoom-duration: 320ms;
}

body,
html,
#root {
    margin: 0;
    height: 100%;
    background: #0b0e12;
    color: #cdd6f4;
    font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Inter, sans-serif;
}

.root {
    height: 100%;
}

.toolbar {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    display: flex;
    gap: 6px;
}

.toolbar button {
    background: #111827;
    border: 1px solid #1f2937;
    color: #e5e7eb;
    padding: 6px 10px;
    border-radius: 8px;
    cursor: pointer;
}

.file-node {
    width: 100%;
    height: 100%;
    background: #0d1117;
    border: 1px solid #1f2937;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 0 0 1px #0b1220 inset;
}

.file-node-header {
    background: #0b1220;
    padding: 6px 10px;
    font-weight: 600;
    font-size: 12px;
    letter-spacing: .3px;
    border-bottom: 1px solid #1f2937;
    cursor: grab;
}

.code-card {
    height: calc(100% - 30px);
    overflow: auto;
}

.code-card .file-title {
    display: none;
}

pre.hljs {
    margin: 0;
    padding: 8px 10px 8px 56px;
    /* leave space for gutter */
    font-size: 12px;
    line-height: 1.35;
    position: relative;
    counter-reset: line;
}

pre.hljs .code-line {
    display: block;
    counter-increment: line;
    position: relative;
}

pre.hljs .code-line::before {
    content: counter(line);
    position: absolute;
    left: -44px;
    width: 36px;
    text-align: right;
    color: #6b7280;
    opacity: 0.9;
}

pre.hljs .code-line.highlight {
    background: rgba(255, 214, 10, 0.15);
    outline: 1px solid rgba(255, 214, 10, 0.35);
}

pre.hljs.wrap {
    white-space: pre-wrap;
}

.preview {
    font-size: 11px;
    opacity: .8;
    padding: 8px;
}

/* Improve MiniMap visibility */
.react-flow__minimap {
    background: #0f1115 !important;
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.06) inset;
}

.react-flow__minimap-mask {
    fill: rgba(255, 255, 255, 0.06) !important;
}

.react-flow__minimap-node {
    fill: #4f46e5 !important;
    stroke: rgba(255, 255, 255, 0.2) !important;
}

/* Allow extreme zooming */
.react-flow__renderer,
.react-flow__viewport {
    will-change: transform;
}

/* Smooth node transitions for layout/elevation changes */
.react-flow__node {
    transition: transform 220ms cubic-bezier(0.22, 1, 0.36, 1), opacity 160ms ease;
    will-change: transform;
}

/* Disable transition while dragging to keep the interaction snappy */
.react-flow__node.no-animate {
    transition: none !important;
}

@media (prefers-reduced-motion: reduce) {
    .react-flow__node {
        transition: none !important;
    }
}

/* Smooth transform transitions for the React Flow viewport (zoom smoothing) */
.react-flow__viewport {
    transition: none;
}

.react-flow__viewport.zoom-smooth {
    transition: transform var(--zoom-duration) var(--ease-smooth);
}

/* Disable smoothing during pans/drags for snappy feel */
.react-flow__viewport.no-animate {
    transition: none !important;
}

/* Placeholder body shown when code is hidden for performance */
.node-placeholder-body {
    height: calc(100% - 30px);
    display: grid;
    place-items: center;
    color: #94a3b8;
    font-size: 12px;
    opacity: 0.9;
}

/* Defer offscreen work for heavy node content */
.code-card {
    content-visibility: auto;
    contain-intrinsic-size: 480px 280px;
    contain: layout paint size;
}

/* Promote nodes to their own layer to reduce flicker during viewport moves */
.file-node {
    backface-visibility: hidden;
    transform: translateZ(0);
}pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 1em
}
code.hljs {
  padding: 3px 5px
}
/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/
.hljs {
  color: #c9d1d9;
  background: #0d1117
}
.hljs-doctag,
.hljs-keyword,
.hljs-meta .hljs-keyword,
.hljs-template-tag,
.hljs-template-variable,
.hljs-type,
.hljs-variable.language_ {
  /* prettylights-syntax-keyword */
  color: #ff7b72
}
.hljs-title,
.hljs-title.class_,
.hljs-title.class_.inherited__,
.hljs-title.function_ {
  /* prettylights-syntax-entity */
  color: #d2a8ff
}
.hljs-attr,
.hljs-attribute,
.hljs-literal,
.hljs-meta,
.hljs-number,
.hljs-operator,
.hljs-variable,
.hljs-selector-attr,
.hljs-selector-class,
.hljs-selector-id {
  /* prettylights-syntax-constant */
  color: #79c0ff
}
.hljs-regexp,
.hljs-string,
.hljs-meta .hljs-string {
  /* prettylights-syntax-string */
  color: #a5d6ff
}
.hljs-built_in,
.hljs-symbol {
  /* prettylights-syntax-variable */
  color: #ffa657
}
.hljs-comment,
.hljs-code,
.hljs-formula {
  /* prettylights-syntax-comment */
  color: #8b949e
}
.hljs-name,
.hljs-quote,
.hljs-selector-tag,
.hljs-selector-pseudo {
  /* prettylights-syntax-entity-tag */
  color: #7ee787
}
.hljs-subst {
  /* prettylights-syntax-storage-modifier-import */
  color: #c9d1d9
}
.hljs-section {
  /* prettylights-syntax-markup-heading */
  color: #1f6feb;
  font-weight: bold
}
.hljs-bullet {
  /* prettylights-syntax-markup-list */
  color: #f2cc60
}
.hljs-emphasis {
  /* prettylights-syntax-markup-italic */
  color: #c9d1d9;
  font-style: italic
}
.hljs-strong {
  /* prettylights-syntax-markup-bold */
  color: #c9d1d9;
  font-weight: bold
}
.hljs-addition {
  /* prettylights-syntax-markup-inserted */
  color: #aff5b4;
  background-color: #033a16
}
.hljs-deletion {
  /* prettylights-syntax-markup-deleted */
  color: #ffdcd7;
  background-color: #67060c
}
.hljs-char.escape_,
.hljs-link,
.hljs-params,
.hljs-property,
.hljs-punctuation,
.hljs-tag {
  /* purposely ignored */
  
}
```

## extension/media/index.html

```html
<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; img-src vscode-resource: https: data:; style-src 'unsafe-inline' __CSP__; script-src __CSP__; font-src __CSP__; connect-src __CSP__;" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Code Canvas</title>
  <script type="module" crossorigin src="./assets/index-1u4Gp6IV.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-DOkYKv7m.css">
</head>

<body>
    <div id="root"></div>

</body>

</html>
```

## extension/package.json

```json
{
    "name": "code-canvas",
    "displayName": "Code Canvas",
    "publisher": "code-canvas",
    "version": "0.0.1",
    "engines": {
        "vscode": "^1.90.0"
    },
    "categories": [
        "Other"
    ],
    "activationEvents": [
        "onStartupFinished"
    ],
    "main": "dist/extension.js",
    "contributes": {
        "commands": [
            {
                "command": "codeCanvas.open",
                "title": "Code Canvas: Open"
            },
            {
                "command": "codeCanvas.openChanged",
                "title": "Code Canvas: Open Changed Files"
            },
            {
                "command": "codeCanvas.layout.custom",
                "title": "Code Canvas: Layout – Custom"
            },
            {
                "command": "codeCanvas.layout.dagre",
                "title": "Code Canvas: Layout – Dagre"
            },
            {
                "command": "codeCanvas.layout.elk",
                "title": "Code Canvas: Layout – ELK"
            },
            {
                "command": "codeCanvas.layout.force",
                "title": "Code Canvas: Layout – Force"
            },
            {
                "command": "codeCanvas.toggleRefs",
                "title": "Code Canvas: Toggle Refs"
            },
            {
                "command": "codeCanvas.seedFolder",
                "title": "Code Canvas: Open Folder as Seed"
            },
            {
                "command": "codeCanvas.loadMore",
                "title": "Code Canvas: Load 25 More"
            }
        ],
        "keybindings": [
            {
                "command": "codeCanvas.openChanged",
                "key": "shift+o"
            },
            {
                "command": "codeCanvas.loadMore",
                "key": "shift+plus"
            },
            {
                "command": "codeCanvas.layout.custom",
                "key": "shift+1"
            },
            {
                "command": "codeCanvas.layout.dagre",
                "key": "shift+2"
            },
            {
                "command": "codeCanvas.layout.elk",
                "key": "shift+3"
            },
            {
                "command": "codeCanvas.layout.force",
                "key": "shift+4"
            },
            {
                "command": "codeCanvas.toggleRefs",
                "key": "r"
            }
        ],
        "configuration": {
            "title": "Code Canvas",
            "properties": {
                "codeCanvas.maxNodes": {
                    "type": "number",
                    "default": 300,
                    "description": "Maximum nodes to render per subgraph."
                },
                "codeCanvas.excludeGlobs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "default": [
                        "**/node_modules/**",
                        "**/.venv/**",
                        "**/__pycache__/**",
                        "**/dist/**",
                        "**/build/**",
                        "**/.git/**"
                    ],
                    "description": "Extra glob patterns to exclude from indexing."
                },
                "codeCanvas.maxPreviewBytes": {
                    "type": "number",
                    "default": 100000,
                    "description": "Maximum number of bytes of file content to send to the webview for preview per file."
                },
                "codeCanvas.initialCap": {
                    "type": "number",
                    "default": 25,
                    "description": "Initial maximum number of nodes to show when first rendering a graph."
                }
            }
        }
    },
    "scripts": {
        "vscode:prepublish": "npm run build",
        "build": "tsup src/extension.ts --format cjs --dts --out-dir dist --external vscode",
        "watch": "tsup src/extension.ts --watch --format cjs --out-dir dist",
        "package": "vsce package"
    },
    "dependencies": {
        "fast-glob": "^3.3.2",
        "minimatch": "^9.0.5"
    },
    "devDependencies": {
        "@types/node": "^24.2.1",
        "@types/vscode": "^1.102.0",
        "@vscode/vsce": "^3.6.0",
        "tsup": "^8.5.0",
        "typescript": "^5.6"
    }
}
```

## extension/src/extension.ts

```typescript
﻿import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { htmlForWebview, Graph } from './util';
import { buildIndex, subgraph } from './graph';
import { getChangedFiles, watchGitState } from './git';
import * as lsp from './lsp';

let panel: vscode.WebviewPanel | undefined;
let idxPromise: ReturnType<typeof buildIndex> | undefined;
let lastSeeds: string[] = [];
let lastCap: number = 0;

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('codeCanvas.open', () => openPanel(context)),
        vscode.commands.registerCommand('codeCanvas.openChanged', async () => {
            await ensurePanel(context);
            const files = await getChangedFiles();
            panel?.webview.postMessage({ type: 'openChanged', files });
        }),
        vscode.commands.registerCommand('codeCanvas.layout.custom', () => panel?.webview.postMessage({ type: 'layout', algo: 'custom' })),
        vscode.commands.registerCommand('codeCanvas.layout.dagre', () => panel?.webview.postMessage({ type: 'layout', algo: 'dagre' })),
        vscode.commands.registerCommand('codeCanvas.layout.elk', () => panel?.webview.postMessage({ type: 'layout', algo: 'elk' })),
        vscode.commands.registerCommand('codeCanvas.layout.force', () => panel?.webview.postMessage({ type: 'layout', algo: 'force' })),
        vscode.commands.registerCommand('codeCanvas.toggleRefs', () => panel?.webview.postMessage({ type: 'toggleRefs' })),
        vscode.commands.registerCommand('codeCanvas.seedFolder', async () => {
            await ensurePanel(context);
            const picked = await vscode.window.showOpenDialog({ canSelectFiles: false, canSelectFolders: true, canSelectMany: false, openLabel: 'Use Folder as Seed' });
            if (!picked || !picked[0]) return;
            const folder = picked[0].fsPath;
            const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
            if (root && !idxPromise) idxPromise = buildIndex(root);
            const index = await idxPromise;
            if (!index) return;
            const folderNorm = path.resolve(folder);
            const seeds = Array.from(index.nodes).filter(p => isSubPath(folderNorm, p));
            if (!seeds.length) {
                vscode.window.showInformationMessage('Code Canvas: No files found under selected folder.');
                return;
            }
            const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
            const initialCapCfg: number = vscode.workspace.getConfiguration('codeCanvas').get('initialCap') ?? 25;
            const cap = Math.min(maxNodes, initialCapCfg);
            lastSeeds = seeds;
            lastCap = cap;
            const g: Graph = await subgraph(index, seeds, cap);
            panel?.webview.postMessage({ type: 'graph', graph: g });
        }),
        vscode.commands.registerCommand('codeCanvas.loadMore', async () => {
            await ensurePanel(context);
            if (!lastSeeds.length) return;
            const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
            if (root && !idxPromise) idxPromise = buildIndex(root);
            const index = await idxPromise;
            if (!index) return;
            const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
            const nextCap = Math.min(maxNodes, lastCap + 25);
            lastCap = nextCap;
            const g: Graph = await subgraph(index, lastSeeds, nextCap);
            panel?.webview.postMessage({ type: 'graph', graph: g });
        })
    );

    vscode.workspace.onDidChangeTextDocument(async (e) => {
        if (!panel) return;
        panel.webview.postMessage({ type: 'docChanged', file: e.document.uri.fsPath });
    });

    watchGitState(async () => {
        if (!panel) return;
        const files = await getChangedFiles();
        panel.webview.postMessage({ type: 'gitChanged', files });
    });
}

async function ensurePanel(context: vscode.ExtensionContext) { if (!panel) openPanel(context); }

function openPanel(context: vscode.ExtensionContext) {
    const column = vscode.ViewColumn.Beside;
    panel = vscode.window.createWebviewPanel('codeCanvas', 'Code Canvas', column, {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [vscode.Uri.joinPath(context.extensionUri, 'media')]
    });
    panel.webview.html = htmlForWebview(panel, context);
    panel.onDidDispose(() => panel = undefined);

    // kick off indexing
    const ws = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
    if (ws) idxPromise = buildIndex(ws);

    setTimeout(() => sendInitial(ws), 150);

    panel.webview.onDidReceiveMessage(async (msg) => {
        switch (msg.type) {
            case 'requestGraph': await sendInitial(ws); break;
            case 'expand': await sendExpansion(msg.ids || []); break;
            case 'loadMore': {
                const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
                if (root && !idxPromise) idxPromise = buildIndex(root);
                const index = await idxPromise;
                if (!index || !lastSeeds.length) break;
                const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
                const nextCap = Math.min(maxNodes, lastCap + 25);
                lastCap = nextCap;
                const g: Graph = await subgraph(index, lastSeeds, nextCap);
                panel?.webview.postMessage({ type: 'graph', graph: g });
                break;
            }
            case 'openFile': {
                const uri = vscode.Uri.file(msg.path);
                vscode.window.showTextDocument(uri, { preview: false });
                break;
            }
            case 'toggleEdges': {
                panel?.webview.postMessage({ type: 'toggleEdges' });
                break;
            }
            case 'requestChanged': {
                const files = await getChangedFiles();
                panel?.webview.postMessage({ type: 'changedFiles', files });
                break;
            }
            case 'requestRefs': {
                const { path, line, character } = msg;
                const uri = vscode.Uri.file(path);
                const refs = await lsp.getReferences(uri, new vscode.Position(line, character));
                panel?.webview.postMessage({ type: 'refs', at: { path, line, character }, refs });
                break;
            }
            case 'requestDefOpen': {
                const { path, line, character } = msg;
                const fromUri = vscode.Uri.file(path);
                const defs = await lsp.getDefinition(fromUri, new vscode.Position(line, character));
                const loc = Array.isArray(defs) ? defs[0] : defs;
                if (loc) {
                    let openUri: vscode.Uri | undefined;
                    let range: vscode.Range | undefined;
                    const anyLoc = loc as any;
                    if (anyLoc.targetUri) {
                        openUri = toUri(anyLoc.targetUri);
                        range = (anyLoc.targetSelectionRange || anyLoc.targetRange) as vscode.Range | undefined;
                    } else if (anyLoc.uri) {
                        openUri = toUri(anyLoc.uri);
                        range = anyLoc.range as vscode.Range | undefined;
                    }
                    if (openUri) await vscode.window.showTextDocument(openUri, { preview: false, selection: range });
                }
                break;
            }
            case 'requestCode': {
                const { path } = msg;
                const maxBytes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxPreviewBytes') ?? 100_000;
                const content = safeRead(path, maxBytes);
                panel?.webview.postMessage({ type: 'code', path, content });
                break;
            }
            case 'requestCodeMany': {
                const { paths } = msg as { paths: string[] };
                const maxBytes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxPreviewBytes') ?? 100_000;
                const entries = (paths || []).map(p => ({ path: p, content: safeRead(p, maxBytes) }));
                panel?.webview.postMessage({ type: 'codeMany', entries });
                break;
            }
        }
    });
}

async function sendInitial(ws?: string) {
    if (!panel) return;
    if (!ws) { panel.webview.postMessage({ type: 'empty', reason: 'no-workspace' }); return; }

    const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
    const initialCapCfg: number = vscode.workspace.getConfiguration('codeCanvas').get('initialCap') ?? 25;

    // seeds = active editor + changed files
    const active = vscode.window.activeTextEditor?.document.uri.fsPath;
    const changed = (await getChangedFiles()).slice(0, 5);
    const seeds = Array.from(new Set([active, ...changed].filter(Boolean) as string[]));

    panel.webview.postMessage({ type: 'progress', msg: 'Indexing…' });
    const index = await (idxPromise ?? buildIndex(ws));
    panel.webview.postMessage({ type: 'progress', msg: null });

    const initialCap = Math.min(maxNodes, initialCapCfg);
    lastSeeds = seeds;
    lastCap = initialCap;
    const g: Graph = await subgraph(index, seeds, initialCap);
    if (!g.nodes.length) panel.webview.postMessage({ type: 'empty', reason: 'no-matched-files' });
    else panel.webview.postMessage({ type: 'graph', graph: g });
}

async function sendExpansion(ids: string[]) {
    if (!panel) return;
    const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
    const index = await idxPromise;
    if (!index) return;
    const g: Graph = await subgraph(index, ids, maxNodes);
    panel?.webview.postMessage({ type: 'expandResult', graph: g });
}

export function deactivate() { }

function toUri(u: unknown): vscode.Uri | undefined {
    try {
        if (!u) return undefined;
        if (u instanceof vscode.Uri) return u;
        const anyU = u as any;
        if (typeof anyU === 'object' && typeof anyU.scheme === 'string') {
            return vscode.Uri.from(anyU);
        }
        if (typeof u === 'string') {
            const s = u as string;
            if (/^[a-zA-Z]:[\\/]/.test(s)) {
                return vscode.Uri.file(s);
            }
            return vscode.Uri.parse(s);
        }
    } catch { }
    return undefined;
}

function isSubPath(parent: string, child: string): boolean {
    try {
        const parentNorm = path.resolve(parent);
        const childNorm = path.resolve(child);
        if (process.platform === 'win32') {
            const p = parentNorm.replace(/[\\/]+$/, '') + path.sep; // ensure trailing sep
            const c = childNorm;
            return c.toLowerCase().startsWith(p.toLowerCase());
        } else {
            const p = parentNorm.endsWith(path.sep) ? parentNorm : parentNorm + path.sep;
            return childNorm.startsWith(p);
        }
    } catch {
        return false;
    }
}

function safeRead(p: string, _limit: number): string {
    try {
        return fs.readFileSync(p, 'utf8');
    } catch {
        return '';
    }
}
```

## extension/src/git.ts

```typescript
﻿import * as vscode from 'vscode';

export async function getChangedFiles(): Promise<string[]> {
    // Prefer Git extension API if available
    const gitExt = vscode.extensions.getExtension('vscode.git');
    if (gitExt) {
        const api = (gitExt.isActive ? gitExt.exports : await gitExt.activate()).getAPI(1);
        const repo = api.repositories[0];
        if (repo) {
            const files = [
                ...repo.state.workingTreeChanges,
                ...repo.state.mergeChanges,
                ...repo.state.indexChanges
            ].map(c => c.uri.fsPath);
            return Array.from(new Set(files));
        }
    }
    // Fallback: simple status parse
    try {
        const cp = await import('child_process');
        const { stdout } = cp.spawnSync('git', ['status', '--porcelain'], { encoding: 'utf8' });
        return stdout.split('\n').filter(Boolean).map(line => line.slice(3)).filter(Boolean);
    } catch { return []; }
}

export function watchGitState(onChange: () => void) {
    const gitExt = vscode.extensions.getExtension('vscode.git');
    if (!gitExt) return () => { };
    const add = async () => {
        const api = (gitExt.isActive ? gitExt.exports : await gitExt.activate()).getAPI(1);
        const repo = api.repositories[0];
        if (!repo) return () => { };
        const d1 = repo.state.onDidChange(onChange);
        const d2 = api.onDidOpenRepository(onChange);
        const d3 = api.onDidChangeState(onChange);
        return () => { d1.dispose(); d2.dispose(); d3.dispose(); };
    };
    add();
    return () => { };
}
```

## extension/src/graph.ts

```typescript
﻿import fg from 'fast-glob';
import * as path from 'path';
import * as fs from 'fs';
import * as vscode from 'vscode';
import type { Graph, EdgeLink } from './util';
import { getDocumentSymbols } from './lsp';

const JS_GLOB = ['**/*.{js,jsx,ts,tsx}'];
const PY_GLOB = ['**/*.py'];

// Normalize paths to a canonical absolute form used for all map/set keys
function normalizePath(p: string): string {
    try {
        let out = path.resolve(p);
        if (process.platform === 'win32') {
            out = path.normalize(out);
            // Lowercase drive letter for consistency
            out = out.replace(/^([A-Z]):\\/, (m, d) => `${d.toLowerCase()}:\\`);
        }
        return out;
    } catch {
        return p;
    }
}

type Index = {
    nodes: Set<string>;
    imports: Map<string, Set<string>>; // file -> imported file paths (resolved)
    importLines: Map<string, Map<string, number[]>>; // file -> (resolved -> lines)
    lang: Map<string, 'js' | 'ts' | 'py' | 'other'>;
    // Detailed import entries to enable symbol-level mapping
    importEntries: Map<string, { spec: string; line: number }[]>; // per source file
};

export async function buildIndex(root: string): Promise<Index> {
    const excludes: string[] = vscode.workspace.getConfiguration('codeCanvas').get('excludeGlobs') || [];
    const rawFiles = Array.from(new Set([
        ...await fg(JS_GLOB, { cwd: root, absolute: true, ignore: excludes }),
        ...await fg(PY_GLOB, { cwd: root, absolute: true, ignore: excludes }),
    ]));
    const files = rawFiles.map(f => normalizePath(f));

    const lang = new Map<string, 'js' | 'ts' | 'py' | 'other'>();
    for (const f of files) {
        const ext = path.extname(f).toLowerCase();
        lang.set(
            f,
            ext === '.py' ? 'py'
                : (ext === '.ts' || ext === '.tsx') ? 'ts'
                    : (ext === '.js' || ext === '.jsx') ? 'js'
                        : 'other'
        );
    }

    const imports = new Map<string, Set<string>>();
    const importLines = new Map<string, Map<string, number[]>>();
    const importEntries = new Map<string, { spec: string; line: number }[]>();
    for (const f of files) {
        const src = safeRead(f);
        const specs = lang.get(f) === 'py' ? parsePyImportsWithLines(src) : parseJsTsImportsWithLines(src);
        const targets = new Set<string>();
        const lineMap = new Map<string, number[]>();
        importEntries.set(f, specs);
        for (const { spec, line } of specs) {
            const r = lang.get(f) === 'py' ? resolvePy(root, f, spec) : resolveJsTs(root, f, spec);
            if (!r) continue;
            const rNorm = normalizePath(r);
            targets.add(rNorm);
            const arr = lineMap.get(rNorm) || [];
            arr.push(line);
            lineMap.set(rNorm, arr);
        }
        imports.set(f, targets);
        importLines.set(f, lineMap);
    }

    return { nodes: new Set(files), imports, importLines, lang, importEntries };
}

// Build a subgraph with BFS from seeds up to max nodes/edges.
export async function subgraph(index: Index, seeds: string[], maxNodes: number): Promise<Graph> {
    const seen = new Set<string>();
    const q: string[] = [];
    for (const s of seeds) {
        const sNorm = normalizePath(s);
        if (index.nodes.has(sNorm)) { seen.add(sNorm); q.push(sNorm); }
    }

    // If no valid seeds, pick up to 10 random-ish files to start
    if (q.length === 0) {
        for (const f of Array.from(index.nodes).slice(0, Math.min(10, index.nodes.size))) {
            seen.add(f); q.push(f);
        }
    }

    while (q.length && seen.size < maxNodes) {
        const cur = q.shift()!;
        const out = index.imports.get(cur) || new Set();
        for (const t of out) {
            if (seen.size >= maxNodes) break;
            const tNorm = normalizePath(t);
            if (!index.nodes.has(tNorm)) continue;
            if (!seen.has(tNorm)) { seen.add(tNorm); q.push(tNorm); }
        }
        // add a bit of reverse reachability (files importing cur)
        for (const [f, outs] of index.imports) {
            if (outs.has(cur) && !seen.has(f)) {
                if (seen.size >= maxNodes) break;
                seen.add(f); q.push(f);
            }
        }
    }

    const nodes = Array.from(seen).map(f => ({
        id: makeSafeId(f),
        label: path.basename(f),
        path: f,
        lang: (index.lang.get(f) || 'other') as any
    }));

    const nodeIdByPath = new Map<string, string>();
    for (const n of nodes) nodeIdByPath.set(n.path, n.id);

    const edges: Graph['edges'] = [];
    const symbolCache = new Map<string, Awaited<ReturnType<typeof getDocumentSymbols>>>();
    const getSymbols = async (file: string) => {
        if (!symbolCache.has(file)) {
            const uri = vscode.Uri.file(file);
            symbolCache.set(file, await getDocumentSymbols(uri));
        }
        return symbolCache.get(file)!;
    };

    for (const s of seen) {
        const lineMap = index.importLines.get(s) || new Map();
        const entries = index.importEntries.get(s) || [];
        for (const t of (index.imports.get(s) || new Set())) {
            if (seen.has(t)) {
                const sid = nodeIdByPath.get(s)!;
                const tid = nodeIdByPath.get(t)!;
                const lines = lineMap.get(t) || [];
                const sourceLine = lines.length ? lines[0] : undefined;

                // Compute per-symbol target lines for this src->t relationship
                const links: EdgeLink[] = [];
                try {
                    const syms = await getSymbols(t);
                    // Find all import statements for this target file and map names heuristically
                    for (const { spec, line } of entries) {
                        const resolved = (index.lang.get(s) === 'py') ? resolvePy(path.dirname(s), s, spec) : resolveJsTs(path.dirname(s), s, spec);
                        const resolvedNorm = resolved ? normalizePath(resolved) : undefined;
                        if (resolvedNorm !== t) continue;
                        // Heuristic: try to split last path part as module name, but prefer matching symbols by name presence in the source file near import
                        // For Phase 2 scope, we will not fully parse named specifiers; instead, map to best top-level symbol (class/func/var) if unique, else fallback 0
                        let targetLine = 0;
                        const topLevel = syms.filter(sy => sy.range?.start?.line != null);
                        if (topLevel.length === 1) targetLine = topLevel[0].range.start.line;
                        else if (topLevel.length > 1) {
                            // pick first non-trivial symbol (Class, Function) if present
                            const preferred = topLevel.find(sy => sy.kind === vscode.SymbolKind.Class || sy.kind === vscode.SymbolKind.Function || sy.kind === vscode.SymbolKind.Method) || topLevel[0];
                            targetLine = preferred.range.start.line;
                        }
                        links.push({ symbolName: undefined, targetLine });
                    }
                } catch {
                    // Fallback: keep empty links
                }

                edges.push({ id: `e_${hashString(s + '->' + t + '#' + (sourceLine ?? -1))}`, source: sid, target: tid, kind: 'import', sourceLine, targetLine: links[0]?.targetLine ?? 0, links });
            }
        }
    }

    return { nodes, edges };
}

function safeRead(p: string) { try { return fs.readFileSync(p, 'utf8'); } catch { return ''; } }

function parseJsTsImportsWithLines(code: string): { spec: string; line: number }[] {
    const out: { spec: string; line: number }[] = [];
    const patterns = [
        /import\s+[^'\"]+from\s+['\"]([^'\"]+)['\"]/g,
        /import\s+['\"]([^'\"]+)['\"]/g,
        /export\s+[^'\"]*\s+from\s+['\"]([^'\"]+)['\"]/g
    ];
    for (const r of patterns) {
        let m: RegExpExecArray | null;
        while ((m = r.exec(code))) {
            const idx = m.index ?? 0;
            const line = code.slice(0, idx).split('\n').length - 1;
            out.push({ spec: m[1], line });
        }
    }
    return out;
}
function parsePyImportsWithLines(code: string): { spec: string; line: number }[] {
    const out: { spec: string; line: number }[] = [];
    let m: RegExpExecArray | null;
    const r1 = /^\s*import\s+([\w\.]+)/gm;
    const r2 = /^\s*from\s+([\w\.]+)\s+import\s+[\w\*,\s]+/gm;
    while ((m = r1.exec(code))) {
        const idx = m.index ?? 0;
        const line = code.slice(0, idx).split('\n').length - 1;
        out.push({ spec: m[1], line });
    }
    while ((m = r2.exec(code))) {
        const idx = m.index ?? 0;
        const line = code.slice(0, idx).split('\n').length - 1;
        out.push({ spec: m[1], line });
    }
    return out;
}

function resolveJsTs(root: string, fromFile: string, spec: string): string | undefined {
    if (!spec.startsWith('.') && !spec.startsWith('/')) return; // skip packages
    const base = path.resolve(path.dirname(fromFile), spec);
    const tries = ['', '.ts', '.tsx', '.js', '.jsx', '/index.ts', '/index.tsx', '/index.js', '/index.jsx'];
    for (const t of tries) { const p = base + t; if (fs.existsSync(p)) return normalizePath(p); }
}
function resolvePy(root: string, _from: string, mod: string): string | undefined {
    const parts = mod.split('.');
    const candidates = [
        path.resolve(root, ...parts) + '.py',
        path.resolve(root, ...parts, '__init__.py')
    ];
    for (const p of candidates) if (fs.existsSync(p)) return normalizePath(p);
}

function hashString(input: string): string {
    let hash = 0 >>> 0;
    for (let i = 0; i < input.length; i++) {
        hash = (hash * 31 + input.charCodeAt(i)) >>> 0;
    }
    return hash.toString(36);
}

function makeSafeId(raw: string): string {
    const safe = raw.replace(/[^a-zA-Z0-9_-]/g, '_');
    return `n_${safe}_${hashString(raw)}`;
}
```

## extension/src/lsp.ts

```typescript
﻿import * as vscode from 'vscode';

export async function getReferences(uri: vscode.Uri, position: vscode.Position) {
    const locs = await vscode.commands.executeCommand<vscode.Location[]>(
        'vscode.executeReferenceProvider', uri, position
    );
    return (locs || []).map(l => ({
        uri: l.uri.toString(),
        range: { start: l.range.start, end: l.range.end }
    }));
}

export async function getDefinition(uri: vscode.Uri, position: vscode.Position) {
    const defs = await vscode.commands.executeCommand<any>('vscode.executeDefinitionProvider', uri, position);
    return defs;
}

export async function getCallHierarchyIncoming(uri: vscode.Uri, position: vscode.Position) {
    const items = await vscode.commands.executeCommand<any>('vscode.prepareCallHierarchy', uri, position);
    if (!items || !items[0]) return [];
    const incoming = await vscode.commands.executeCommand<any>('vscode.provideIncomingCalls', items[0]);
    return incoming || [];
}

export async function getCallHierarchyOutgoing(uri: vscode.Uri, position: vscode.Position) {
    const items = await vscode.commands.executeCommand<any>('vscode.prepareCallHierarchy', uri, position);
    if (!items || !items[0]) return [];
    const outgoing = await vscode.commands.executeCommand<any>('vscode.provideOutgoingCalls', items[0]);
    return outgoing || [];
}

export type FlatSymbol = { name: string; kind: vscode.SymbolKind; range: vscode.Range };

export async function getDocumentSymbols(uri: vscode.Uri): Promise<FlatSymbol[]> {
    try {
        const symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(
            'vscode.executeDocumentSymbolProvider', uri
        );
        if (!symbols || !Array.isArray(symbols)) return [];
        const out: FlatSymbol[] = [];
        const visit = (items: vscode.DocumentSymbol[]) => {
            for (const s of items) {
                out.push({ name: s.name, kind: s.kind, range: s.selectionRange || s.range });
                if (s.children && s.children.length) visit(s.children);
            }
        };
        visit(symbols);
        return out;
    } catch {
        return [];
    }
}
```

## extension/src/util.ts

```typescript
﻿import * as vscode from 'vscode';
import * as fs from 'fs';

export type GraphNode = {
    id: string;
    label: string;
    path: string;
    lang: 'ts' | 'js' | 'tsx' | 'jsx' | 'py' | 'other';
};

export type EdgeLink = { symbolName?: string; targetLine: number };

export type GraphEdge = {
    id: string;
    source: string;
    target: string;
    kind: 'import' | 'call' | 'ref';
    sourceLine?: number;
    targetLine?: number;
    links?: EdgeLink[];
};

export type Graph = { nodes: GraphNode[]; edges: GraphEdge[] };

/**
 * Load the built webview HTML and rewrite asset URLs for the VS Code webview.
 * Handles both "/assets/..." and "./assets/...".
 */
export function htmlForWebview(
    panel: vscode.WebviewPanel,
    context: vscode.ExtensionContext
) {
    const media = vscode.Uri.joinPath(context.extensionUri, 'media');
    const index = vscode.Uri.joinPath(media, 'index.html');
    let html = fs.readFileSync(index.fsPath, 'utf8');

    const fix = (p: string) =>
        panel.webview
            .asWebviewUri(vscode.Uri.joinPath(media, p))
            .toString();

    html = html
        // rewrite src/href="./assets/..." and "/assets/..."
        .replace(/((?:src|href)=["'])\.?\/assets\//g, (_m, p1) => `${p1}${fix('assets/')}`)
        .replace(/__CSP__/g, panel.webview.cspSource);

    return html;
}
```

## extension/tsconfig.json

```json
﻿{
    "compilerOptions": {
        "target": "ES2022",
        "lib": [
            "ES2022"
        ],
        "module": "ESNext",
        "moduleResolution": "Node",
        "strict": true,
        "allowSyntheticDefaultImports": true,
        "skipLibCheck": true,
        "outDir": "dist",
        "rootDir": "src",
        "types": [
            "vscode",
            "node"
        ]
    },
    "include": [
        "src/**/*.ts"
    ]
}
```

## final_review_gate.py

```python
# final_review_gate.py
import sys
import os

if __name__ == "__main__":
    # Try to make stdout unbuffered for more responsive interaction.
    # This might not work on all platforms or if stdout is not a TTY,
    # but it's a good practice for this kind of interactive script.
    try:
        sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', buffering=1)
    except Exception:
        pass # Ignore if unbuffering fails, e.g., in certain environments

    try:
        sys.stderr = os.fdopen(sys.stderr.fileno(), 'w', buffering=1)
    except Exception:
        pass # Ignore

    print("--- FINAL REVIEW GATE ACTIVE ---", flush=True)
    print("AI has completed its primary actions. Awaiting your review or further sub-prompts.", flush=True)
    print("Type your sub-prompt, or one of: 'TASK_COMPLETE', 'Done', 'Quit', 'q' to signal completion.", flush=True) # MODIFIED
    
    active_session = True
    while active_session:
        try:
            # Signal that the script is ready for input.
            # The AI doesn't need to parse this, but it's good for user visibility.
            print("REVIEW_GATE_AWAITING_INPUT:", end="", flush=True) 
            
            line = sys.stdin.readline()
            
            if not line:  # EOF
                print("--- REVIEW GATE: STDIN CLOSED (EOF), EXITING SCRIPT ---", flush=True)
                active_session = False
                break
            
            user_input = line.strip()

            # Check for exit conditions
            if user_input.upper() in ['TASK_COMPLETE', 'DONE', 'QUIT', 'Q']: # MODIFIED: Empty string no longer exits
                print(f"--- REVIEW GATE: USER SIGNALED COMPLETION WITH '{user_input.upper()}' ---", flush=True)
                active_session = False
                break
            elif user_input: # If there's any other non-empty input (and not a completion command)
                # This is the critical line the AI will "listen" for.
                print(f"USER_REVIEW_SUB_PROMPT: {user_input}", flush=True)
            # If user_input was empty (and not a completion command),
            # the loop simply continues, and "REVIEW_GATE_AWAITING_INPUT:" will be printed again.
            
        except KeyboardInterrupt:
            print("--- REVIEW GATE: SESSION INTERRUPTED BY USER (KeyboardInterrupt) ---", flush=True)
            active_session = False
            break
        except Exception as e:
            print(f"--- REVIEW GATE SCRIPT ERROR: {e} ---", flush=True)
            active_session = False
            break
            
    print("--- FINAL REVIEW GATE SCRIPT EXITED ---", flush=True)
```

## package.json

```json
{
  "name": "code-canvas",
  "private": true,
  "version": "1.0.0",
  "description": "Code Canvas",
  "main": "index.js",
  "scripts": {
    "build": "npm -w webview run build && npm -w extension run build",
    "watch": "npm -w webview run dev & npm -w extension run watch",
    "package": "npm -w extension run package"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "workspaces": [
    "webview",
    "extension"
  ],
  "overrides": {}
}
```

## README.md

```markdown
﻿# paste: README.md
```

## repomix-output.md

```````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-14 14:13:50

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.gitignore
extension
  media
    assets
      index-DB8g-wRD.js
      index-DXezZONC.css
    index.html
  package.json
  src
    extension.ts
    git.ts
    graph.ts
    lsp.ts
    util.ts
  tsconfig.json
final_review_gate.py
package.json
README.md
repomix-output.md
webview
  index.html
  package.json
  src
    App.tsx
    code
      CodeCard.tsx
      highlight.ts
    layout.ts
    main.tsx
    reactflow-node-types.tsx
    styles.css
  tsconfig.json
  vite.config.ts
```

# Repository Files


## .gitignore

```text
/final_review_gate.py
node_modules
```

## extension/media/assets/index-DXezZONC.css

```css
/* this gets exported as style.css and can be used for the default theming */
/* these are the necessary styles for React Flow, they get used by base.css and style.css */
.react-flow {
  direction: ltr;
}
.react-flow__container {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
}
.react-flow__pane {
  z-index: 1;
  cursor: -webkit-grab;
  cursor: grab;
}
.react-flow__pane.selection {
    cursor: pointer;
  }
.react-flow__pane.dragging {
    cursor: -webkit-grabbing;
    cursor: grabbing;
  }
.react-flow__viewport {
  transform-origin: 0 0;
  z-index: 2;
  pointer-events: none;
}
.react-flow__renderer {
  z-index: 4;
}
.react-flow__selection {
  z-index: 6;
}
.react-flow__nodesselection-rect:focus,
.react-flow__nodesselection-rect:focus-visible {
  outline: none;
}
.react-flow .react-flow__edges {
  pointer-events: none;
  overflow: visible;
}
.react-flow__edge-path,
.react-flow__connection-path {
  stroke: #b1b1b7;
  stroke-width: 1;
  fill: none;
}
.react-flow__edge {
  pointer-events: visibleStroke;
  cursor: pointer;
}
.react-flow__edge.animated path {
    stroke-dasharray: 5;
    -webkit-animation: dashdraw 0.5s linear infinite;
            animation: dashdraw 0.5s linear infinite;
  }
.react-flow__edge.animated path.react-flow__edge-interaction {
    stroke-dasharray: none;
    -webkit-animation: none;
            animation: none;
  }
.react-flow__edge.inactive {
    pointer-events: none;
  }
.react-flow__edge.selected,
  .react-flow__edge:focus,
  .react-flow__edge:focus-visible {
    outline: none;
  }
.react-flow__edge.selected .react-flow__edge-path,
  .react-flow__edge:focus .react-flow__edge-path,
  .react-flow__edge:focus-visible .react-flow__edge-path {
    stroke: #555;
  }
.react-flow__edge-textwrapper {
    pointer-events: all;
  }
.react-flow__edge-textbg {
    fill: white;
  }
.react-flow__edge .react-flow__edge-text {
    pointer-events: none;
    -webkit-user-select: none;
       -moz-user-select: none;
            user-select: none;
  }
.react-flow__connection {
  pointer-events: none;
}
.react-flow__connection .animated {
    stroke-dasharray: 5;
    -webkit-animation: dashdraw 0.5s linear infinite;
            animation: dashdraw 0.5s linear infinite;
  }
.react-flow__connectionline {
  z-index: 1001;
}
.react-flow__nodes {
  pointer-events: none;
  transform-origin: 0 0;
}
.react-flow__node {
  position: absolute;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
  pointer-events: all;
  transform-origin: 0 0;
  box-sizing: border-box;
  cursor: -webkit-grab;
  cursor: grab;
}
.react-flow__node.dragging {
    cursor: -webkit-grabbing;
    cursor: grabbing;
  }
.react-flow__nodesselection {
  z-index: 3;
  transform-origin: left top;
  pointer-events: none;
}
.react-flow__nodesselection-rect {
    position: absolute;
    pointer-events: all;
    cursor: -webkit-grab;
    cursor: grab;
  }
.react-flow__handle {
  position: absolute;
  pointer-events: none;
  min-width: 5px;
  min-height: 5px;
  width: 6px;
  height: 6px;
  background: #1a192b;
  border: 1px solid white;
  border-radius: 100%;
}
.react-flow__handle.connectionindicator {
    pointer-events: all;
    cursor: crosshair;
  }
.react-flow__handle-bottom {
    top: auto;
    left: 50%;
    bottom: -4px;
    transform: translate(-50%, 0);
  }
.react-flow__handle-top {
    left: 50%;
    top: -4px;
    transform: translate(-50%, 0);
  }
.react-flow__handle-left {
    top: 50%;
    left: -4px;
    transform: translate(0, -50%);
  }
.react-flow__handle-right {
    right: -4px;
    top: 50%;
    transform: translate(0, -50%);
  }
.react-flow__edgeupdater {
  cursor: move;
  pointer-events: all;
}
.react-flow__panel {
  position: absolute;
  z-index: 5;
  margin: 15px;
}
.react-flow__panel.top {
    top: 0;
  }
.react-flow__panel.bottom {
    bottom: 0;
  }
.react-flow__panel.left {
    left: 0;
  }
.react-flow__panel.right {
    right: 0;
  }
.react-flow__panel.center {
    left: 50%;
    transform: translateX(-50%);
  }
.react-flow__attribution {
  font-size: 10px;
  background: rgba(255, 255, 255, 0.5);
  padding: 2px 3px;
  margin: 0;
}
.react-flow__attribution a {
    text-decoration: none;
    color: #999;
  }
@-webkit-keyframes dashdraw {
  from {
    stroke-dashoffset: 10;
  }
}
@keyframes dashdraw {
  from {
    stroke-dashoffset: 10;
  }
}
.react-flow__edgelabel-renderer {
  position: absolute;
  width: 100%;
  height: 100%;
  pointer-events: none;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
}
.react-flow__edge.updating .react-flow__edge-path {
      stroke: #777;
    }
.react-flow__edge-text {
    font-size: 10px;
  }
.react-flow__node.selectable:focus,
  .react-flow__node.selectable:focus-visible {
    outline: none;
  }
.react-flow__node-default,
.react-flow__node-input,
.react-flow__node-output,
.react-flow__node-group {
  padding: 10px;
  border-radius: 3px;
  width: 150px;
  font-size: 12px;
  color: #222;
  text-align: center;
  border-width: 1px;
  border-style: solid;
  border-color: #1a192b;
  background-color: white;
}
.react-flow__node-default.selectable:hover, .react-flow__node-input.selectable:hover, .react-flow__node-output.selectable:hover, .react-flow__node-group.selectable:hover {
      box-shadow: 0 1px 4px 1px rgba(0, 0, 0, 0.08);
    }
.react-flow__node-default.selectable.selected,
    .react-flow__node-default.selectable:focus,
    .react-flow__node-default.selectable:focus-visible,
    .react-flow__node-input.selectable.selected,
    .react-flow__node-input.selectable:focus,
    .react-flow__node-input.selectable:focus-visible,
    .react-flow__node-output.selectable.selected,
    .react-flow__node-output.selectable:focus,
    .react-flow__node-output.selectable:focus-visible,
    .react-flow__node-group.selectable.selected,
    .react-flow__node-group.selectable:focus,
    .react-flow__node-group.selectable:focus-visible {
      box-shadow: 0 0 0 0.5px #1a192b;
    }
.react-flow__node-group {
  background-color: rgba(240, 240, 240, 0.25);
}
.react-flow__nodesselection-rect,
.react-flow__selection {
  background: rgba(0, 89, 220, 0.08);
  border: 1px dotted rgba(0, 89, 220, 0.8);
}
.react-flow__nodesselection-rect:focus,
  .react-flow__nodesselection-rect:focus-visible,
  .react-flow__selection:focus,
  .react-flow__selection:focus-visible {
    outline: none;
  }
.react-flow__controls {
  box-shadow: 0 0 2px 1px rgba(0, 0, 0, 0.08);
}
.react-flow__controls-button {
    border: none;
    background: #fefefe;
    border-bottom: 1px solid #eee;
    box-sizing: content-box;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 16px;
    height: 16px;
    cursor: pointer;
    -webkit-user-select: none;
       -moz-user-select: none;
            user-select: none;
    padding: 5px;
  }
.react-flow__controls-button:hover {
      background: #f4f4f4;
    }
.react-flow__controls-button svg {
      width: 100%;
      max-width: 12px;
      max-height: 12px;
    }
.react-flow__controls-button:disabled {
      pointer-events: none;
    }
.react-flow__controls-button:disabled svg {
        fill-opacity: 0.4;
      }
.react-flow__minimap {
  background-color: #fff;
}
.react-flow__minimap svg {
  display: block;
}
.react-flow__resize-control {
  position: absolute;
}
.react-flow__resize-control.left,
.react-flow__resize-control.right {
  cursor: ew-resize;
}
.react-flow__resize-control.top,
.react-flow__resize-control.bottom {
  cursor: ns-resize;
}
.react-flow__resize-control.top.left,
.react-flow__resize-control.bottom.right {
  cursor: nwse-resize;
}
.react-flow__resize-control.bottom.left,
.react-flow__resize-control.top.right {
  cursor: nesw-resize;
}
/* handle styles */
.react-flow__resize-control.handle {
  width: 4px;
  height: 4px;
  border: 1px solid #fff;
  border-radius: 1px;
  background-color: #3367d9;
  transform: translate(-50%, -50%);
}
.react-flow__resize-control.handle.left {
  left: 0;
  top: 50%;
}
.react-flow__resize-control.handle.right {
  left: 100%;
  top: 50%;
}
.react-flow__resize-control.handle.top {
  left: 50%;
  top: 0;
}
.react-flow__resize-control.handle.bottom {
  left: 50%;
  top: 100%;
}
.react-flow__resize-control.handle.top.left {
  left: 0;
}
.react-flow__resize-control.handle.bottom.left {
  left: 0;
}
.react-flow__resize-control.handle.top.right {
  left: 100%;
}
.react-flow__resize-control.handle.bottom.right {
  left: 100%;
}
/* line styles */
.react-flow__resize-control.line {
  border-color: #3367d9;
  border-width: 0;
  border-style: solid;
}
.react-flow__resize-control.line.left,
.react-flow__resize-control.line.right {
  width: 1px;
  transform: translate(-50%, 0);
  top: 0;
  height: 100%;
}
.react-flow__resize-control.line.left {
  left: 0;
  border-left-width: 1px;
}
.react-flow__resize-control.line.right {
  left: 100%;
  border-right-width: 1px;
}
.react-flow__resize-control.line.top,
.react-flow__resize-control.line.bottom {
  height: 1px;
  transform: translate(0, -50%);
  left: 0;
  width: 100%;
}
.react-flow__resize-control.line.top {
  top: 0;
  border-top-width: 1px;
}
.react-flow__resize-control.line.bottom {
  border-bottom-width: 1px;
  top: 100%;
}
:root {
    color-scheme: dark;
}

body,
html,
#root {
    margin: 0;
    height: 100%;
    background: #0b0e12;
    color: #cdd6f4;
    font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Inter, sans-serif;
}

.root {
    height: 100%;
}

.toolbar {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    display: flex;
    gap: 6px;
}

.toolbar button {
    background: #111827;
    border: 1px solid #1f2937;
    color: #e5e7eb;
    padding: 6px 10px;
    border-radius: 8px;
    cursor: pointer;
}

.file-node {
    width: 100%;
    height: 100%;
    background: #0d1117;
    border: 1px solid #1f2937;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 0 0 1px #0b1220 inset;
}

.file-node-header {
    background: #0b1220;
    padding: 6px 10px;
    font-weight: 600;
    font-size: 12px;
    letter-spacing: .3px;
    border-bottom: 1px solid #1f2937;
    cursor: default;
}

.code-card {
    height: calc(100% - 30px);
    overflow: auto;
}

.code-card .file-title {
    display: none;
}

pre.hljs {
    margin: 0;
    padding: 8px 10px 8px 56px;
    /* leave space for gutter */
    font-size: 12px;
    line-height: 1.35;
    position: relative;
    counter-reset: line;
}

pre.hljs .code-line {
    display: block;
    counter-increment: line;
    position: relative;
}

pre.hljs .code-line::before {
    content: counter(line);
    position: absolute;
    left: -44px;
    width: 36px;
    text-align: right;
    color: #6b7280;
    opacity: 0.9;
}

pre.hljs .code-line.highlight {
    background: rgba(255, 214, 10, 0.15);
    outline: 1px solid rgba(255, 214, 10, 0.35);
}

pre.hljs.wrap {
    white-space: pre-wrap;
}

.preview {
    font-size: 11px;
    opacity: .8;
    padding: 8px;
}

/* Improve MiniMap visibility */
.react-flow__minimap {
    background: #0f1115 !important;
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.06) inset;
}

.react-flow__minimap-mask {
    fill: rgba(255, 255, 255, 0.06) !important;
}

.react-flow__minimap-node {
    fill: #4f46e5 !important;
    stroke: rgba(255, 255, 255, 0.2) !important;
}

/* Allow extreme zooming */
.react-flow__renderer,
.react-flow__viewport {
    will-change: transform;
}pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 1em
}
code.hljs {
  padding: 3px 5px
}
/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/
.hljs {
  color: #c9d1d9;
  background: #0d1117
}
.hljs-doctag,
.hljs-keyword,
.hljs-meta .hljs-keyword,
.hljs-template-tag,
.hljs-template-variable,
.hljs-type,
.hljs-variable.language_ {
  /* prettylights-syntax-keyword */
  color: #ff7b72
}
.hljs-title,
.hljs-title.class_,
.hljs-title.class_.inherited__,
.hljs-title.function_ {
  /* prettylights-syntax-entity */
  color: #d2a8ff
}
.hljs-attr,
.hljs-attribute,
.hljs-literal,
.hljs-meta,
.hljs-number,
.hljs-operator,
.hljs-variable,
.hljs-selector-attr,
.hljs-selector-class,
.hljs-selector-id {
  /* prettylights-syntax-constant */
  color: #79c0ff
}
.hljs-regexp,
.hljs-string,
.hljs-meta .hljs-string {
  /* prettylights-syntax-string */
  color: #a5d6ff
}
.hljs-built_in,
.hljs-symbol {
  /* prettylights-syntax-variable */
  color: #ffa657
}
.hljs-comment,
.hljs-code,
.hljs-formula {
  /* prettylights-syntax-comment */
  color: #8b949e
}
.hljs-name,
.hljs-quote,
.hljs-selector-tag,
.hljs-selector-pseudo {
  /* prettylights-syntax-entity-tag */
  color: #7ee787
}
.hljs-subst {
  /* prettylights-syntax-storage-modifier-import */
  color: #c9d1d9
}
.hljs-section {
  /* prettylights-syntax-markup-heading */
  color: #1f6feb;
  font-weight: bold
}
.hljs-bullet {
  /* prettylights-syntax-markup-list */
  color: #f2cc60
}
.hljs-emphasis {
  /* prettylights-syntax-markup-italic */
  color: #c9d1d9;
  font-style: italic
}
.hljs-strong {
  /* prettylights-syntax-markup-bold */
  color: #c9d1d9;
  font-weight: bold
}
.hljs-addition {
  /* prettylights-syntax-markup-inserted */
  color: #aff5b4;
  background-color: #033a16
}
.hljs-deletion {
  /* prettylights-syntax-markup-deleted */
  color: #ffdcd7;
  background-color: #67060c
}
.hljs-char.escape_,
.hljs-link,
.hljs-params,
.hljs-property,
.hljs-punctuation,
.hljs-tag {
  /* purposely ignored */
  
}
```

## extension/media/index.html

```html
<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; img-src vscode-resource: https: data:; style-src 'unsafe-inline' __CSP__; script-src __CSP__; font-src __CSP__; connect-src __CSP__;" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Code Canvas</title>
  <script type="module" crossorigin src="./assets/index-DB8g-wRD.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-DXezZONC.css">
</head>

<body>
    <div id="root"></div>

</body>

</html>
```

## extension/package.json

```json
{
    "name": "code-canvas",
    "displayName": "Code Canvas",
    "publisher": "code-canvas",
    "version": "0.0.1",
    "engines": {
        "vscode": "^1.90.0"
    },
    "categories": [
        "Other"
    ],
    "activationEvents": [
        "onStartupFinished"
    ],
    "main": "dist/extension.js",
    "contributes": {
        "commands": [
            {
                "command": "codeCanvas.open",
                "title": "Code Canvas: Open"
            },
            {
                "command": "codeCanvas.openChanged",
                "title": "Code Canvas: Open Changed Files"
            },
            {
                "command": "codeCanvas.layout.custom",
                "title": "Code Canvas: Layout – Custom"
            },
            {
                "command": "codeCanvas.layout.dagre",
                "title": "Code Canvas: Layout – Dagre"
            },
            {
                "command": "codeCanvas.layout.elk",
                "title": "Code Canvas: Layout – ELK"
            },
            {
                "command": "codeCanvas.layout.force",
                "title": "Code Canvas: Layout – Force"
            },
            {
                "command": "codeCanvas.toggleRefs",
                "title": "Code Canvas: Toggle Refs"
            },
            {
                "command": "codeCanvas.seedFolder",
                "title": "Code Canvas: Open Folder as Seed"
            },
            {
                "command": "codeCanvas.loadMore",
                "title": "Code Canvas: Load 25 More"
            }
        ],
        "keybindings": [
            {
                "command": "codeCanvas.openChanged",
                "key": "shift+o"
            },
            {
                "command": "codeCanvas.loadMore",
                "key": "shift+plus"
            },
            {
                "command": "codeCanvas.layout.custom",
                "key": "shift+1"
            },
            {
                "command": "codeCanvas.layout.dagre",
                "key": "shift+2"
            },
            {
                "command": "codeCanvas.layout.elk",
                "key": "shift+3"
            },
            {
                "command": "codeCanvas.layout.force",
                "key": "shift+4"
            },
            {
                "command": "codeCanvas.toggleRefs",
                "key": "r"
            }
        ],
        "configuration": {
            "title": "Code Canvas",
            "properties": {
                "codeCanvas.maxNodes": {
                    "type": "number",
                    "default": 300,
                    "description": "Maximum nodes to render per subgraph."
                },
                "codeCanvas.excludeGlobs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "default": [
                        "**/node_modules/**",
                        "**/.venv/**",
                        "**/__pycache__/**",
                        "**/dist/**",
                        "**/build/**",
                        "**/.git/**"
                    ],
                    "description": "Extra glob patterns to exclude from indexing."
                },
                "codeCanvas.maxPreviewBytes": {
                    "type": "number",
                    "default": 100000,
                    "description": "Maximum number of bytes of file content to send to the webview for preview per file."
                },
                "codeCanvas.initialCap": {
                    "type": "number",
                    "default": 25,
                    "description": "Initial maximum number of nodes to show when first rendering a graph."
                }
            }
        }
    },
    "scripts": {
        "vscode:prepublish": "npm run build",
        "build": "tsup src/extension.ts --format cjs --dts --out-dir dist --external vscode",
        "watch": "tsup src/extension.ts --watch --format cjs --out-dir dist",
        "package": "vsce package"
    },
    "dependencies": {
        "fast-glob": "^3.3.2",
        "minimatch": "^9.0.5"
    },
    "devDependencies": {
        "@types/node": "^24.2.1",
        "@types/vscode": "^1.102.0",
        "@vscode/vsce": "^3.6.0",
        "tsup": "^8.5.0",
        "typescript": "^5.6"
    }
}
```

## extension/src/extension.ts

```typescript
﻿import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { htmlForWebview, Graph } from './util';
import { buildIndex, subgraph } from './graph';
import { getChangedFiles, watchGitState } from './git';
import * as lsp from './lsp';

let panel: vscode.WebviewPanel | undefined;
let idxPromise: ReturnType<typeof buildIndex> | undefined;
let lastSeeds: string[] = [];
let lastCap: number = 0;

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('codeCanvas.open', () => openPanel(context)),
        vscode.commands.registerCommand('codeCanvas.openChanged', async () => {
            await ensurePanel(context);
            const files = await getChangedFiles();
            panel?.webview.postMessage({ type: 'openChanged', files });
        }),
        vscode.commands.registerCommand('codeCanvas.layout.custom', () => panel?.webview.postMessage({ type: 'layout', algo: 'custom' })),
        vscode.commands.registerCommand('codeCanvas.layout.dagre', () => panel?.webview.postMessage({ type: 'layout', algo: 'dagre' })),
        vscode.commands.registerCommand('codeCanvas.layout.elk', () => panel?.webview.postMessage({ type: 'layout', algo: 'elk' })),
        vscode.commands.registerCommand('codeCanvas.layout.force', () => panel?.webview.postMessage({ type: 'layout', algo: 'force' })),
        vscode.commands.registerCommand('codeCanvas.toggleRefs', () => panel?.webview.postMessage({ type: 'toggleRefs' })),
        vscode.commands.registerCommand('codeCanvas.seedFolder', async () => {
            await ensurePanel(context);
            const picked = await vscode.window.showOpenDialog({ canSelectFiles: false, canSelectFolders: true, canSelectMany: false, openLabel: 'Use Folder as Seed' });
            if (!picked || !picked[0]) return;
            const folder = picked[0].fsPath;
            const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
            if (root && !idxPromise) idxPromise = buildIndex(root);
            const index = await idxPromise;
            if (!index) return;
            const folderNorm = path.resolve(folder);
            const seeds = Array.from(index.nodes).filter(p => isSubPath(folderNorm, p));
            if (!seeds.length) {
                vscode.window.showInformationMessage('Code Canvas: No files found under selected folder.');
                return;
            }
            const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
            const initialCapCfg: number = vscode.workspace.getConfiguration('codeCanvas').get('initialCap') ?? 25;
            const cap = Math.min(maxNodes, initialCapCfg);
            lastSeeds = seeds;
            lastCap = cap;
            const g: Graph = await subgraph(index, seeds, cap);
            panel?.webview.postMessage({ type: 'graph', graph: g });
        }),
        vscode.commands.registerCommand('codeCanvas.loadMore', async () => {
            await ensurePanel(context);
            if (!lastSeeds.length) return;
            const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
            if (root && !idxPromise) idxPromise = buildIndex(root);
            const index = await idxPromise;
            if (!index) return;
            const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
            const nextCap = Math.min(maxNodes, lastCap + 25);
            lastCap = nextCap;
            const g: Graph = await subgraph(index, lastSeeds, nextCap);
            panel?.webview.postMessage({ type: 'graph', graph: g });
        })
    );

    vscode.workspace.onDidChangeTextDocument(async (e) => {
        if (!panel) return;
        panel.webview.postMessage({ type: 'docChanged', file: e.document.uri.fsPath });
    });

    watchGitState(async () => {
        if (!panel) return;
        const files = await getChangedFiles();
        panel.webview.postMessage({ type: 'gitChanged', files });
    });
}

async function ensurePanel(context: vscode.ExtensionContext) { if (!panel) openPanel(context); }

function openPanel(context: vscode.ExtensionContext) {
    const column = vscode.ViewColumn.Beside;
    panel = vscode.window.createWebviewPanel('codeCanvas', 'Code Canvas', column, {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [vscode.Uri.joinPath(context.extensionUri, 'media')]
    });
    panel.webview.html = htmlForWebview(panel, context);
    panel.onDidDispose(() => panel = undefined);

    // kick off indexing
    const ws = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
    if (ws) idxPromise = buildIndex(ws);

    setTimeout(() => sendInitial(ws), 150);

    panel.webview.onDidReceiveMessage(async (msg) => {
        switch (msg.type) {
            case 'requestGraph': await sendInitial(ws); break;
            case 'expand': await sendExpansion(msg.ids || []); break;
            case 'loadMore': {
                const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
                if (root && !idxPromise) idxPromise = buildIndex(root);
                const index = await idxPromise;
                if (!index || !lastSeeds.length) break;
                const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
                const nextCap = Math.min(maxNodes, lastCap + 25);
                lastCap = nextCap;
                const g: Graph = await subgraph(index, lastSeeds, nextCap);
                panel?.webview.postMessage({ type: 'graph', graph: g });
                break;
            }
            case 'openFile': {
                const uri = vscode.Uri.file(msg.path);
                vscode.window.showTextDocument(uri, { preview: false });
                break;
            }
            case 'toggleEdges': {
                panel?.webview.postMessage({ type: 'toggleEdges' });
                break;
            }
            case 'requestChanged': {
                const files = await getChangedFiles();
                panel?.webview.postMessage({ type: 'changedFiles', files });
                break;
            }
            case 'requestRefs': {
                const { path, line, character } = msg;
                const uri = vscode.Uri.file(path);
                const refs = await lsp.getReferences(uri, new vscode.Position(line, character));
                panel?.webview.postMessage({ type: 'refs', at: { path, line, character }, refs });
                break;
            }
            case 'requestDefOpen': {
                const { path, line, character } = msg;
                const fromUri = vscode.Uri.file(path);
                const defs = await lsp.getDefinition(fromUri, new vscode.Position(line, character));
                const loc = Array.isArray(defs) ? defs[0] : defs;
                if (loc) {
                    let openUri: vscode.Uri | undefined;
                    let range: vscode.Range | undefined;
                    const anyLoc = loc as any;
                    if (anyLoc.targetUri) {
                        openUri = toUri(anyLoc.targetUri);
                        range = (anyLoc.targetSelectionRange || anyLoc.targetRange) as vscode.Range | undefined;
                    } else if (anyLoc.uri) {
                        openUri = toUri(anyLoc.uri);
                        range = anyLoc.range as vscode.Range | undefined;
                    }
                    if (openUri) await vscode.window.showTextDocument(openUri, { preview: false, selection: range });
                }
                break;
            }
            case 'requestCode': {
                const { path } = msg;
                const maxBytes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxPreviewBytes') ?? 100_000;
                const content = safeRead(path, maxBytes);
                panel?.webview.postMessage({ type: 'code', path, content });
                break;
            }
            case 'requestCodeMany': {
                const { paths } = msg as { paths: string[] };
                const maxBytes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxPreviewBytes') ?? 100_000;
                const entries = (paths || []).map(p => ({ path: p, content: safeRead(p, maxBytes) }));
                panel?.webview.postMessage({ type: 'codeMany', entries });
                break;
            }
        }
    });
}

async function sendInitial(ws?: string) {
    if (!panel) return;
    if (!ws) { panel.webview.postMessage({ type: 'empty', reason: 'no-workspace' }); return; }

    const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
    const initialCapCfg: number = vscode.workspace.getConfiguration('codeCanvas').get('initialCap') ?? 25;

    // seeds = active editor + changed files
    const active = vscode.window.activeTextEditor?.document.uri.fsPath;
    const changed = (await getChangedFiles()).slice(0, 5);
    const seeds = Array.from(new Set([active, ...changed].filter(Boolean) as string[]));

    panel.webview.postMessage({ type: 'progress', msg: 'Indexing…' });
    const index = await (idxPromise ?? buildIndex(ws));
    panel.webview.postMessage({ type: 'progress', msg: null });

    const initialCap = Math.min(maxNodes, initialCapCfg);
    lastSeeds = seeds;
    lastCap = initialCap;
    const g: Graph = await subgraph(index, seeds, initialCap);
    if (!g.nodes.length) panel.webview.postMessage({ type: 'empty', reason: 'no-matched-files' });
    else panel.webview.postMessage({ type: 'graph', graph: g });
}

async function sendExpansion(ids: string[]) {
    if (!panel) return;
    const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
    const index = await idxPromise;
    if (!index) return;
    const g: Graph = await subgraph(index, ids, maxNodes);
    panel?.webview.postMessage({ type: 'expandResult', graph: g });
}

export function deactivate() { }

function toUri(u: unknown): vscode.Uri | undefined {
    try {
        if (!u) return undefined;
        if (u instanceof vscode.Uri) return u;
        const anyU = u as any;
        if (typeof anyU === 'object' && typeof anyU.scheme === 'string') {
            return vscode.Uri.from(anyU);
        }
        if (typeof u === 'string') {
            const s = u as string;
            if (/^[a-zA-Z]:[\\/]/.test(s)) {
                return vscode.Uri.file(s);
            }
            return vscode.Uri.parse(s);
        }
    } catch { }
    return undefined;
}

function isSubPath(parent: string, child: string): boolean {
    try {
        const parentNorm = path.resolve(parent);
        const childNorm = path.resolve(child);
        if (process.platform === 'win32') {
            const p = parentNorm.replace(/[\\/]+$/, '') + path.sep; // ensure trailing sep
            const c = childNorm;
            return c.toLowerCase().startsWith(p.toLowerCase());
        } else {
            const p = parentNorm.endsWith(path.sep) ? parentNorm : parentNorm + path.sep;
            return childNorm.startsWith(p);
        }
    } catch {
        return false;
    }
}

function safeRead(p: string, _limit: number): string {
    try {
        return fs.readFileSync(p, 'utf8');
    } catch {
        return '';
    }
}
```

## extension/src/git.ts

```typescript
﻿import * as vscode from 'vscode';

export async function getChangedFiles(): Promise<string[]> {
    // Prefer Git extension API if available
    const gitExt = vscode.extensions.getExtension('vscode.git');
    if (gitExt) {
        const api = (gitExt.isActive ? gitExt.exports : await gitExt.activate()).getAPI(1);
        const repo = api.repositories[0];
        if (repo) {
            const files = [
                ...repo.state.workingTreeChanges,
                ...repo.state.mergeChanges,
                ...repo.state.indexChanges
            ].map(c => c.uri.fsPath);
            return Array.from(new Set(files));
        }
    }
    // Fallback: simple status parse
    try {
        const cp = await import('child_process');
        const { stdout } = cp.spawnSync('git', ['status', '--porcelain'], { encoding: 'utf8' });
        return stdout.split('\n').filter(Boolean).map(line => line.slice(3)).filter(Boolean);
    } catch { return []; }
}

export function watchGitState(onChange: () => void) {
    const gitExt = vscode.extensions.getExtension('vscode.git');
    if (!gitExt) return () => { };
    const add = async () => {
        const api = (gitExt.isActive ? gitExt.exports : await gitExt.activate()).getAPI(1);
        const repo = api.repositories[0];
        if (!repo) return () => { };
        const d1 = repo.state.onDidChange(onChange);
        const d2 = api.onDidOpenRepository(onChange);
        const d3 = api.onDidChangeState(onChange);
        return () => { d1.dispose(); d2.dispose(); d3.dispose(); };
    };
    add();
    return () => { };
}
```

## extension/src/graph.ts

```typescript
﻿import fg from 'fast-glob';
import * as path from 'path';
import * as fs from 'fs';
import * as vscode from 'vscode';
import type { Graph, EdgeLink } from './util';
import { getDocumentSymbols } from './lsp';

const JS_GLOB = ['**/*.{js,jsx,ts,tsx}'];
const PY_GLOB = ['**/*.py'];

// Normalize paths to a canonical absolute form used for all map/set keys
function normalizePath(p: string): string {
    try {
        let out = path.resolve(p);
        if (process.platform === 'win32') {
            out = path.normalize(out);
            // Lowercase drive letter for consistency
            out = out.replace(/^([A-Z]):\\/, (m, d) => `${d.toLowerCase()}:\\`);
        }
        return out;
    } catch {
        return p;
    }
}

type Index = {
    nodes: Set<string>;
    imports: Map<string, Set<string>>; // file -> imported file paths (resolved)
    importLines: Map<string, Map<string, number[]>>; // file -> (resolved -> lines)
    lang: Map<string, 'js' | 'ts' | 'py' | 'other'>;
    // Detailed import entries to enable symbol-level mapping
    importEntries: Map<string, { spec: string; line: number }[]>; // per source file
};

export async function buildIndex(root: string): Promise<Index> {
    const excludes: string[] = vscode.workspace.getConfiguration('codeCanvas').get('excludeGlobs') || [];
    const rawFiles = Array.from(new Set([
        ...await fg(JS_GLOB, { cwd: root, absolute: true, ignore: excludes }),
        ...await fg(PY_GLOB, { cwd: root, absolute: true, ignore: excludes }),
    ]));
    const files = rawFiles.map(f => normalizePath(f));

    const lang = new Map<string, 'js' | 'ts' | 'py' | 'other'>();
    for (const f of files) {
        const ext = path.extname(f).toLowerCase();
        lang.set(
            f,
            ext === '.py' ? 'py'
                : (ext === '.ts' || ext === '.tsx') ? 'ts'
                    : (ext === '.js' || ext === '.jsx') ? 'js'
                        : 'other'
        );
    }

    const imports = new Map<string, Set<string>>();
    const importLines = new Map<string, Map<string, number[]>>();
    const importEntries = new Map<string, { spec: string; line: number }[]>();
    for (const f of files) {
        const src = safeRead(f);
        const specs = lang.get(f) === 'py' ? parsePyImportsWithLines(src) : parseJsTsImportsWithLines(src);
        const targets = new Set<string>();
        const lineMap = new Map<string, number[]>();
        importEntries.set(f, specs);
        for (const { spec, line } of specs) {
            const r = lang.get(f) === 'py' ? resolvePy(root, f, spec) : resolveJsTs(root, f, spec);
            if (!r) continue;
            const rNorm = normalizePath(r);
            targets.add(rNorm);
            const arr = lineMap.get(rNorm) || [];
            arr.push(line);
            lineMap.set(rNorm, arr);
        }
        imports.set(f, targets);
        importLines.set(f, lineMap);
    }

    return { nodes: new Set(files), imports, importLines, lang, importEntries };
}

// Build a subgraph with BFS from seeds up to max nodes/edges.
export async function subgraph(index: Index, seeds: string[], maxNodes: number): Promise<Graph> {
    const seen = new Set<string>();
    const q: string[] = [];
    for (const s of seeds) {
        const sNorm = normalizePath(s);
        if (index.nodes.has(sNorm)) { seen.add(sNorm); q.push(sNorm); }
    }

    // If no valid seeds, pick up to 10 random-ish files to start
    if (q.length === 0) {
        for (const f of Array.from(index.nodes).slice(0, Math.min(10, index.nodes.size))) {
            seen.add(f); q.push(f);
        }
    }

    while (q.length && seen.size < maxNodes) {
        const cur = q.shift()!;
        const out = index.imports.get(cur) || new Set();
        for (const t of out) {
            if (seen.size >= maxNodes) break;
            const tNorm = normalizePath(t);
            if (!index.nodes.has(tNorm)) continue;
            if (!seen.has(tNorm)) { seen.add(tNorm); q.push(tNorm); }
        }
        // add a bit of reverse reachability (files importing cur)
        for (const [f, outs] of index.imports) {
            if (outs.has(cur) && !seen.has(f)) {
                if (seen.size >= maxNodes) break;
                seen.add(f); q.push(f);
            }
        }
    }

    const nodes = Array.from(seen).map(f => ({
        id: makeSafeId(f),
        label: path.basename(f),
        path: f,
        lang: (index.lang.get(f) || 'other') as any
    }));

    const nodeIdByPath = new Map<string, string>();
    for (const n of nodes) nodeIdByPath.set(n.path, n.id);

    const edges: Graph['edges'] = [];
    const symbolCache = new Map<string, Awaited<ReturnType<typeof getDocumentSymbols>>>();
    const getSymbols = async (file: string) => {
        if (!symbolCache.has(file)) {
            const uri = vscode.Uri.file(file);
            symbolCache.set(file, await getDocumentSymbols(uri));
        }
        return symbolCache.get(file)!;
    };

    for (const s of seen) {
        const lineMap = index.importLines.get(s) || new Map();
        const entries = index.importEntries.get(s) || [];
        for (const t of (index.imports.get(s) || new Set())) {
            if (seen.has(t)) {
                const sid = nodeIdByPath.get(s)!;
                const tid = nodeIdByPath.get(t)!;
                const lines = lineMap.get(t) || [];
                const sourceLine = lines.length ? lines[0] : undefined;

                // Compute per-symbol target lines for this src->t relationship
                const links: EdgeLink[] = [];
                try {
                    const syms = await getSymbols(t);
                    // Find all import statements for this target file and map names heuristically
                    for (const { spec, line } of entries) {
                        const resolved = (index.lang.get(s) === 'py') ? resolvePy(path.dirname(s), s, spec) : resolveJsTs(path.dirname(s), s, spec);
                        const resolvedNorm = resolved ? normalizePath(resolved) : undefined;
                        if (resolvedNorm !== t) continue;
                        // Heuristic: try to split last path part as module name, but prefer matching symbols by name presence in the source file near import
                        // For Phase 2 scope, we will not fully parse named specifiers; instead, map to best top-level symbol (class/func/var) if unique, else fallback 0
                        let targetLine = 0;
                        const topLevel = syms.filter(sy => sy.range?.start?.line != null);
                        if (topLevel.length === 1) targetLine = topLevel[0].range.start.line;
                        else if (topLevel.length > 1) {
                            // pick first non-trivial symbol (Class, Function) if present
                            const preferred = topLevel.find(sy => sy.kind === vscode.SymbolKind.Class || sy.kind === vscode.SymbolKind.Function || sy.kind === vscode.SymbolKind.Method) || topLevel[0];
                            targetLine = preferred.range.start.line;
                        }
                        links.push({ symbolName: undefined, targetLine });
                    }
                } catch {
                    // Fallback: keep empty links
                }

                edges.push({ id: `e_${hashString(s + '->' + t + '#' + (sourceLine ?? -1))}`, source: sid, target: tid, kind: 'import', sourceLine, targetLine: links[0]?.targetLine ?? 0, links });
            }
        }
    }

    return { nodes, edges };
}

function safeRead(p: string) { try { return fs.readFileSync(p, 'utf8'); } catch { return ''; } }

function parseJsTsImportsWithLines(code: string): { spec: string; line: number }[] {
    const out: { spec: string; line: number }[] = [];
    const patterns = [
        /import\s+[^'\"]+from\s+['\"]([^'\"]+)['\"]/g,
        /import\s+['\"]([^'\"]+)['\"]/g,
        /export\s+[^'\"]*\s+from\s+['\"]([^'\"]+)['\"]/g
    ];
    for (const r of patterns) {
        let m: RegExpExecArray | null;
        while ((m = r.exec(code))) {
            const idx = m.index ?? 0;
            const line = code.slice(0, idx).split('\n').length - 1;
            out.push({ spec: m[1], line });
        }
    }
    return out;
}
function parsePyImportsWithLines(code: string): { spec: string; line: number }[] {
    const out: { spec: string; line: number }[] = [];
    let m: RegExpExecArray | null;
    const r1 = /^\s*import\s+([\w\.]+)/gm;
    const r2 = /^\s*from\s+([\w\.]+)\s+import\s+[\w\*,\s]+/gm;
    while ((m = r1.exec(code))) {
        const idx = m.index ?? 0;
        const line = code.slice(0, idx).split('\n').length - 1;
        out.push({ spec: m[1], line });
    }
    while ((m = r2.exec(code))) {
        const idx = m.index ?? 0;
        const line = code.slice(0, idx).split('\n').length - 1;
        out.push({ spec: m[1], line });
    }
    return out;
}

function resolveJsTs(root: string, fromFile: string, spec: string): string | undefined {
    if (!spec.startsWith('.') && !spec.startsWith('/')) return; // skip packages
    const base = path.resolve(path.dirname(fromFile), spec);
    const tries = ['', '.ts', '.tsx', '.js', '.jsx', '/index.ts', '/index.tsx', '/index.js', '/index.jsx'];
    for (const t of tries) { const p = base + t; if (fs.existsSync(p)) return normalizePath(p); }
}
function resolvePy(root: string, _from: string, mod: string): string | undefined {
    const parts = mod.split('.');
    const candidates = [
        path.resolve(root, ...parts) + '.py',
        path.resolve(root, ...parts, '__init__.py')
    ];
    for (const p of candidates) if (fs.existsSync(p)) return normalizePath(p);
}

function hashString(input: string): string {
    let hash = 0 >>> 0;
    for (let i = 0; i < input.length; i++) {
        hash = (hash * 31 + input.charCodeAt(i)) >>> 0;
    }
    return hash.toString(36);
}

function makeSafeId(raw: string): string {
    const safe = raw.replace(/[^a-zA-Z0-9_-]/g, '_');
    return `n_${safe}_${hashString(raw)}`;
}
```

## extension/src/lsp.ts

```typescript
﻿import * as vscode from 'vscode';

export async function getReferences(uri: vscode.Uri, position: vscode.Position) {
    const locs = await vscode.commands.executeCommand<vscode.Location[]>(
        'vscode.executeReferenceProvider', uri, position
    );
    return (locs || []).map(l => ({
        uri: l.uri.toString(),
        range: { start: l.range.start, end: l.range.end }
    }));
}

export async function getDefinition(uri: vscode.Uri, position: vscode.Position) {
    const defs = await vscode.commands.executeCommand<any>('vscode.executeDefinitionProvider', uri, position);
    return defs;
}

export async function getCallHierarchyIncoming(uri: vscode.Uri, position: vscode.Position) {
    const items = await vscode.commands.executeCommand<any>('vscode.prepareCallHierarchy', uri, position);
    if (!items || !items[0]) return [];
    const incoming = await vscode.commands.executeCommand<any>('vscode.provideIncomingCalls', items[0]);
    return incoming || [];
}

export async function getCallHierarchyOutgoing(uri: vscode.Uri, position: vscode.Position) {
    const items = await vscode.commands.executeCommand<any>('vscode.prepareCallHierarchy', uri, position);
    if (!items || !items[0]) return [];
    const outgoing = await vscode.commands.executeCommand<any>('vscode.provideOutgoingCalls', items[0]);
    return outgoing || [];
}

export type FlatSymbol = { name: string; kind: vscode.SymbolKind; range: vscode.Range };

export async function getDocumentSymbols(uri: vscode.Uri): Promise<FlatSymbol[]> {
    try {
        const symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(
            'vscode.executeDocumentSymbolProvider', uri
        );
        if (!symbols || !Array.isArray(symbols)) return [];
        const out: FlatSymbol[] = [];
        const visit = (items: vscode.DocumentSymbol[]) => {
            for (const s of items) {
                out.push({ name: s.name, kind: s.kind, range: s.selectionRange || s.range });
                if (s.children && s.children.length) visit(s.children);
            }
        };
        visit(symbols);
        return out;
    } catch {
        return [];
    }
}
```

## extension/src/util.ts

```typescript
﻿import * as vscode from 'vscode';
import * as fs from 'fs';

export type GraphNode = {
    id: string;
    label: string;
    path: string;
    lang: 'ts' | 'js' | 'tsx' | 'jsx' | 'py' | 'other';
};

export type EdgeLink = { symbolName?: string; targetLine: number };

export type GraphEdge = {
    id: string;
    source: string;
    target: string;
    kind: 'import' | 'call' | 'ref';
    sourceLine?: number;
    targetLine?: number;
    links?: EdgeLink[];
};

export type Graph = { nodes: GraphNode[]; edges: GraphEdge[] };

/**
 * Load the built webview HTML and rewrite asset URLs for the VS Code webview.
 * Handles both "/assets/..." and "./assets/...".
 */
export function htmlForWebview(
    panel: vscode.WebviewPanel,
    context: vscode.ExtensionContext
) {
    const media = vscode.Uri.joinPath(context.extensionUri, 'media');
    const index = vscode.Uri.joinPath(media, 'index.html');
    let html = fs.readFileSync(index.fsPath, 'utf8');

    const fix = (p: string) =>
        panel.webview
            .asWebviewUri(vscode.Uri.joinPath(media, p))
            .toString();

    html = html
        // rewrite src/href="./assets/..." and "/assets/..."
        .replace(/((?:src|href)=["'])\.?\/assets\//g, (_m, p1) => `${p1}${fix('assets/')}`)
        .replace(/__CSP__/g, panel.webview.cspSource);

    return html;
}
```

## extension/tsconfig.json

```json
﻿{
    "compilerOptions": {
        "target": "ES2022",
        "lib": [
            "ES2022"
        ],
        "module": "ESNext",
        "moduleResolution": "Node",
        "strict": true,
        "allowSyntheticDefaultImports": true,
        "skipLibCheck": true,
        "outDir": "dist",
        "rootDir": "src",
        "types": [
            "vscode",
            "node"
        ]
    },
    "include": [
        "src/**/*.ts"
    ]
}
```

## final_review_gate.py

```python
# final_review_gate.py
import sys
import os

if __name__ == "__main__":
    # Try to make stdout unbuffered for more responsive interaction.
    # This might not work on all platforms or if stdout is not a TTY,
    # but it's a good practice for this kind of interactive script.
    try:
        sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', buffering=1)
    except Exception:
        pass # Ignore if unbuffering fails, e.g., in certain environments

    try:
        sys.stderr = os.fdopen(sys.stderr.fileno(), 'w', buffering=1)
    except Exception:
        pass # Ignore

    print("--- FINAL REVIEW GATE ACTIVE ---", flush=True)
    print("AI has completed its primary actions. Awaiting your review or further sub-prompts.", flush=True)
    print("Type your sub-prompt, or one of: 'TASK_COMPLETE', 'Done', 'Quit', 'q' to signal completion.", flush=True) # MODIFIED
    
    active_session = True
    while active_session:
        try:
            # Signal that the script is ready for input.
            # The AI doesn't need to parse this, but it's good for user visibility.
            print("REVIEW_GATE_AWAITING_INPUT:", end="", flush=True) 
            
            line = sys.stdin.readline()
            
            if not line:  # EOF
                print("--- REVIEW GATE: STDIN CLOSED (EOF), EXITING SCRIPT ---", flush=True)
                active_session = False
                break
            
            user_input = line.strip()

            # Check for exit conditions
            if user_input.upper() in ['TASK_COMPLETE', 'DONE', 'QUIT', 'Q']: # MODIFIED: Empty string no longer exits
                print(f"--- REVIEW GATE: USER SIGNALED COMPLETION WITH '{user_input.upper()}' ---", flush=True)
                active_session = False
                break
            elif user_input: # If there's any other non-empty input (and not a completion command)
                # This is the critical line the AI will "listen" for.
                print(f"USER_REVIEW_SUB_PROMPT: {user_input}", flush=True)
            # If user_input was empty (and not a completion command),
            # the loop simply continues, and "REVIEW_GATE_AWAITING_INPUT:" will be printed again.
            
        except KeyboardInterrupt:
            print("--- REVIEW GATE: SESSION INTERRUPTED BY USER (KeyboardInterrupt) ---", flush=True)
            active_session = False
            break
        except Exception as e:
            print(f"--- REVIEW GATE SCRIPT ERROR: {e} ---", flush=True)
            active_session = False
            break
            
    print("--- FINAL REVIEW GATE SCRIPT EXITED ---", flush=True)
```

## package.json

```json
{
  "name": "code-canvas",
  "private": true,
  "version": "1.0.0",
  "description": "Code Canvas",
  "main": "index.js",
  "scripts": {
    "build": "npm -w webview run build && npm -w extension run build",
    "watch": "npm -w webview run dev & npm -w extension run watch",
    "package": "npm -w extension run package"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "workspaces": [
    "webview",
    "extension"
  ],
  "overrides": {}
}
```

## README.md

```markdown
﻿# paste: README.md
```

## repomix-output.md

``````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-14 12:55:01

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.gitignore
extension
  media
    assets
      index-CRI2b931.css
      index-yHFPFp3S.js
    index.html
  package.json
  src
    extension.ts
    git.ts
    graph.ts
    lsp.ts
    util.ts
  tsconfig.json
final_review_gate.py
package.json
README.md
repomix-output.md
webview
  index.html
  package.json
  src
    App.tsx
    code
      CodeCard.tsx
      highlight.ts
    layout.ts
    main.tsx
    reactflow-node-types.tsx
    styles.css
  tsconfig.json
  vite.config.ts
```

# Repository Files


## .gitignore

```text
/final_review_gate.py
node_modules
```

## extension/media/assets/index-CRI2b931.css

```css
.react-flow{direction:ltr}.react-flow__container{position:absolute;width:100%;height:100%;top:0;left:0}.react-flow__pane{z-index:1;cursor:-webkit-grab;cursor:grab}.react-flow__pane.selection{cursor:pointer}.react-flow__pane.dragging{cursor:-webkit-grabbing;cursor:grabbing}.react-flow__viewport{transform-origin:0 0;z-index:2;pointer-events:none}.react-flow__renderer{z-index:4}.react-flow__selection{z-index:6}.react-flow__nodesselection-rect:focus,.react-flow__nodesselection-rect:focus-visible{outline:none}.react-flow .react-flow__edges{pointer-events:none;overflow:visible}.react-flow__edge-path,.react-flow__connection-path{stroke:#b1b1b7;stroke-width:1;fill:none}.react-flow__edge{pointer-events:visibleStroke;cursor:pointer}.react-flow__edge.animated path{stroke-dasharray:5;-webkit-animation:dashdraw .5s linear infinite;animation:dashdraw .5s linear infinite}.react-flow__edge.animated path.react-flow__edge-interaction{stroke-dasharray:none;-webkit-animation:none;animation:none}.react-flow__edge.inactive{pointer-events:none}.react-flow__edge.selected,.react-flow__edge:focus,.react-flow__edge:focus-visible{outline:none}.react-flow__edge.selected .react-flow__edge-path,.react-flow__edge:focus .react-flow__edge-path,.react-flow__edge:focus-visible .react-flow__edge-path{stroke:#555}.react-flow__edge-textwrapper{pointer-events:all}.react-flow__edge-textbg{fill:#fff}.react-flow__edge .react-flow__edge-text{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.react-flow__connection{pointer-events:none}.react-flow__connection .animated{stroke-dasharray:5;-webkit-animation:dashdraw .5s linear infinite;animation:dashdraw .5s linear infinite}.react-flow__connectionline{z-index:1001}.react-flow__nodes{pointer-events:none;transform-origin:0 0}.react-flow__node{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none;pointer-events:all;transform-origin:0 0;box-sizing:border-box;cursor:-webkit-grab;cursor:grab}.react-flow__node.dragging{cursor:-webkit-grabbing;cursor:grabbing}.react-flow__nodesselection{z-index:3;transform-origin:left top;pointer-events:none}.react-flow__nodesselection-rect{position:absolute;pointer-events:all;cursor:-webkit-grab;cursor:grab}.react-flow__handle{position:absolute;pointer-events:none;min-width:5px;min-height:5px;width:6px;height:6px;background:#1a192b;border:1px solid white;border-radius:100%}.react-flow__handle.connectionindicator{pointer-events:all;cursor:crosshair}.react-flow__handle-bottom{top:auto;left:50%;bottom:-4px;transform:translate(-50%)}.react-flow__handle-top{left:50%;top:-4px;transform:translate(-50%)}.react-flow__handle-left{top:50%;left:-4px;transform:translateY(-50%)}.react-flow__handle-right{right:-4px;top:50%;transform:translateY(-50%)}.react-flow__edgeupdater{cursor:move;pointer-events:all}.react-flow__panel{position:absolute;z-index:5;margin:15px}.react-flow__panel.top{top:0}.react-flow__panel.bottom{bottom:0}.react-flow__panel.left{left:0}.react-flow__panel.right{right:0}.react-flow__panel.center{left:50%;transform:translate(-50%)}.react-flow__attribution{font-size:10px;background:#ffffff80;padding:2px 3px;margin:0}.react-flow__attribution a{text-decoration:none;color:#999}@-webkit-keyframes dashdraw{0%{stroke-dashoffset:10}}@keyframes dashdraw{0%{stroke-dashoffset:10}}.react-flow__edgelabel-renderer{position:absolute;width:100%;height:100%;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.react-flow__edge.updating .react-flow__edge-path{stroke:#777}.react-flow__edge-text{font-size:10px}.react-flow__node.selectable:focus,.react-flow__node.selectable:focus-visible{outline:none}.react-flow__node-default,.react-flow__node-input,.react-flow__node-output,.react-flow__node-group{padding:10px;border-radius:3px;width:150px;font-size:12px;color:#222;text-align:center;border-width:1px;border-style:solid;border-color:#1a192b;background-color:#fff}.react-flow__node-default.selectable:hover,.react-flow__node-input.selectable:hover,.react-flow__node-output.selectable:hover,.react-flow__node-group.selectable:hover{box-shadow:0 1px 4px 1px #00000014}.react-flow__node-default.selectable.selected,.react-flow__node-default.selectable:focus,.react-flow__node-default.selectable:focus-visible,.react-flow__node-input.selectable.selected,.react-flow__node-input.selectable:focus,.react-flow__node-input.selectable:focus-visible,.react-flow__node-output.selectable.selected,.react-flow__node-output.selectable:focus,.react-flow__node-output.selectable:focus-visible,.react-flow__node-group.selectable.selected,.react-flow__node-group.selectable:focus,.react-flow__node-group.selectable:focus-visible{box-shadow:0 0 0 .5px #1a192b}.react-flow__node-group{background-color:#f0f0f040}.react-flow__nodesselection-rect,.react-flow__selection{background:#0059dc14;border:1px dotted rgba(0,89,220,.8)}.react-flow__nodesselection-rect:focus,.react-flow__nodesselection-rect:focus-visible,.react-flow__selection:focus,.react-flow__selection:focus-visible{outline:none}.react-flow__controls{box-shadow:0 0 2px 1px #00000014}.react-flow__controls-button{border:none;background:#fefefe;border-bottom:1px solid #eee;box-sizing:content-box;display:flex;justify-content:center;align-items:center;width:16px;height:16px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;user-select:none;padding:5px}.react-flow__controls-button:hover{background:#f4f4f4}.react-flow__controls-button svg{width:100%;max-width:12px;max-height:12px}.react-flow__controls-button:disabled{pointer-events:none}.react-flow__controls-button:disabled svg{fill-opacity:.4}.react-flow__minimap{background-color:#fff}.react-flow__minimap svg{display:block}.react-flow__resize-control{position:absolute}.react-flow__resize-control.left,.react-flow__resize-control.right{cursor:ew-resize}.react-flow__resize-control.top,.react-flow__resize-control.bottom{cursor:ns-resize}.react-flow__resize-control.top.left,.react-flow__resize-control.bottom.right{cursor:nwse-resize}.react-flow__resize-control.bottom.left,.react-flow__resize-control.top.right{cursor:nesw-resize}.react-flow__resize-control.handle{width:4px;height:4px;border:1px solid #fff;border-radius:1px;background-color:#3367d9;transform:translate(-50%,-50%)}.react-flow__resize-control.handle.left{left:0;top:50%}.react-flow__resize-control.handle.right{left:100%;top:50%}.react-flow__resize-control.handle.top{left:50%;top:0}.react-flow__resize-control.handle.bottom{left:50%;top:100%}.react-flow__resize-control.handle.top.left,.react-flow__resize-control.handle.bottom.left{left:0}.react-flow__resize-control.handle.top.right,.react-flow__resize-control.handle.bottom.right{left:100%}.react-flow__resize-control.line{border-color:#3367d9;border-width:0;border-style:solid}.react-flow__resize-control.line.left,.react-flow__resize-control.line.right{width:1px;transform:translate(-50%);top:0;height:100%}.react-flow__resize-control.line.left{left:0;border-left-width:1px}.react-flow__resize-control.line.right{left:100%;border-right-width:1px}.react-flow__resize-control.line.top,.react-flow__resize-control.line.bottom{height:1px;transform:translateY(-50%);left:0;width:100%}.react-flow__resize-control.line.top{top:0;border-top-width:1px}.react-flow__resize-control.line.bottom{border-bottom-width:1px;top:100%}:root{color-scheme:dark}body,html,#root{margin:0;height:100%;background:#0b0e12;color:#cdd6f4;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Inter,sans-serif}.root{height:100%}.toolbar{position:absolute;top:10px;left:10px;z-index:10;display:flex;gap:6px}.toolbar button{background:#111827;border:1px solid #1f2937;color:#e5e7eb;padding:6px 10px;border-radius:8px;cursor:pointer}.file-node{width:100%;height:100%;background:#0d1117;border:1px solid #1f2937;border-radius:12px;overflow:hidden;box-shadow:0 0 0 1px #0b1220 inset}.file-node-header{background:#0b1220;padding:6px 10px;font-weight:600;font-size:12px;letter-spacing:.3px;border-bottom:1px solid #1f2937;cursor:default}.code-card{height:calc(100% - 30px);overflow:auto}.code-card .file-title{display:none}pre.hljs{margin:0;padding:8px 10px 8px 56px;font-size:12px;line-height:1.35;position:relative;counter-reset:line}pre.hljs .code-line{display:block;counter-increment:line;position:relative}pre.hljs .code-line:before{content:counter(line);position:absolute;left:-44px;width:36px;text-align:right;color:#6b7280;opacity:.9}pre.hljs .code-line.highlight{background:#ffd60a26;outline:1px solid rgba(255,214,10,.35)}pre.hljs.wrap{white-space:pre-wrap}.preview{font-size:11px;opacity:.8;padding:8px}.react-flow__minimap{background:#0f1115!important;box-shadow:0 0 0 1px #ffffff0f inset}.react-flow__minimap-mask{fill:#ffffff0f!important}.react-flow__minimap-node{fill:#4f46e5!important;stroke:#fff3!important}.react-flow__renderer,.react-flow__viewport{will-change:transform}pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#79c0ff}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-comment,.hljs-code,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}
```

## extension/media/index.html

```html
<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; img-src vscode-resource: https: data:; style-src 'unsafe-inline' __CSP__; script-src __CSP__; font-src __CSP__; connect-src __CSP__;" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Code Canvas</title>
  <script type="module" crossorigin src="./assets/index-yHFPFp3S.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-CRI2b931.css">
</head>

<body>
    <div id="root"></div>

</body>

</html>
```

## extension/package.json

```json
{
    "name": "code-canvas",
    "displayName": "Code Canvas",
    "publisher": "code-canvas",
    "version": "0.0.1",
    "engines": {
        "vscode": "^1.90.0"
    },
    "categories": [
        "Other"
    ],
    "activationEvents": [
        "onStartupFinished"
    ],
    "main": "dist/extension.js",
    "contributes": {
        "commands": [
            {
                "command": "codeCanvas.open",
                "title": "Code Canvas: Open"
            },
            {
                "command": "codeCanvas.openChanged",
                "title": "Code Canvas: Open Changed Files"
            },
            {
                "command": "codeCanvas.layout.custom",
                "title": "Code Canvas: Layout – Custom"
            },
            {
                "command": "codeCanvas.layout.dagre",
                "title": "Code Canvas: Layout – Dagre"
            },
            {
                "command": "codeCanvas.layout.elk",
                "title": "Code Canvas: Layout – ELK"
            },
            {
                "command": "codeCanvas.layout.force",
                "title": "Code Canvas: Layout – Force"
            },
            {
                "command": "codeCanvas.toggleRefs",
                "title": "Code Canvas: Toggle Refs"
            },
            {
                "command": "codeCanvas.seedFolder",
                "title": "Code Canvas: Open Folder as Seed"
            },
            {
                "command": "codeCanvas.loadMore",
                "title": "Code Canvas: Load 25 More"
            }
        ],
        "keybindings": [
            {
                "command": "codeCanvas.openChanged",
                "key": "shift+o"
            },
            {
                "command": "codeCanvas.loadMore",
                "key": "shift+plus"
            },
            {
                "command": "codeCanvas.layout.custom",
                "key": "shift+1"
            },
            {
                "command": "codeCanvas.layout.dagre",
                "key": "shift+2"
            },
            {
                "command": "codeCanvas.layout.elk",
                "key": "shift+3"
            },
            {
                "command": "codeCanvas.layout.force",
                "key": "shift+4"
            },
            {
                "command": "codeCanvas.toggleRefs",
                "key": "r"
            }
        ],
        "configuration": {
            "title": "Code Canvas",
            "properties": {
                "codeCanvas.maxNodes": {
                    "type": "number",
                    "default": 300,
                    "description": "Maximum nodes to render per subgraph."
                },
                "codeCanvas.excludeGlobs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "default": [
                        "**/node_modules/**",
                        "**/.venv/**",
                        "**/__pycache__/**",
                        "**/dist/**",
                        "**/build/**",
                        "**/.git/**"
                    ],
                    "description": "Extra glob patterns to exclude from indexing."
                },
                "codeCanvas.maxPreviewBytes": {
                    "type": "number",
                    "default": 100000,
                    "description": "Maximum number of bytes of file content to send to the webview for preview per file."
                },
                "codeCanvas.initialCap": {
                    "type": "number",
                    "default": 25,
                    "description": "Initial maximum number of nodes to show when first rendering a graph."
                }
            }
        }
    },
    "scripts": {
        "vscode:prepublish": "npm run build",
        "build": "tsup src/extension.ts --format cjs --dts --out-dir dist --external vscode",
        "watch": "tsup src/extension.ts --watch --format cjs --out-dir dist",
        "package": "vsce package"
    },
    "dependencies": {
        "fast-glob": "^3.3.2",
        "minimatch": "^9.0.5"
    },
    "devDependencies": {
        "@types/node": "^24.2.1",
        "@types/vscode": "^1.102.0",
        "@vscode/vsce": "^3.6.0",
        "tsup": "^8.5.0",
        "typescript": "^5.6"
    }
}
```

## extension/src/extension.ts

```typescript
﻿import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { htmlForWebview, Graph } from './util';
import { buildIndex, subgraph } from './graph';
import { getChangedFiles, watchGitState } from './git';
import * as lsp from './lsp';

let panel: vscode.WebviewPanel | undefined;
let idxPromise: ReturnType<typeof buildIndex> | undefined;
let lastSeeds: string[] = [];
let lastCap: number = 0;

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('codeCanvas.open', () => openPanel(context)),
        vscode.commands.registerCommand('codeCanvas.openChanged', async () => {
            await ensurePanel(context);
            const files = await getChangedFiles();
            panel?.webview.postMessage({ type: 'openChanged', files });
        }),
        vscode.commands.registerCommand('codeCanvas.layout.custom', () => panel?.webview.postMessage({ type: 'layout', algo: 'custom' })),
        vscode.commands.registerCommand('codeCanvas.layout.dagre', () => panel?.webview.postMessage({ type: 'layout', algo: 'dagre' })),
        vscode.commands.registerCommand('codeCanvas.layout.elk', () => panel?.webview.postMessage({ type: 'layout', algo: 'elk' })),
        vscode.commands.registerCommand('codeCanvas.layout.force', () => panel?.webview.postMessage({ type: 'layout', algo: 'force' })),
        vscode.commands.registerCommand('codeCanvas.toggleRefs', () => panel?.webview.postMessage({ type: 'toggleRefs' })),
        vscode.commands.registerCommand('codeCanvas.seedFolder', async () => {
            await ensurePanel(context);
            const picked = await vscode.window.showOpenDialog({ canSelectFiles: false, canSelectFolders: true, canSelectMany: false, openLabel: 'Use Folder as Seed' });
            if (!picked || !picked[0]) return;
            const folder = picked[0].fsPath;
            const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
            if (root && !idxPromise) idxPromise = buildIndex(root);
            const index = await idxPromise;
            if (!index) return;
            const folderNorm = path.resolve(folder);
            const seeds = Array.from(index.nodes).filter(p => isSubPath(folderNorm, p));
            if (!seeds.length) {
                vscode.window.showInformationMessage('Code Canvas: No files found under selected folder.');
                return;
            }
            const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
            const initialCapCfg: number = vscode.workspace.getConfiguration('codeCanvas').get('initialCap') ?? 25;
            const cap = Math.min(maxNodes, initialCapCfg);
            lastSeeds = seeds;
            lastCap = cap;
            const g: Graph = subgraph(index, seeds, cap);
            panel?.webview.postMessage({ type: 'graph', graph: g });
        }),
        vscode.commands.registerCommand('codeCanvas.loadMore', async () => {
            await ensurePanel(context);
            if (!lastSeeds.length) return;
            const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
            if (root && !idxPromise) idxPromise = buildIndex(root);
            const index = await idxPromise;
            if (!index) return;
            const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
            const nextCap = Math.min(maxNodes, lastCap + 25);
            lastCap = nextCap;
            const g: Graph = subgraph(index, lastSeeds, nextCap);
            panel?.webview.postMessage({ type: 'graph', graph: g });
        })
    );

    vscode.workspace.onDidChangeTextDocument(async (e) => {
        if (!panel) return;
        panel.webview.postMessage({ type: 'docChanged', file: e.document.uri.fsPath });
    });

    watchGitState(async () => {
        if (!panel) return;
        const files = await getChangedFiles();
        panel.webview.postMessage({ type: 'gitChanged', files });
    });
}

async function ensurePanel(context: vscode.ExtensionContext) { if (!panel) openPanel(context); }

function openPanel(context: vscode.ExtensionContext) {
    const column = vscode.ViewColumn.Beside;
    panel = vscode.window.createWebviewPanel('codeCanvas', 'Code Canvas', column, {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [vscode.Uri.joinPath(context.extensionUri, 'media')]
    });
    panel.webview.html = htmlForWebview(panel, context);
    panel.onDidDispose(() => panel = undefined);

    // kick off indexing
    const ws = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
    if (ws) idxPromise = buildIndex(ws);

    setTimeout(() => sendInitial(ws), 150);

    panel.webview.onDidReceiveMessage(async (msg) => {
        switch (msg.type) {
            case 'requestGraph': await sendInitial(ws); break;
            case 'expand': await sendExpansion(msg.ids || []); break;
            case 'loadMore': {
                const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
                if (root && !idxPromise) idxPromise = buildIndex(root);
                const index = await idxPromise;
                if (!index || !lastSeeds.length) break;
                const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
                const nextCap = Math.min(maxNodes, lastCap + 25);
                lastCap = nextCap;
                const g: Graph = subgraph(index, lastSeeds, nextCap);
                panel?.webview.postMessage({ type: 'graph', graph: g });
                break;
            }
            case 'openFile': {
                const uri = vscode.Uri.file(msg.path);
                vscode.window.showTextDocument(uri, { preview: false });
                break;
            }
            case 'toggleEdges': {
                panel?.webview.postMessage({ type: 'toggleEdges' });
                break;
            }
            case 'requestChanged': {
                const files = await getChangedFiles();
                panel?.webview.postMessage({ type: 'changedFiles', files });
                break;
            }
            case 'requestRefs': {
                const { path, line, character } = msg;
                const uri = vscode.Uri.file(path);
                const refs = await lsp.getReferences(uri, new vscode.Position(line, character));
                panel?.webview.postMessage({ type: 'refs', at: { path, line, character }, refs });
                break;
            }
            case 'requestDefOpen': {
                const { path, line, character } = msg;
                const fromUri = vscode.Uri.file(path);
                const defs = await lsp.getDefinition(fromUri, new vscode.Position(line, character));
                const loc = Array.isArray(defs) ? defs[0] : defs;
                if (loc) {
                    let openUri: vscode.Uri | undefined;
                    let range: vscode.Range | undefined;
                    const anyLoc = loc as any;
                    if (anyLoc.targetUri) {
                        openUri = toUri(anyLoc.targetUri);
                        range = (anyLoc.targetSelectionRange || anyLoc.targetRange) as vscode.Range | undefined;
                    } else if (anyLoc.uri) {
                        openUri = toUri(anyLoc.uri);
                        range = anyLoc.range as vscode.Range | undefined;
                    }
                    if (openUri) await vscode.window.showTextDocument(openUri, { preview: false, selection: range });
                }
                break;
            }
            case 'requestCode': {
                const { path } = msg;
                const maxBytes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxPreviewBytes') ?? 100_000;
                const content = safeRead(path, maxBytes);
                panel?.webview.postMessage({ type: 'code', path, content });
                break;
            }
            case 'requestCodeMany': {
                const { paths } = msg as { paths: string[] };
                const maxBytes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxPreviewBytes') ?? 100_000;
                const entries = (paths || []).map(p => ({ path: p, content: safeRead(p, maxBytes) }));
                panel?.webview.postMessage({ type: 'codeMany', entries });
                break;
            }
        }
    });
}

async function sendInitial(ws?: string) {
    if (!panel) return;
    if (!ws) { panel.webview.postMessage({ type: 'empty', reason: 'no-workspace' }); return; }

    const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
    const initialCapCfg: number = vscode.workspace.getConfiguration('codeCanvas').get('initialCap') ?? 25;

    // seeds = active editor + changed files
    const active = vscode.window.activeTextEditor?.document.uri.fsPath;
    const changed = (await getChangedFiles()).slice(0, 5);
    const seeds = Array.from(new Set([active, ...changed].filter(Boolean) as string[]));

    panel.webview.postMessage({ type: 'progress', msg: 'Indexing…' });
    const index = await (idxPromise ?? buildIndex(ws));
    panel.webview.postMessage({ type: 'progress', msg: null });

    const initialCap = Math.min(maxNodes, initialCapCfg);
    lastSeeds = seeds;
    lastCap = initialCap;
    const g: Graph = subgraph(index, seeds, initialCap);
    if (!g.nodes.length) panel.webview.postMessage({ type: 'empty', reason: 'no-matched-files' });
    else panel.webview.postMessage({ type: 'graph', graph: g });
}

async function sendExpansion(ids: string[]) {
    if (!panel) return;
    const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
    const index = await idxPromise;
    if (!index) return;
    const g: Graph = subgraph(index, ids, maxNodes);
    panel.webview.postMessage({ type: 'expandResult', graph: g });
}

export function deactivate() { }

function toUri(u: unknown): vscode.Uri | undefined {
    try {
        if (!u) return undefined;
        if (u instanceof vscode.Uri) return u;
        const anyU = u as any;
        if (typeof anyU === 'object' && typeof anyU.scheme === 'string') {
            return vscode.Uri.from(anyU);
        }
        if (typeof u === 'string') {
            const s = u as string;
            if (/^[a-zA-Z]:[\\/]/.test(s)) {
                return vscode.Uri.file(s);
            }
            return vscode.Uri.parse(s);
        }
    } catch { }
    return undefined;
}

function isSubPath(parent: string, child: string): boolean {
    try {
        const parentNorm = path.resolve(parent);
        const childNorm = path.resolve(child);
        if (process.platform === 'win32') {
            const p = parentNorm.replace(/[\\/]+$/, '') + path.sep; // ensure trailing sep
            const c = childNorm;
            return c.toLowerCase().startsWith(p.toLowerCase());
        } else {
            const p = parentNorm.endsWith(path.sep) ? parentNorm : parentNorm + path.sep;
            return childNorm.startsWith(p);
        }
    } catch {
        return false;
    }
}

function safeRead(p: string, _limit: number): string {
    try {
        return fs.readFileSync(p, 'utf8');
    } catch {
        return '';
    }
}
```

## extension/src/git.ts

```typescript
﻿import * as vscode from 'vscode';

export async function getChangedFiles(): Promise<string[]> {
    // Prefer Git extension API if available
    const gitExt = vscode.extensions.getExtension('vscode.git');
    if (gitExt) {
        const api = (gitExt.isActive ? gitExt.exports : await gitExt.activate()).getAPI(1);
        const repo = api.repositories[0];
        if (repo) {
            const files = [
                ...repo.state.workingTreeChanges,
                ...repo.state.mergeChanges,
                ...repo.state.indexChanges
            ].map(c => c.uri.fsPath);
            return Array.from(new Set(files));
        }
    }
    // Fallback: simple status parse
    try {
        const cp = await import('child_process');
        const { stdout } = cp.spawnSync('git', ['status', '--porcelain'], { encoding: 'utf8' });
        return stdout.split('\n').filter(Boolean).map(line => line.slice(3)).filter(Boolean);
    } catch { return []; }
}

export function watchGitState(onChange: () => void) {
    const gitExt = vscode.extensions.getExtension('vscode.git');
    if (!gitExt) return () => { };
    const add = async () => {
        const api = (gitExt.isActive ? gitExt.exports : await gitExt.activate()).getAPI(1);
        const repo = api.repositories[0];
        if (!repo) return () => { };
        const d1 = repo.state.onDidChange(onChange);
        const d2 = api.onDidOpenRepository(onChange);
        const d3 = api.onDidChangeState(onChange);
        return () => { d1.dispose(); d2.dispose(); d3.dispose(); };
    };
    add();
    return () => { };
}
```

## extension/src/graph.ts

```typescript
﻿import fg from 'fast-glob';
import * as path from 'path';
import * as fs from 'fs';
import * as vscode from 'vscode';
import type { Graph } from './util';

const JS_GLOB = ['**/*.{js,jsx,ts,tsx}'];
const PY_GLOB = ['**/*.py'];

type Index = {
    nodes: Set<string>;
    imports: Map<string, Set<string>>; // file -> imported file paths (resolved)
    importLines: Map<string, Map<string, number[]>>; // file -> (resolved -> lines)
    lang: Map<string, 'js' | 'ts' | 'py' | 'other'>;
};

export async function buildIndex(root: string): Promise<Index> {
    const excludes: string[] = vscode.workspace.getConfiguration('codeCanvas').get('excludeGlobs') || [];
    const files = Array.from(new Set([
        ...await fg(JS_GLOB, { cwd: root, absolute: true, ignore: excludes }),
        ...await fg(PY_GLOB, { cwd: root, absolute: true, ignore: excludes }),
    ]));

    const lang = new Map<string, 'js' | 'ts' | 'py' | 'other'>();
    for (const f of files) {
        lang.set(
            f,
            f.endsWith('.py') ? 'py'
                : (f.endsWith('.ts') || f.endsWith('.tsx')) ? 'ts'
                    : 'js'
        );
    }

    const imports = new Map<string, Set<string>>();
    const importLines = new Map<string, Map<string, number[]>>();
    for (const f of files) {
        const src = safeRead(f);
        const specs = lang.get(f) === 'py' ? parsePyImportsWithLines(src) : parseJsTsImportsWithLines(src);
        const targets = new Set<string>();
        const lineMap = new Map<string, number[]>();
        for (const { spec, line } of specs) {
            const r = lang.get(f) === 'py' ? resolvePy(root, f, spec) : resolveJsTs(root, f, spec);
            if (!r) continue;
            targets.add(r);
            const arr = lineMap.get(r) || [];
            arr.push(line);
            lineMap.set(r, arr);
        }
        imports.set(f, targets);
        importLines.set(f, lineMap);
    }

    return { nodes: new Set(files), imports, importLines, lang };
}

// Build a subgraph with BFS from seeds up to max nodes/edges.
export function subgraph(index: Index, seeds: string[], maxNodes: number): Graph {
    const seen = new Set<string>();
    const q: string[] = [];
    for (const s of seeds) if (index.nodes.has(s)) { seen.add(s); q.push(s); }

    // If no valid seeds, pick up to 10 random-ish files to start
    if (q.length === 0) {
        for (const f of Array.from(index.nodes).slice(0, Math.min(10, index.nodes.size))) {
            seen.add(f); q.push(f);
        }
    }

    while (q.length && seen.size < maxNodes) {
        const cur = q.shift()!;
        const out = index.imports.get(cur) || new Set();
        for (const t of out) {
            if (seen.size >= maxNodes) break;
            if (!seen.has(t)) { seen.add(t); q.push(t); }
        }
        // add a bit of reverse reachability (files importing cur)
        for (const [f, outs] of index.imports) {
            if (outs.has(cur) && !seen.has(f)) {
                if (seen.size >= maxNodes) break;
                seen.add(f); q.push(f);
            }
        }
    }

    const nodes = Array.from(seen).map(f => ({
        id: makeSafeId(f),
        label: path.basename(f),
        path: f,
        lang: (index.lang.get(f) || 'other') as any
    }));

    const nodeIdByPath = new Map<string, string>();
    for (const n of nodes) nodeIdByPath.set(n.path, n.id);

    const edges: Graph['edges'] = [];
    for (const s of seen) {
        const lineMap = index.importLines.get(s) || new Map();
        for (const t of (index.imports.get(s) || new Set())) {
            if (seen.has(t)) {
                const sid = nodeIdByPath.get(s)!;
                const tid = nodeIdByPath.get(t)!;
                const lines = lineMap.get(t) || [];
                const sourceLine = lines.length ? lines[0] : undefined;
                const targetLine = 0; // fallback: start of file
                edges.push({ id: `e_${hashString(s + '->' + t + '#' + (sourceLine ?? -1))}`, source: sid, target: tid, kind: 'import', sourceLine, targetLine });
            }
        }
    }

    return { nodes, edges };
}

function safeRead(p: string) { try { return fs.readFileSync(p, 'utf8'); } catch { return ''; } }

function parseJsTsImportsWithLines(code: string): { spec: string; line: number }[] {
    const out: { spec: string; line: number }[] = [];
    const patterns = [
        /import\s+[^'\"]+from\s+['\"]([^'\"]+)['\"]/g,
        /import\s+['\"]([^'\"]+)['\"]/g,
        /export\s+[^'\"]*\s+from\s+['\"]([^'\"]+)['\"]/g
    ];
    for (const r of patterns) {
        let m: RegExpExecArray | null;
        while ((m = r.exec(code))) {
            const idx = m.index ?? 0;
            const line = code.slice(0, idx).split('\n').length - 1;
            out.push({ spec: m[1], line });
        }
    }
    return out;
}
function parsePyImportsWithLines(code: string): { spec: string; line: number }[] {
    const out: { spec: string; line: number }[] = [];
    let m: RegExpExecArray | null;
    const r1 = /^\s*import\s+([\w\.]+)/gm;
    const r2 = /^\s*from\s+([\w\.]+)\s+import\s+[\w\*,\s]+/gm;
    while ((m = r1.exec(code))) {
        const idx = m.index ?? 0;
        const line = code.slice(0, idx).split('\n').length - 1;
        out.push({ spec: m[1], line });
    }
    while ((m = r2.exec(code))) {
        const idx = m.index ?? 0;
        const line = code.slice(0, idx).split('\n').length - 1;
        out.push({ spec: m[1], line });
    }
    return out;
}

function resolveJsTs(root: string, fromFile: string, spec: string): string | undefined {
    if (!spec.startsWith('.') && !spec.startsWith('/')) return; // skip packages
    const base = path.resolve(path.dirname(fromFile), spec);
    const tries = ['', '.ts', '.tsx', '.js', '.jsx', '/index.ts', '/index.tsx', '/index.js', '/index.jsx'];
    for (const t of tries) { const p = base + t; if (fs.existsSync(p)) return p; }
}
function resolvePy(root: string, _from: string, mod: string): string | undefined {
    const parts = mod.split('.');
    const candidates = [
        path.resolve(root, ...parts) + '.py',
        path.resolve(root, ...parts, '__init__.py')
    ];
    for (const p of candidates) if (fs.existsSync(p)) return p;
}

function hashString(input: string): string {
    let hash = 0 >>> 0;
    for (let i = 0; i < input.length; i++) {
        hash = (hash * 31 + input.charCodeAt(i)) >>> 0;
    }
    return hash.toString(36);
}

function makeSafeId(raw: string): string {
    const safe = raw.replace(/[^a-zA-Z0-9_-]/g, '_');
    return `n_${safe}_${hashString(raw)}`;
}
```

## extension/src/lsp.ts

```typescript
﻿import * as vscode from 'vscode';

export async function getReferences(uri: vscode.Uri, position: vscode.Position) {
    const locs = await vscode.commands.executeCommand<vscode.Location[]>(
        'vscode.executeReferenceProvider', uri, position
    );
    return (locs || []).map(l => ({
        uri: l.uri.toString(),
        range: { start: l.range.start, end: l.range.end }
    }));
}

export async function getDefinition(uri: vscode.Uri, position: vscode.Position) {
    const defs = await vscode.commands.executeCommand<any>('vscode.executeDefinitionProvider', uri, position);
    return defs;
}

export async function getCallHierarchyIncoming(uri: vscode.Uri, position: vscode.Position) {
    const items = await vscode.commands.executeCommand<any>('vscode.prepareCallHierarchy', uri, position);
    if (!items || !items[0]) return [];
    const incoming = await vscode.commands.executeCommand<any>('vscode.provideIncomingCalls', items[0]);
    return incoming || [];
}

export async function getCallHierarchyOutgoing(uri: vscode.Uri, position: vscode.Position) {
    const items = await vscode.commands.executeCommand<any>('vscode.prepareCallHierarchy', uri, position);
    if (!items || !items[0]) return [];
    const outgoing = await vscode.commands.executeCommand<any>('vscode.provideOutgoingCalls', items[0]);
    return outgoing || [];
}
```

## extension/src/util.ts

```typescript
﻿import * as vscode from 'vscode';
import * as fs from 'fs';

export type GraphNode = {
    id: string;
    label: string;
    path: string;
    lang: 'ts' | 'js' | 'tsx' | 'jsx' | 'py' | 'other';
};

export type GraphEdge = {
    id: string;
    source: string;
    target: string;
    kind: 'import' | 'call' | 'ref';
    sourceLine?: number;
    targetLine?: number;
};

export type Graph = { nodes: GraphNode[]; edges: GraphEdge[] };

/**
 * Load the built webview HTML and rewrite asset URLs for the VS Code webview.
 * Handles both "/assets/..." and "./assets/...".
 */
export function htmlForWebview(
    panel: vscode.WebviewPanel,
    context: vscode.ExtensionContext
) {
    const media = vscode.Uri.joinPath(context.extensionUri, 'media');
    const index = vscode.Uri.joinPath(media, 'index.html');
    let html = fs.readFileSync(index.fsPath, 'utf8');

    const fix = (p: string) =>
        panel.webview
            .asWebviewUri(vscode.Uri.joinPath(media, p))
            .toString();

    html = html
        // rewrite src/href="./assets/..." and "/assets/..."
        .replace(/((?:src|href)=["'])\.?\/assets\//g, (_m, p1) => `${p1}${fix('assets/')}`)
        .replace(/__CSP__/g, panel.webview.cspSource);

    return html;
}
```

## extension/tsconfig.json

```json
﻿{
    "compilerOptions": {
        "target": "ES2022",
        "lib": [
            "ES2022"
        ],
        "module": "ESNext",
        "moduleResolution": "Node",
        "strict": true,
        "allowSyntheticDefaultImports": true,
        "skipLibCheck": true,
        "outDir": "dist",
        "rootDir": "src",
        "types": [
            "vscode",
            "node"
        ]
    },
    "include": [
        "src/**/*.ts"
    ]
}
```

## final_review_gate.py

```python
# final_review_gate.py
import sys
import os

if __name__ == "__main__":
	# Try to make stdout unbuffered for more responsive interaction.
	# This might not work on all platforms or if stdout is not a TTY,
	# but it's a good practice for this kind of interactive script.
	try:
		sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', buffering=1)
	except Exception:
		pass # Ignore if unbuffering fails, e.g., in certain environments

	try:
		sys.stderr = os.fdopen(sys.stderr.fileno(), 'w', buffering=1)
	except Exception:
		pass # Ignore

	print("--- FINAL REVIEW GATE ACTIVE ---", flush=True)
	print("AI has completed its primary actions. Awaiting your review or further sub-prompts.", flush=True)
	print("Type your sub-prompt, or one of: 'TASK_COMPLETE', 'Done', 'Quit', 'q' to signal completion.", flush=True) # MODIFIED
	
	active_session = True
	while active_session:
		try:
			# Signal that the script is ready for input.
			# The AI doesn't need to parse this, but it's good for user visibility.
			print("REVIEW_GATE_AWAITING_INPUT:", end="", flush=True) 
			
			line = sys.stdin.readline()
			
			if not line:  # EOF
				print("--- REVIEW GATE: STDIN CLOSED (EOF), EXITING SCRIPT ---", flush=True)
				active_session = False
				break
			
			user_input = line.strip()

			# Check for exit conditions
			if user_input.upper() in ['TASK_COMPLETE', 'DONE', 'QUIT', 'Q']: # MODIFIED: Empty string no longer exits
				print(f"--- REVIEW GATE: USER SIGNALED COMPLETION WITH '{user_input.upper()}' ---", flush=True)
				active_session = False
				break
			elif user_input: # If there's any other non-empty input (and not a completion command)
				# This is the critical line the AI will "listen" for.
				print(f"USER_REVIEW_SUB_PROMPT: {user_input}", flush=True)
			# If user_input was empty (and not a completion command),
			# the loop simply continues, and "REVIEW_GATE_AWAITING_INPUT:" will be printed again.
			
		except KeyboardInterrupt:
			print("--- REVIEW GATE: SESSION INTERRUPTED BY USER (KeyboardInterrupt) ---", flush=True)
			active_session = False
			break
		except Exception as e:
			print(f"--- REVIEW GATE SCRIPT ERROR: {e} ---", flush=True)
			active_session = False
			break
			
	print("--- FINAL REVIEW GATE SCRIPT EXITED ---", flush=True)
```

## package.json

```json
{
  "name": "code-canvas",
  "private": true,
  "version": "1.0.0",
  "description": "Code Canvas",
  "main": "index.js",
  "scripts": {
    "build": "npm -w webview run build && npm -w extension run build",
    "watch": "npm -w webview run dev & npm -w extension run watch",
    "package": "npm -w extension run package"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "workspaces": [
    "webview",
    "extension"
  ],
  "overrides": {}
}
```

## README.md

```markdown
﻿# paste: README.md
```

## repomix-output.md

`````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-14 09:03:37

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.gitignore
extension
  media
    assets
      index-CiAVdd7B.js
      index-CRI2b931.css
    index.html
  package.json
  src
    extension.ts
    git.ts
    graph.ts
    lsp.ts
    util.ts
  tsconfig.json
final_review_gate.py
package.json
README.md
repomix-output.md
webview
  index.html
  package.json
  src
    App.tsx
    code
      CodeCard.tsx
      highlight.ts
    layout.ts
    main.tsx
    reactflow-node-types.tsx
    styles.css
  tsconfig.json
  vite.config.ts
```

# Repository Files


## .gitignore

```text
/final_review_gate.py
node_modules
```

## extension/media/assets/index-CRI2b931.css

```css
.react-flow{direction:ltr}.react-flow__container{position:absolute;width:100%;height:100%;top:0;left:0}.react-flow__pane{z-index:1;cursor:-webkit-grab;cursor:grab}.react-flow__pane.selection{cursor:pointer}.react-flow__pane.dragging{cursor:-webkit-grabbing;cursor:grabbing}.react-flow__viewport{transform-origin:0 0;z-index:2;pointer-events:none}.react-flow__renderer{z-index:4}.react-flow__selection{z-index:6}.react-flow__nodesselection-rect:focus,.react-flow__nodesselection-rect:focus-visible{outline:none}.react-flow .react-flow__edges{pointer-events:none;overflow:visible}.react-flow__edge-path,.react-flow__connection-path{stroke:#b1b1b7;stroke-width:1;fill:none}.react-flow__edge{pointer-events:visibleStroke;cursor:pointer}.react-flow__edge.animated path{stroke-dasharray:5;-webkit-animation:dashdraw .5s linear infinite;animation:dashdraw .5s linear infinite}.react-flow__edge.animated path.react-flow__edge-interaction{stroke-dasharray:none;-webkit-animation:none;animation:none}.react-flow__edge.inactive{pointer-events:none}.react-flow__edge.selected,.react-flow__edge:focus,.react-flow__edge:focus-visible{outline:none}.react-flow__edge.selected .react-flow__edge-path,.react-flow__edge:focus .react-flow__edge-path,.react-flow__edge:focus-visible .react-flow__edge-path{stroke:#555}.react-flow__edge-textwrapper{pointer-events:all}.react-flow__edge-textbg{fill:#fff}.react-flow__edge .react-flow__edge-text{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.react-flow__connection{pointer-events:none}.react-flow__connection .animated{stroke-dasharray:5;-webkit-animation:dashdraw .5s linear infinite;animation:dashdraw .5s linear infinite}.react-flow__connectionline{z-index:1001}.react-flow__nodes{pointer-events:none;transform-origin:0 0}.react-flow__node{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none;pointer-events:all;transform-origin:0 0;box-sizing:border-box;cursor:-webkit-grab;cursor:grab}.react-flow__node.dragging{cursor:-webkit-grabbing;cursor:grabbing}.react-flow__nodesselection{z-index:3;transform-origin:left top;pointer-events:none}.react-flow__nodesselection-rect{position:absolute;pointer-events:all;cursor:-webkit-grab;cursor:grab}.react-flow__handle{position:absolute;pointer-events:none;min-width:5px;min-height:5px;width:6px;height:6px;background:#1a192b;border:1px solid white;border-radius:100%}.react-flow__handle.connectionindicator{pointer-events:all;cursor:crosshair}.react-flow__handle-bottom{top:auto;left:50%;bottom:-4px;transform:translate(-50%)}.react-flow__handle-top{left:50%;top:-4px;transform:translate(-50%)}.react-flow__handle-left{top:50%;left:-4px;transform:translateY(-50%)}.react-flow__handle-right{right:-4px;top:50%;transform:translateY(-50%)}.react-flow__edgeupdater{cursor:move;pointer-events:all}.react-flow__panel{position:absolute;z-index:5;margin:15px}.react-flow__panel.top{top:0}.react-flow__panel.bottom{bottom:0}.react-flow__panel.left{left:0}.react-flow__panel.right{right:0}.react-flow__panel.center{left:50%;transform:translate(-50%)}.react-flow__attribution{font-size:10px;background:#ffffff80;padding:2px 3px;margin:0}.react-flow__attribution a{text-decoration:none;color:#999}@-webkit-keyframes dashdraw{0%{stroke-dashoffset:10}}@keyframes dashdraw{0%{stroke-dashoffset:10}}.react-flow__edgelabel-renderer{position:absolute;width:100%;height:100%;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.react-flow__edge.updating .react-flow__edge-path{stroke:#777}.react-flow__edge-text{font-size:10px}.react-flow__node.selectable:focus,.react-flow__node.selectable:focus-visible{outline:none}.react-flow__node-default,.react-flow__node-input,.react-flow__node-output,.react-flow__node-group{padding:10px;border-radius:3px;width:150px;font-size:12px;color:#222;text-align:center;border-width:1px;border-style:solid;border-color:#1a192b;background-color:#fff}.react-flow__node-default.selectable:hover,.react-flow__node-input.selectable:hover,.react-flow__node-output.selectable:hover,.react-flow__node-group.selectable:hover{box-shadow:0 1px 4px 1px #00000014}.react-flow__node-default.selectable.selected,.react-flow__node-default.selectable:focus,.react-flow__node-default.selectable:focus-visible,.react-flow__node-input.selectable.selected,.react-flow__node-input.selectable:focus,.react-flow__node-input.selectable:focus-visible,.react-flow__node-output.selectable.selected,.react-flow__node-output.selectable:focus,.react-flow__node-output.selectable:focus-visible,.react-flow__node-group.selectable.selected,.react-flow__node-group.selectable:focus,.react-flow__node-group.selectable:focus-visible{box-shadow:0 0 0 .5px #1a192b}.react-flow__node-group{background-color:#f0f0f040}.react-flow__nodesselection-rect,.react-flow__selection{background:#0059dc14;border:1px dotted rgba(0,89,220,.8)}.react-flow__nodesselection-rect:focus,.react-flow__nodesselection-rect:focus-visible,.react-flow__selection:focus,.react-flow__selection:focus-visible{outline:none}.react-flow__controls{box-shadow:0 0 2px 1px #00000014}.react-flow__controls-button{border:none;background:#fefefe;border-bottom:1px solid #eee;box-sizing:content-box;display:flex;justify-content:center;align-items:center;width:16px;height:16px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;user-select:none;padding:5px}.react-flow__controls-button:hover{background:#f4f4f4}.react-flow__controls-button svg{width:100%;max-width:12px;max-height:12px}.react-flow__controls-button:disabled{pointer-events:none}.react-flow__controls-button:disabled svg{fill-opacity:.4}.react-flow__minimap{background-color:#fff}.react-flow__minimap svg{display:block}.react-flow__resize-control{position:absolute}.react-flow__resize-control.left,.react-flow__resize-control.right{cursor:ew-resize}.react-flow__resize-control.top,.react-flow__resize-control.bottom{cursor:ns-resize}.react-flow__resize-control.top.left,.react-flow__resize-control.bottom.right{cursor:nwse-resize}.react-flow__resize-control.bottom.left,.react-flow__resize-control.top.right{cursor:nesw-resize}.react-flow__resize-control.handle{width:4px;height:4px;border:1px solid #fff;border-radius:1px;background-color:#3367d9;transform:translate(-50%,-50%)}.react-flow__resize-control.handle.left{left:0;top:50%}.react-flow__resize-control.handle.right{left:100%;top:50%}.react-flow__resize-control.handle.top{left:50%;top:0}.react-flow__resize-control.handle.bottom{left:50%;top:100%}.react-flow__resize-control.handle.top.left,.react-flow__resize-control.handle.bottom.left{left:0}.react-flow__resize-control.handle.top.right,.react-flow__resize-control.handle.bottom.right{left:100%}.react-flow__resize-control.line{border-color:#3367d9;border-width:0;border-style:solid}.react-flow__resize-control.line.left,.react-flow__resize-control.line.right{width:1px;transform:translate(-50%);top:0;height:100%}.react-flow__resize-control.line.left{left:0;border-left-width:1px}.react-flow__resize-control.line.right{left:100%;border-right-width:1px}.react-flow__resize-control.line.top,.react-flow__resize-control.line.bottom{height:1px;transform:translateY(-50%);left:0;width:100%}.react-flow__resize-control.line.top{top:0;border-top-width:1px}.react-flow__resize-control.line.bottom{border-bottom-width:1px;top:100%}:root{color-scheme:dark}body,html,#root{margin:0;height:100%;background:#0b0e12;color:#cdd6f4;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Inter,sans-serif}.root{height:100%}.toolbar{position:absolute;top:10px;left:10px;z-index:10;display:flex;gap:6px}.toolbar button{background:#111827;border:1px solid #1f2937;color:#e5e7eb;padding:6px 10px;border-radius:8px;cursor:pointer}.file-node{width:100%;height:100%;background:#0d1117;border:1px solid #1f2937;border-radius:12px;overflow:hidden;box-shadow:0 0 0 1px #0b1220 inset}.file-node-header{background:#0b1220;padding:6px 10px;font-weight:600;font-size:12px;letter-spacing:.3px;border-bottom:1px solid #1f2937;cursor:default}.code-card{height:calc(100% - 30px);overflow:auto}.code-card .file-title{display:none}pre.hljs{margin:0;padding:8px 10px 8px 56px;font-size:12px;line-height:1.35;position:relative;counter-reset:line}pre.hljs .code-line{display:block;counter-increment:line;position:relative}pre.hljs .code-line:before{content:counter(line);position:absolute;left:-44px;width:36px;text-align:right;color:#6b7280;opacity:.9}pre.hljs .code-line.highlight{background:#ffd60a26;outline:1px solid rgba(255,214,10,.35)}pre.hljs.wrap{white-space:pre-wrap}.preview{font-size:11px;opacity:.8;padding:8px}.react-flow__minimap{background:#0f1115!important;box-shadow:0 0 0 1px #ffffff0f inset}.react-flow__minimap-mask{fill:#ffffff0f!important}.react-flow__minimap-node{fill:#4f46e5!important;stroke:#fff3!important}.react-flow__renderer,.react-flow__viewport{will-change:transform}pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#79c0ff}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-comment,.hljs-code,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}
```

## extension/media/index.html

```html
<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; img-src vscode-resource: https: data:; style-src 'unsafe-inline' __CSP__; script-src __CSP__; font-src __CSP__; connect-src __CSP__;" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Code Canvas</title>
  <script type="module" crossorigin src="./assets/index-CiAVdd7B.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-CRI2b931.css">
</head>

<body>
    <div id="root"></div>

</body>

</html>
```

## extension/package.json

```json
{
    "name": "code-canvas",
    "displayName": "Code Canvas",
    "publisher": "code-canvas",
    "version": "0.0.1",
    "engines": {
        "vscode": "^1.90.0"
    },
    "categories": [
        "Other"
    ],
    "activationEvents": [
        "onStartupFinished"
    ],
    "main": "dist/extension.js",
    "contributes": {
        "commands": [
            {
                "command": "codeCanvas.open",
                "title": "Code Canvas: Open"
            },
            {
                "command": "codeCanvas.openChanged",
                "title": "Code Canvas: Open Changed Files"
            },
            {
                "command": "codeCanvas.layout.custom",
                "title": "Code Canvas: Layout – Custom"
            },
            {
                "command": "codeCanvas.layout.dagre",
                "title": "Code Canvas: Layout – Dagre"
            },
            {
                "command": "codeCanvas.layout.elk",
                "title": "Code Canvas: Layout – ELK"
            },
            {
                "command": "codeCanvas.layout.force",
                "title": "Code Canvas: Layout – Force"
            },
            {
                "command": "codeCanvas.toggleRefs",
                "title": "Code Canvas: Toggle Refs"
            },
            {
                "command": "codeCanvas.seedFolder",
                "title": "Code Canvas: Open Folder as Seed"
            },
            {
                "command": "codeCanvas.loadMore",
                "title": "Code Canvas: Load 25 More"
            }
        ],
        "keybindings": [
            {
                "command": "codeCanvas.openChanged",
                "key": "shift+o"
            },
            {
                "command": "codeCanvas.loadMore",
                "key": "shift+plus"
            },
            {
                "command": "codeCanvas.layout.custom",
                "key": "shift+1"
            },
            {
                "command": "codeCanvas.layout.dagre",
                "key": "shift+2"
            },
            {
                "command": "codeCanvas.layout.elk",
                "key": "shift+3"
            },
            {
                "command": "codeCanvas.layout.force",
                "key": "shift+4"
            },
            {
                "command": "codeCanvas.toggleRefs",
                "key": "r"
            }
        ],
        "configuration": {
            "title": "Code Canvas",
            "properties": {
                "codeCanvas.maxNodes": {
                    "type": "number",
                    "default": 300,
                    "description": "Maximum nodes to render per subgraph."
                },
                "codeCanvas.excludeGlobs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "default": [
                        "**/node_modules/**",
                        "**/.venv/**",
                        "**/__pycache__/**",
                        "**/dist/**",
                        "**/build/**",
                        "**/.git/**"
                    ],
                    "description": "Extra glob patterns to exclude from indexing."
                },
                "codeCanvas.maxPreviewBytes": {
                    "type": "number",
                    "default": 100000,
                    "description": "Maximum number of bytes of file content to send to the webview for preview per file."
                },
                "codeCanvas.initialCap": {
                    "type": "number",
                    "default": 25,
                    "description": "Initial maximum number of nodes to show when first rendering a graph."
                }
            }
        }
    },
    "scripts": {
        "vscode:prepublish": "npm run build",
        "build": "tsup src/extension.ts --format cjs --dts --out-dir dist --external vscode",
        "watch": "tsup src/extension.ts --watch --format cjs --out-dir dist",
        "package": "vsce package"
    },
    "dependencies": {
        "fast-glob": "^3.3.2",
        "minimatch": "^9.0.5"
    },
    "devDependencies": {
        "@types/node": "^24.2.1",
        "@types/vscode": "^1.102.0",
        "@vscode/vsce": "^3.6.0",
        "tsup": "^8.5.0",
        "typescript": "^5.6"
    }
}
```

## extension/src/extension.ts

```typescript
﻿import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { htmlForWebview, Graph } from './util';
import { buildIndex, subgraph } from './graph';
import { getChangedFiles, watchGitState } from './git';
import * as lsp from './lsp';

let panel: vscode.WebviewPanel | undefined;
let idxPromise: ReturnType<typeof buildIndex> | undefined;
let lastSeeds: string[] = [];
let lastCap: number = 0;

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('codeCanvas.open', () => openPanel(context)),
        vscode.commands.registerCommand('codeCanvas.openChanged', async () => {
            await ensurePanel(context);
            const files = await getChangedFiles();
            panel?.webview.postMessage({ type: 'openChanged', files });
        }),
        vscode.commands.registerCommand('codeCanvas.layout.custom', () => panel?.webview.postMessage({ type: 'layout', algo: 'custom' })),
        vscode.commands.registerCommand('codeCanvas.layout.dagre', () => panel?.webview.postMessage({ type: 'layout', algo: 'dagre' })),
        vscode.commands.registerCommand('codeCanvas.layout.elk', () => panel?.webview.postMessage({ type: 'layout', algo: 'elk' })),
        vscode.commands.registerCommand('codeCanvas.layout.force', () => panel?.webview.postMessage({ type: 'layout', algo: 'force' })),
        vscode.commands.registerCommand('codeCanvas.toggleRefs', () => panel?.webview.postMessage({ type: 'toggleRefs' })),
        vscode.commands.registerCommand('codeCanvas.seedFolder', async () => {
            await ensurePanel(context);
            const picked = await vscode.window.showOpenDialog({ canSelectFiles: false, canSelectFolders: true, canSelectMany: false, openLabel: 'Use Folder as Seed' });
            if (!picked || !picked[0]) return;
            const folder = picked[0].fsPath;
            const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
            if (root && !idxPromise) idxPromise = buildIndex(root);
            const index = await idxPromise;
            if (!index) return;
            const folderNorm = path.resolve(folder);
            const seeds = Array.from(index.nodes).filter(p => isSubPath(folderNorm, p));
            if (!seeds.length) {
                vscode.window.showInformationMessage('Code Canvas: No files found under selected folder.');
                return;
            }
            const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
            const initialCapCfg: number = vscode.workspace.getConfiguration('codeCanvas').get('initialCap') ?? 25;
            const cap = Math.min(maxNodes, initialCapCfg);
            lastSeeds = seeds;
            lastCap = cap;
            const g: Graph = subgraph(index, seeds, cap);
            panel?.webview.postMessage({ type: 'graph', graph: g });
        }),
        vscode.commands.registerCommand('codeCanvas.loadMore', async () => {
            await ensurePanel(context);
            if (!lastSeeds.length) return;
            const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
            if (root && !idxPromise) idxPromise = buildIndex(root);
            const index = await idxPromise;
            if (!index) return;
            const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
            const nextCap = Math.min(maxNodes, lastCap + 25);
            lastCap = nextCap;
            const g: Graph = subgraph(index, lastSeeds, nextCap);
            panel?.webview.postMessage({ type: 'graph', graph: g });
        })
    );

    vscode.workspace.onDidChangeTextDocument(async (e) => {
        if (!panel) return;
        panel.webview.postMessage({ type: 'docChanged', file: e.document.uri.fsPath });
    });

    watchGitState(async () => {
        if (!panel) return;
        const files = await getChangedFiles();
        panel.webview.postMessage({ type: 'gitChanged', files });
    });
}

async function ensurePanel(context: vscode.ExtensionContext) { if (!panel) openPanel(context); }

function openPanel(context: vscode.ExtensionContext) {
    const column = vscode.ViewColumn.Beside;
    panel = vscode.window.createWebviewPanel('codeCanvas', 'Code Canvas', column, {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [vscode.Uri.joinPath(context.extensionUri, 'media')]
    });
    panel.webview.html = htmlForWebview(panel, context);
    panel.onDidDispose(() => panel = undefined);

    // kick off indexing
    const ws = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
    if (ws) idxPromise = buildIndex(ws);

    setTimeout(() => sendInitial(ws), 150);

    panel.webview.onDidReceiveMessage(async (msg) => {
        switch (msg.type) {
            case 'requestGraph': await sendInitial(ws); break;
            case 'expand': await sendExpansion(msg.ids || []); break;
            case 'loadMore': {
                const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
                if (root && !idxPromise) idxPromise = buildIndex(root);
                const index = await idxPromise;
                if (!index || !lastSeeds.length) break;
                const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
                const nextCap = Math.min(maxNodes, lastCap + 25);
                lastCap = nextCap;
                const g: Graph = subgraph(index, lastSeeds, nextCap);
                panel?.webview.postMessage({ type: 'graph', graph: g });
                break;
            }
            case 'openFile': {
                const uri = vscode.Uri.file(msg.path);
                vscode.window.showTextDocument(uri, { preview: false });
                break;
            }
            case 'toggleEdges': {
                panel?.webview.postMessage({ type: 'toggleEdges' });
                break;
            }
            case 'requestChanged': {
                const files = await getChangedFiles();
                panel?.webview.postMessage({ type: 'changedFiles', files });
                break;
            }
            case 'requestRefs': {
                const { path, line, character } = msg;
                const uri = vscode.Uri.file(path);
                const refs = await lsp.getReferences(uri, new vscode.Position(line, character));
                panel?.webview.postMessage({ type: 'refs', at: { path, line, character }, refs });
                break;
            }
            case 'requestDefOpen': {
                const { path, line, character } = msg;
                const fromUri = vscode.Uri.file(path);
                const defs = await lsp.getDefinition(fromUri, new vscode.Position(line, character));
                const loc = Array.isArray(defs) ? defs[0] : defs;
                if (loc) {
                    let openUri: vscode.Uri | undefined;
                    let range: vscode.Range | undefined;
                    const anyLoc = loc as any;
                    if (anyLoc.targetUri) {
                        openUri = toUri(anyLoc.targetUri);
                        range = (anyLoc.targetSelectionRange || anyLoc.targetRange) as vscode.Range | undefined;
                    } else if (anyLoc.uri) {
                        openUri = toUri(anyLoc.uri);
                        range = anyLoc.range as vscode.Range | undefined;
                    }
                    if (openUri) await vscode.window.showTextDocument(openUri, { preview: false, selection: range });
                }
                break;
            }
            case 'requestCode': {
                const { path } = msg;
                const maxBytes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxPreviewBytes') ?? 100_000;
                const content = safeRead(path, maxBytes);
                panel?.webview.postMessage({ type: 'code', path, content });
                break;
            }
            case 'requestCodeMany': {
                const { paths } = msg as { paths: string[] };
                const maxBytes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxPreviewBytes') ?? 100_000;
                const entries = (paths || []).map(p => ({ path: p, content: safeRead(p, maxBytes) }));
                panel?.webview.postMessage({ type: 'codeMany', entries });
                break;
            }
        }
    });
}

async function sendInitial(ws?: string) {
    if (!panel) return;
    if (!ws) { panel.webview.postMessage({ type: 'empty', reason: 'no-workspace' }); return; }

    const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
    const initialCapCfg: number = vscode.workspace.getConfiguration('codeCanvas').get('initialCap') ?? 25;

    // seeds = active editor + changed files
    const active = vscode.window.activeTextEditor?.document.uri.fsPath;
    const changed = (await getChangedFiles()).slice(0, 5);
    const seeds = Array.from(new Set([active, ...changed].filter(Boolean) as string[]));

    panel.webview.postMessage({ type: 'progress', msg: 'Indexing…' });
    const index = await (idxPromise ?? buildIndex(ws));
    panel.webview.postMessage({ type: 'progress', msg: null });

    const initialCap = Math.min(maxNodes, initialCapCfg);
    lastSeeds = seeds;
    lastCap = initialCap;
    const g: Graph = subgraph(index, seeds, initialCap);
    if (!g.nodes.length) panel.webview.postMessage({ type: 'empty', reason: 'no-matched-files' });
    else panel.webview.postMessage({ type: 'graph', graph: g });
}

async function sendExpansion(ids: string[]) {
    if (!panel) return;
    const maxNodes: number = vscode.workspace.getConfiguration('codeCanvas').get('maxNodes') ?? 300;
    const index = await idxPromise;
    if (!index) return;
    const g: Graph = subgraph(index, ids, maxNodes);
    panel.webview.postMessage({ type: 'expandResult', graph: g });
}

export function deactivate() { }

function toUri(u: unknown): vscode.Uri | undefined {
    try {
        if (!u) return undefined;
        if (u instanceof vscode.Uri) return u;
        const anyU = u as any;
        if (typeof anyU === 'object' && typeof anyU.scheme === 'string') {
            return vscode.Uri.from(anyU);
        }
        if (typeof u === 'string') {
            const s = u as string;
            if (/^[a-zA-Z]:[\\/]/.test(s)) {
                return vscode.Uri.file(s);
            }
            return vscode.Uri.parse(s);
        }
    } catch { }
    return undefined;
}

function isSubPath(parent: string, child: string): boolean {
    try {
        const parentNorm = path.resolve(parent);
        const childNorm = path.resolve(child);
        if (process.platform === 'win32') {
            const p = parentNorm.replace(/[\\/]+$/, '') + path.sep; // ensure trailing sep
            const c = childNorm;
            return c.toLowerCase().startsWith(p.toLowerCase());
        } else {
            const p = parentNorm.endsWith(path.sep) ? parentNorm : parentNorm + path.sep;
            return childNorm.startsWith(p);
        }
    } catch {
        return false;
    }
}

function safeRead(p: string, _limit: number): string {
    try {
        return fs.readFileSync(p, 'utf8');
    } catch {
        return '';
    }
}
```

## extension/src/git.ts

```typescript
﻿import * as vscode from 'vscode';

export async function getChangedFiles(): Promise<string[]> {
    // Prefer Git extension API if available
    const gitExt = vscode.extensions.getExtension('vscode.git');
    if (gitExt) {
        const api = (gitExt.isActive ? gitExt.exports : await gitExt.activate()).getAPI(1);
        const repo = api.repositories[0];
        if (repo) {
            const files = [
                ...repo.state.workingTreeChanges,
                ...repo.state.mergeChanges,
                ...repo.state.indexChanges
            ].map(c => c.uri.fsPath);
            return Array.from(new Set(files));
        }
    }
    // Fallback: simple status parse
    try {
        const cp = await import('child_process');
        const { stdout } = cp.spawnSync('git', ['status', '--porcelain'], { encoding: 'utf8' });
        return stdout.split('\n').filter(Boolean).map(line => line.slice(3)).filter(Boolean);
    } catch { return []; }
}

export function watchGitState(onChange: () => void) {
    const gitExt = vscode.extensions.getExtension('vscode.git');
    if (!gitExt) return () => { };
    const add = async () => {
        const api = (gitExt.isActive ? gitExt.exports : await gitExt.activate()).getAPI(1);
        const repo = api.repositories[0];
        if (!repo) return () => { };
        const d1 = repo.state.onDidChange(onChange);
        const d2 = api.onDidOpenRepository(onChange);
        const d3 = api.onDidChangeState(onChange);
        return () => { d1.dispose(); d2.dispose(); d3.dispose(); };
    };
    add();
    return () => { };
}
```

## extension/src/graph.ts

```typescript
﻿import fg from 'fast-glob';
import * as path from 'path';
import * as fs from 'fs';
import * as vscode from 'vscode';
import type { Graph } from './util';

const JS_GLOB = ['**/*.{js,jsx,ts,tsx}'];
const PY_GLOB = ['**/*.py'];

type Index = {
    nodes: Set<string>;
    imports: Map<string, Set<string>>; // file -> imported file paths (resolved)
    importLines: Map<string, Map<string, number[]>>; // file -> (resolved -> lines)
    lang: Map<string, 'js' | 'ts' | 'py' | 'other'>;
};

export async function buildIndex(root: string): Promise<Index> {
    const excludes: string[] = vscode.workspace.getConfiguration('codeCanvas').get('excludeGlobs') || [];
    const files = Array.from(new Set([
        ...await fg(JS_GLOB, { cwd: root, absolute: true, ignore: excludes }),
        ...await fg(PY_GLOB, { cwd: root, absolute: true, ignore: excludes }),
    ]));

    const lang = new Map<string, 'js' | 'ts' | 'py' | 'other'>();
    for (const f of files) {
        lang.set(
            f,
            f.endsWith('.py') ? 'py'
                : (f.endsWith('.ts') || f.endsWith('.tsx')) ? 'ts'
                    : 'js'
        );
    }

    const imports = new Map<string, Set<string>>();
    const importLines = new Map<string, Map<string, number[]>>();
    for (const f of files) {
        const src = safeRead(f);
        const specs = lang.get(f) === 'py' ? parsePyImportsWithLines(src) : parseJsTsImportsWithLines(src);
        const targets = new Set<string>();
        const lineMap = new Map<string, number[]>();
        for (const { spec, line } of specs) {
            const r = lang.get(f) === 'py' ? resolvePy(root, f, spec) : resolveJsTs(root, f, spec);
            if (!r) continue;
            targets.add(r);
            const arr = lineMap.get(r) || [];
            arr.push(line);
            lineMap.set(r, arr);
        }
        imports.set(f, targets);
        importLines.set(f, lineMap);
    }

    return { nodes: new Set(files), imports, importLines, lang };
}

// Build a subgraph with BFS from seeds up to max nodes/edges.
export function subgraph(index: Index, seeds: string[], maxNodes: number): Graph {
    const seen = new Set<string>();
    const q: string[] = [];
    for (const s of seeds) if (index.nodes.has(s)) { seen.add(s); q.push(s); }

    // If no valid seeds, pick up to 10 random-ish files to start
    if (q.length === 0) {
        for (const f of Array.from(index.nodes).slice(0, Math.min(10, index.nodes.size))) {
            seen.add(f); q.push(f);
        }
    }

    while (q.length && seen.size < maxNodes) {
        const cur = q.shift()!;
        const out = index.imports.get(cur) || new Set();
        for (const t of out) {
            if (seen.size >= maxNodes) break;
            if (!seen.has(t)) { seen.add(t); q.push(t); }
        }
        // add a bit of reverse reachability (files importing cur)
        for (const [f, outs] of index.imports) {
            if (outs.has(cur) && !seen.has(f)) {
                if (seen.size >= maxNodes) break;
                seen.add(f); q.push(f);
            }
        }
    }

    const nodes = Array.from(seen).map(f => ({
        id: makeSafeId(f),
        label: path.basename(f),
        path: f,
        lang: (index.lang.get(f) || 'other') as any
    }));

    const nodeIdByPath = new Map<string, string>();
    for (const n of nodes) nodeIdByPath.set(n.path, n.id);

    const edges: Graph['edges'] = [];
    for (const s of seen) {
        const lineMap = index.importLines.get(s) || new Map();
        for (const t of (index.imports.get(s) || new Set())) {
            if (seen.has(t)) {
                const sid = nodeIdByPath.get(s)!;
                const tid = nodeIdByPath.get(t)!;
                const lines = lineMap.get(t) || [];
                const sourceLine = lines.length ? lines[0] : undefined;
                const targetLine = 0; // fallback: start of file
                edges.push({ id: `e_${hashString(s + '->' + t + '#' + (sourceLine ?? -1))}`, source: sid, target: tid, kind: 'import', sourceLine, targetLine });
            }
        }
    }

    return { nodes, edges };
}

function safeRead(p: string) { try { return fs.readFileSync(p, 'utf8'); } catch { return ''; } }

function parseJsTsImportsWithLines(code: string): { spec: string; line: number }[] {
    const out: { spec: string; line: number }[] = [];
    const patterns = [
        /import\s+[^'\"]+from\s+['\"]([^'\"]+)['\"]/g,
        /import\s+['\"]([^'\"]+)['\"]/g,
        /export\s+[^'\"]*\s+from\s+['\"]([^'\"]+)['\"]/g
    ];
    for (const r of patterns) {
        let m: RegExpExecArray | null;
        while ((m = r.exec(code))) {
            const idx = m.index ?? 0;
            const line = code.slice(0, idx).split('\n').length - 1;
            out.push({ spec: m[1], line });
        }
    }
    return out;
}
function parsePyImportsWithLines(code: string): { spec: string; line: number }[] {
    const out: { spec: string; line: number }[] = [];
    let m: RegExpExecArray | null;
    const r1 = /^\s*import\s+([\w\.]+)/gm;
    const r2 = /^\s*from\s+([\w\.]+)\s+import\s+[\w\*,\s]+/gm;
    while ((m = r1.exec(code))) {
        const idx = m.index ?? 0;
        const line = code.slice(0, idx).split('\n').length - 1;
        out.push({ spec: m[1], line });
    }
    while ((m = r2.exec(code))) {
        const idx = m.index ?? 0;
        const line = code.slice(0, idx).split('\n').length - 1;
        out.push({ spec: m[1], line });
    }
    return out;
}

function resolveJsTs(root: string, fromFile: string, spec: string): string | undefined {
    if (!spec.startsWith('.') && !spec.startsWith('/')) return; // skip packages
    const base = path.resolve(path.dirname(fromFile), spec);
    const tries = ['', '.ts', '.tsx', '.js', '.jsx', '/index.ts', '/index.tsx', '/index.js', '/index.jsx'];
    for (const t of tries) { const p = base + t; if (fs.existsSync(p)) return p; }
}
function resolvePy(root: string, _from: string, mod: string): string | undefined {
    const parts = mod.split('.');
    const candidates = [
        path.resolve(root, ...parts) + '.py',
        path.resolve(root, ...parts, '__init__.py')
    ];
    for (const p of candidates) if (fs.existsSync(p)) return p;
}

function hashString(input: string): string {
    let hash = 0 >>> 0;
    for (let i = 0; i < input.length; i++) {
        hash = (hash * 31 + input.charCodeAt(i)) >>> 0;
    }
    return hash.toString(36);
}

function makeSafeId(raw: string): string {
    const safe = raw.replace(/[^a-zA-Z0-9_-]/g, '_');
    return `n_${safe}_${hashString(raw)}`;
}
```

## extension/src/lsp.ts

```typescript
﻿import * as vscode from 'vscode';

export async function getReferences(uri: vscode.Uri, position: vscode.Position) {
    const locs = await vscode.commands.executeCommand<vscode.Location[]>(
        'vscode.executeReferenceProvider', uri, position
    );
    return (locs || []).map(l => ({
        uri: l.uri.toString(),
        range: { start: l.range.start, end: l.range.end }
    }));
}

export async function getDefinition(uri: vscode.Uri, position: vscode.Position) {
    const defs = await vscode.commands.executeCommand<any>('vscode.executeDefinitionProvider', uri, position);
    return defs;
}

export async function getCallHierarchyIncoming(uri: vscode.Uri, position: vscode.Position) {
    const items = await vscode.commands.executeCommand<any>('vscode.prepareCallHierarchy', uri, position);
    if (!items || !items[0]) return [];
    const incoming = await vscode.commands.executeCommand<any>('vscode.provideIncomingCalls', items[0]);
    return incoming || [];
}

export async function getCallHierarchyOutgoing(uri: vscode.Uri, position: vscode.Position) {
    const items = await vscode.commands.executeCommand<any>('vscode.prepareCallHierarchy', uri, position);
    if (!items || !items[0]) return [];
    const outgoing = await vscode.commands.executeCommand<any>('vscode.provideOutgoingCalls', items[0]);
    return outgoing || [];
}
```

## extension/src/util.ts

```typescript
﻿import * as vscode from 'vscode';
import * as fs from 'fs';

export type GraphNode = {
    id: string;
    label: string;
    path: string;
    lang: 'ts' | 'js' | 'tsx' | 'jsx' | 'py' | 'other';
};

export type GraphEdge = {
    id: string;
    source: string;
    target: string;
    kind: 'import' | 'call' | 'ref';
    sourceLine?: number;
    targetLine?: number;
};

export type Graph = { nodes: GraphNode[]; edges: GraphEdge[] };

/**
 * Load the built webview HTML and rewrite asset URLs for the VS Code webview.
 * Handles both "/assets/..." and "./assets/...".
 */
export function htmlForWebview(
    panel: vscode.WebviewPanel,
    context: vscode.ExtensionContext
) {
    const media = vscode.Uri.joinPath(context.extensionUri, 'media');
    const index = vscode.Uri.joinPath(media, 'index.html');
    let html = fs.readFileSync(index.fsPath, 'utf8');

    const fix = (p: string) =>
        panel.webview
            .asWebviewUri(vscode.Uri.joinPath(media, p))
            .toString();

    html = html
        // rewrite src/href="./assets/..." and "/assets/..."
        .replace(/((?:src|href)=["'])\.?\/assets\//g, (_m, p1) => `${p1}${fix('assets/')}`)
        .replace(/__CSP__/g, panel.webview.cspSource);

    return html;
}
```

## extension/tsconfig.json

```json
﻿{
    "compilerOptions": {
        "target": "ES2022",
        "lib": [
            "ES2022"
        ],
        "module": "ESNext",
        "moduleResolution": "Node",
        "strict": true,
        "allowSyntheticDefaultImports": true,
        "skipLibCheck": true,
        "outDir": "dist",
        "rootDir": "src",
        "types": [
            "vscode",
            "node"
        ]
    },
    "include": [
        "src/**/*.ts"
    ]
}
```

## final_review_gate.py

```python
# final_review_gate.py
import sys
import os

if __name__ == "__main__":
	# Try to make stdout unbuffered for more responsive interaction.
	# This might not work on all platforms or if stdout is not a TTY,
	# but it's a good practice for this kind of interactive script.
	try:
		sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', buffering=1)
	except Exception:
		pass # Ignore if unbuffering fails, e.g., in certain environments

	try:
		sys.stderr = os.fdopen(sys.stderr.fileno(), 'w', buffering=1)
	except Exception:
		pass # Ignore

	print("--- FINAL REVIEW GATE ACTIVE ---", flush=True)
	print("AI has completed its primary actions. Awaiting your review or further sub-prompts.", flush=True)
	print("Type your sub-prompt, or one of: 'TASK_COMPLETE', 'Done', 'Quit', 'q' to signal completion.", flush=True) # MODIFIED
	
	active_session = True
	while active_session:
		try:
			# Signal that the script is ready for input.
			# The AI doesn't need to parse this, but it's good for user visibility.
			print("REVIEW_GATE_AWAITING_INPUT:", end="", flush=True) 
			
			line = sys.stdin.readline()
			
			if not line:  # EOF
				print("--- REVIEW GATE: STDIN CLOSED (EOF), EXITING SCRIPT ---", flush=True)
				active_session = False
				break
			
			user_input = line.strip()

			# Check for exit conditions
			if user_input.upper() in ['TASK_COMPLETE', 'DONE', 'QUIT', 'Q']: # MODIFIED: Empty string no longer exits
				print(f"--- REVIEW GATE: USER SIGNALED COMPLETION WITH '{user_input.upper()}' ---", flush=True)
				active_session = False
				break
			elif user_input: # If there's any other non-empty input (and not a completion command)
				# This is the critical line the AI will "listen" for.
				print(f"USER_REVIEW_SUB_PROMPT: {user_input}", flush=True)
			# If user_input was empty (and not a completion command),
			# the loop simply continues, and "REVIEW_GATE_AWAITING_INPUT:" will be printed again.
			
		except KeyboardInterrupt:
			print("--- REVIEW GATE: SESSION INTERRUPTED BY USER (KeyboardInterrupt) ---", flush=True)
			active_session = False
			break
		except Exception as e:
			print(f"--- REVIEW GATE SCRIPT ERROR: {e} ---", flush=True)
			active_session = False
			break
			
	print("--- FINAL REVIEW GATE SCRIPT EXITED ---", flush=True)
```

## package.json

```json
{
  "name": "code-canvas",
  "private": true,
  "version": "1.0.0",
  "description": "Code Canvas",
  "main": "index.js",
  "scripts": {
    "build": "npm -w webview run build && npm -w extension run build",
    "watch": "npm -w webview run dev & npm -w extension run watch",
    "package": "npm -w extension run package"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "workspaces": [
    "webview",
    "extension"
  ],
  "overrides": {}
}
```

## README.md

```markdown
﻿# paste: README.md
```

## repomix-output.md

````markdown
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-13 14:04:18

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
extension
  media
    assets
      index-CndG0YVx.js
      index-CzoosWkT.css
    index.html
  package.json
  src
    extension.ts
    git.ts
    graph.ts
    lsp.ts
    util.ts
  tsconfig.json
package.json
README.md
webview
  index.html
  package.json
  src
    App.tsx
    code
      CodeCard.tsx
      highlight.ts
    layout.ts
    main.tsx
    reactflow-node-types.tsx
    styles.css
  tsconfig.json
  vite.config.ts
```

# Repository Files


## extension/media/assets/index-CzoosWkT.css

```css
.react-flow{direction:ltr}.react-flow__container{position:absolute;width:100%;height:100%;top:0;left:0}.react-flow__pane{z-index:1;cursor:-webkit-grab;cursor:grab}.react-flow__pane.selection{cursor:pointer}.react-flow__pane.dragging{cursor:-webkit-grabbing;cursor:grabbing}.react-flow__viewport{transform-origin:0 0;z-index:2;pointer-events:none}.react-flow__renderer{z-index:4}.react-flow__selection{z-index:6}.react-flow__nodesselection-rect:focus,.react-flow__nodesselection-rect:focus-visible{outline:none}.react-flow .react-flow__edges{pointer-events:none;overflow:visible}.react-flow__edge-path,.react-flow__connection-path{stroke:#b1b1b7;stroke-width:1;fill:none}.react-flow__edge{pointer-events:visibleStroke;cursor:pointer}.react-flow__edge.animated path{stroke-dasharray:5;-webkit-animation:dashdraw .5s linear infinite;animation:dashdraw .5s linear infinite}.react-flow__edge.animated path.react-flow__edge-interaction{stroke-dasharray:none;-webkit-animation:none;animation:none}.react-flow__edge.inactive{pointer-events:none}.react-flow__edge.selected,.react-flow__edge:focus,.react-flow__edge:focus-visible{outline:none}.react-flow__edge.selected .react-flow__edge-path,.react-flow__edge:focus .react-flow__edge-path,.react-flow__edge:focus-visible .react-flow__edge-path{stroke:#555}.react-flow__edge-textwrapper{pointer-events:all}.react-flow__edge-textbg{fill:#fff}.react-flow__edge .react-flow__edge-text{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.react-flow__connection{pointer-events:none}.react-flow__connection .animated{stroke-dasharray:5;-webkit-animation:dashdraw .5s linear infinite;animation:dashdraw .5s linear infinite}.react-flow__connectionline{z-index:1001}.react-flow__nodes{pointer-events:none;transform-origin:0 0}.react-flow__node{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none;pointer-events:all;transform-origin:0 0;box-sizing:border-box;cursor:-webkit-grab;cursor:grab}.react-flow__node.dragging{cursor:-webkit-grabbing;cursor:grabbing}.react-flow__nodesselection{z-index:3;transform-origin:left top;pointer-events:none}.react-flow__nodesselection-rect{position:absolute;pointer-events:all;cursor:-webkit-grab;cursor:grab}.react-flow__handle{position:absolute;pointer-events:none;min-width:5px;min-height:5px;width:6px;height:6px;background:#1a192b;border:1px solid white;border-radius:100%}.react-flow__handle.connectionindicator{pointer-events:all;cursor:crosshair}.react-flow__handle-bottom{top:auto;left:50%;bottom:-4px;transform:translate(-50%)}.react-flow__handle-top{left:50%;top:-4px;transform:translate(-50%)}.react-flow__handle-left{top:50%;left:-4px;transform:translateY(-50%)}.react-flow__handle-right{right:-4px;top:50%;transform:translateY(-50%)}.react-flow__edgeupdater{cursor:move;pointer-events:all}.react-flow__panel{position:absolute;z-index:5;margin:15px}.react-flow__panel.top{top:0}.react-flow__panel.bottom{bottom:0}.react-flow__panel.left{left:0}.react-flow__panel.right{right:0}.react-flow__panel.center{left:50%;transform:translate(-50%)}.react-flow__attribution{font-size:10px;background:#ffffff80;padding:2px 3px;margin:0}.react-flow__attribution a{text-decoration:none;color:#999}@-webkit-keyframes dashdraw{0%{stroke-dashoffset:10}}@keyframes dashdraw{0%{stroke-dashoffset:10}}.react-flow__edgelabel-renderer{position:absolute;width:100%;height:100%;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.react-flow__edge.updating .react-flow__edge-path{stroke:#777}.react-flow__edge-text{font-size:10px}.react-flow__node.selectable:focus,.react-flow__node.selectable:focus-visible{outline:none}.react-flow__node-default,.react-flow__node-input,.react-flow__node-output,.react-flow__node-group{padding:10px;border-radius:3px;width:150px;font-size:12px;color:#222;text-align:center;border-width:1px;border-style:solid;border-color:#1a192b;background-color:#fff}.react-flow__node-default.selectable:hover,.react-flow__node-input.selectable:hover,.react-flow__node-output.selectable:hover,.react-flow__node-group.selectable:hover{box-shadow:0 1px 4px 1px #00000014}.react-flow__node-default.selectable.selected,.react-flow__node-default.selectable:focus,.react-flow__node-default.selectable:focus-visible,.react-flow__node-input.selectable.selected,.react-flow__node-input.selectable:focus,.react-flow__node-input.selectable:focus-visible,.react-flow__node-output.selectable.selected,.react-flow__node-output.selectable:focus,.react-flow__node-output.selectable:focus-visible,.react-flow__node-group.selectable.selected,.react-flow__node-group.selectable:focus,.react-flow__node-group.selectable:focus-visible{box-shadow:0 0 0 .5px #1a192b}.react-flow__node-group{background-color:#f0f0f040}.react-flow__nodesselection-rect,.react-flow__selection{background:#0059dc14;border:1px dotted rgba(0,89,220,.8)}.react-flow__nodesselection-rect:focus,.react-flow__nodesselection-rect:focus-visible,.react-flow__selection:focus,.react-flow__selection:focus-visible{outline:none}.react-flow__controls{box-shadow:0 0 2px 1px #00000014}.react-flow__controls-button{border:none;background:#fefefe;border-bottom:1px solid #eee;box-sizing:content-box;display:flex;justify-content:center;align-items:center;width:16px;height:16px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;user-select:none;padding:5px}.react-flow__controls-button:hover{background:#f4f4f4}.react-flow__controls-button svg{width:100%;max-width:12px;max-height:12px}.react-flow__controls-button:disabled{pointer-events:none}.react-flow__controls-button:disabled svg{fill-opacity:.4}.react-flow__minimap{background-color:#fff}.react-flow__minimap svg{display:block}.react-flow__resize-control{position:absolute}.react-flow__resize-control.left,.react-flow__resize-control.right{cursor:ew-resize}.react-flow__resize-control.top,.react-flow__resize-control.bottom{cursor:ns-resize}.react-flow__resize-control.top.left,.react-flow__resize-control.bottom.right{cursor:nwse-resize}.react-flow__resize-control.bottom.left,.react-flow__resize-control.top.right{cursor:nesw-resize}.react-flow__resize-control.handle{width:4px;height:4px;border:1px solid #fff;border-radius:1px;background-color:#3367d9;transform:translate(-50%,-50%)}.react-flow__resize-control.handle.left{left:0;top:50%}.react-flow__resize-control.handle.right{left:100%;top:50%}.react-flow__resize-control.handle.top{left:50%;top:0}.react-flow__resize-control.handle.bottom{left:50%;top:100%}.react-flow__resize-control.handle.top.left,.react-flow__resize-control.handle.bottom.left{left:0}.react-flow__resize-control.handle.top.right,.react-flow__resize-control.handle.bottom.right{left:100%}.react-flow__resize-control.line{border-color:#3367d9;border-width:0;border-style:solid}.react-flow__resize-control.line.left,.react-flow__resize-control.line.right{width:1px;transform:translate(-50%);top:0;height:100%}.react-flow__resize-control.line.left{left:0;border-left-width:1px}.react-flow__resize-control.line.right{left:100%;border-right-width:1px}.react-flow__resize-control.line.top,.react-flow__resize-control.line.bottom{height:1px;transform:translateY(-50%);left:0;width:100%}.react-flow__resize-control.line.top{top:0;border-top-width:1px}.react-flow__resize-control.line.bottom{border-bottom-width:1px;top:100%}:root{color-scheme:dark}body,html,#root{margin:0;height:100%;background:#0b0e12;color:#cdd6f4;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Inter,sans-serif}.root{height:100%}.toolbar{position:absolute;top:10px;left:10px;z-index:10;display:flex;gap:6px}.toolbar button{background:#111827;border:1px solid #1f2937;color:#e5e7eb;padding:6px 10px;border-radius:8px;cursor:pointer}.file-node{width:100%;height:100%;background:#0d1117;border:1px solid #1f2937;border-radius:12px;overflow:hidden;box-shadow:0 0 0 1px #0b1220 inset}.file-node-header{background:#0b1220;padding:6px 10px;font-weight:600;font-size:12px;letter-spacing:.3px;border-bottom:1px solid #1f2937;cursor:default}.code-card{height:calc(100% - 30px);overflow:auto}.code-card .file-title{display:none}pre.hljs{margin:0;padding:8px 10px;font-size:12px;line-height:1.35}.preview{font-size:11px;opacity:.8;padding:8px}
```

## extension/media/index.html

```html
<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; img-src vscode-resource: https: data:; style-src 'unsafe-inline' __CSP__; script-src __CSP__; font-src __CSP__; connect-src __CSP__;" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Code Canvas</title>
  <script type="module" crossorigin src="./assets/index-CndG0YVx.js"></script>
  <link rel="stylesheet" crossorigin href="./assets/index-CzoosWkT.css">
</head>

<body>
    <div id="root"></div>

</body>

</html>
```

## extension/package.json

```json
{
    "name": "code-canvas",
    "displayName": "Code Canvas",
    "publisher": "code-canvas",
    "version": "0.0.1",
    "engines": {
        "vscode": "^1.90.0"
    },
    "categories": [
        "Other"
    ],
    "activationEvents": [
        "onCommand:codeCanvas.open",
        "onCommand:codeCanvas.openChanged",
        "onStartupFinished"
    ],
    "main": "dist/extension.js",
    "contributes": {
        "commands": [
            {
                "command": "codeCanvas.open",
                "title": "Code Canvas: Open"
            },
            {
                "command": "codeCanvas.openChanged",
                "title": "Code Canvas: Open Changed Files"
            },
            {
                "command": "codeCanvas.layout.custom",
                "title": "Code Canvas: Layout – Custom"
            },
            {
                "command": "codeCanvas.layout.dagre",
                "title": "Code Canvas: Layout – Dagre"
            },
            {
                "command": "codeCanvas.layout.elk",
                "title": "Code Canvas: Layout – ELK"
            },
            {
                "command": "codeCanvas.layout.force",
                "title": "Code Canvas: Layout – Force"
            },
            {
                "command": "codeCanvas.toggleRefs",
                "title": "Code Canvas: Toggle Refs"
            }
        ],
        "keybindings": [
            {
                "command": "codeCanvas.openChanged",
                "key": "shift+o"
            },
            {
                "command": "codeCanvas.layout.custom",
                "key": "shift+1"
            },
            {
                "command": "codeCanvas.layout.dagre",
                "key": "shift+2"
            },
            {
                "command": "codeCanvas.layout.elk",
                "key": "shift+3"
            },
            {
                "command": "codeCanvas.layout.force",
                "key": "shift+4"
            },
            {
                "command": "codeCanvas.toggleRefs",
                "key": "r"
            }
        ]
    },
    "scripts": {
        "vscode:prepublish": "npm run build",
        "build": "tsup src/extension.ts --format cjs --dts --out-dir dist --external vscode",
        "watch": "tsup src/extension.ts --watch --format cjs --out-dir dist",
        "package": "vsce package"
    },
    "dependencies": {
        "fast-glob": "^3.3.2",
        "minimatch": "^9.0.5"
    },
    "devDependencies": {
        "@types/node": "^24.2.1",
        "@types/vscode": "^1.102.0",
        "@vscode/vsce": "^3.6.0",
        "tsup": "^8.5.0",
        "typescript": "^5.6"
    }
}
```

## extension/src/extension.ts

```typescript
﻿import * as vscode from 'vscode';
import { htmlForWebview, Graph } from './util';
import { buildImportGraph } from './graph';
import { getChangedFiles, watchGitState } from './git';
import * as lsp from './lsp';

let panel: vscode.WebviewPanel | undefined;

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('codeCanvas.open', () => openPanel(context)),
        vscode.commands.registerCommand('codeCanvas.openChanged', async () => {
            await ensurePanel(context);
            const files = await getChangedFiles();
            panel?.webview.postMessage({ type: 'openChanged', files });
        }),
        vscode.commands.registerCommand('codeCanvas.layout.custom', () => panel?.webview.postMessage({ type: 'layout', algo: 'custom' })),
        vscode.commands.registerCommand('codeCanvas.layout.dagre', () => panel?.webview.postMessage({ type: 'layout', algo: 'dagre' })),
        vscode.commands.registerCommand('codeCanvas.layout.elk', () => panel?.webview.postMessage({ type: 'layout', algo: 'elk' })),
        vscode.commands.registerCommand('codeCanvas.layout.force', () => panel?.webview.postMessage({ type: 'layout', algo: 'force' })),
        vscode.commands.registerCommand('codeCanvas.toggleRefs', () => panel?.webview.postMessage({ type: 'toggleRefs' }))
    );

    vscode.workspace.onDidChangeTextDocument(async (e) => {
        if (!panel) return;
        panel.webview.postMessage({ type: 'docChanged', file: e.document.uri.fsPath });
    });

    watchGitState(async () => {
        if (!panel) return;
        const files = await getChangedFiles();
        panel.webview.postMessage({ type: 'gitChanged', files });
    });
}

async function ensurePanel(context: vscode.ExtensionContext) { if (!panel) openPanel(context); }

function openPanel(context: vscode.ExtensionContext) {
    const column = vscode.ViewColumn.Beside;
    panel = vscode.window.createWebviewPanel('codeCanvas', 'Code Canvas', column, {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [vscode.Uri.joinPath(context.extensionUri, 'media')]
    });
    panel.webview.html = htmlForWebview(panel, context);
    panel.onDidDispose(() => panel = undefined);

    panel.webview.onDidReceiveMessage(async (msg) => {
        switch (msg.type) {
            case 'requestGraph': {
                const ws = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || process.cwd();
                const graph: Graph = await buildImportGraph(ws);
                panel?.webview.postMessage({ type: 'graph', graph });
                break;
            }
            case 'openFile': {
                const uri = vscode.Uri.file(msg.path);
                vscode.window.showTextDocument(uri, { preview: false });
                break;
            }
            case 'requestChanged': {
                const files = await getChangedFiles();
                panel?.webview.postMessage({ type: 'changedFiles', files });
                break;
            }
            case 'requestRefs': {
                const { path, line, character } = msg;
                const uri = vscode.Uri.file(path);
                const refs = await lsp.getReferences(uri, new vscode.Position(line, character));
                panel?.webview.postMessage({ type: 'refs', at: { path, line, character }, refs });
                break;
            }
            case 'requestCalls': {
                const { path, line, character } = msg;
                const uri = vscode.Uri.file(path);
                const incoming = await lsp.getCallHierarchyIncoming(uri, new vscode.Position(line, character));
                const outgoing = await lsp.getCallHierarchyOutgoing(uri, new vscode.Position(line, character));
                panel?.webview.postMessage({ type: 'calls', at: { path, line, character }, incoming, outgoing });
                break;
            }
        }
    });
}

export function deactivate() { }
```

## extension/src/git.ts

```typescript
﻿import * as vscode from 'vscode';

export async function getChangedFiles(): Promise<string[]> {
    // Prefer Git extension API if available
    const gitExt = vscode.extensions.getExtension('vscode.git');
    if (gitExt) {
        const api = (gitExt.isActive ? gitExt.exports : await gitExt.activate()).getAPI(1);
        const repo = api.repositories[0];
        if (repo) {
            const files = [
                ...repo.state.workingTreeChanges,
                ...repo.state.mergeChanges,
                ...repo.state.indexChanges
            ].map(c => c.uri.fsPath);
            return Array.from(new Set(files));
        }
    }
    // Fallback: simple status parse
    try {
        const cp = await import('child_process');
        const { stdout } = cp.spawnSync('git', ['status', '--porcelain'], { encoding: 'utf8' });
        return stdout.split('\n').filter(Boolean).map(line => line.slice(3)).filter(Boolean);
    } catch { return []; }
}

export function watchGitState(onChange: () => void) {
    const gitExt = vscode.extensions.getExtension('vscode.git');
    if (!gitExt) return () => { };
    const add = async () => {
        const api = (gitExt.isActive ? gitExt.exports : await gitExt.activate()).getAPI(1);
        const repo = api.repositories[0];
        if (!repo) return () => { };
        const d1 = repo.state.onDidChange(onChange);
        const d2 = api.onDidOpenRepository(onChange);
        const d3 = api.onDidChangeState(onChange);
        return () => { d1.dispose(); d2.dispose(); d3.dispose(); };
    };
    add();
    return () => { };
}
```

## extension/src/graph.ts

```typescript
﻿import fg from 'fast-glob';
import * as path from 'path';
import * as fs from 'fs';
import type { Graph } from './util';

const JS_GLOB = ['**/*.{js,jsx,ts,tsx}', '!**/node_modules/**', '!**/dist/**', '!**/build/**'];
const PY_GLOB = ['**/*.py', '!**/.venv/**', '!**/__pycache__/**'];

export async function buildImportGraph(root: string): Promise<Graph> {
    const files = Array.from(new Set([
        ...await fg(JS_GLOB, { cwd: root, absolute: true }),
        ...await fg(PY_GLOB, { cwd: root, absolute: true })
    ]));
    const nodes = files.map(f => ({
        id: f,
        label: path.basename(f),
        path: f,
        lang: f.endsWith('.py') ? 'py' : f.endsWith('.ts') || f.endsWith('.tsx') ? 'ts' : 'js'
    }));

    const edges: Graph['edges'] = [];
    for (const f of files) {
        const src = fs.readFileSync(f, 'utf8');
        if (f.endsWith('.py')) parsePyImports(src).forEach(t => pushEdge(edges, f, resolvePy(root, f, t)));
        else parseJsTsImports(src).forEach(t => pushEdge(edges, f, resolveJsTs(root, f, t)));
    }

    return { nodes, edges };
}

function pushEdge(edges: Graph['edges'], sourcePath: string, targetPath?: string) {
    if (!targetPath) return;
    edges.push({ id: `${sourcePath}->${targetPath}`, source: sourcePath, target: targetPath, kind: 'import' });
}

function parseJsTsImports(code: string): string[] {
    const out: string[] = [];
    const r1 = /import\s+[^'"`]+from\s+['"]([^'"`]+)['"]/g; // import X from 'y'
    const r2 = /import\s+['"]([^'"`]+)['"]/g;                 // import 'y'
    const r3 = /export\s+\*?\s*from\s+['"]([^'"`]+)['"]/g;  // export ... from 'y'
    for (const r of [r1, r2, r3]) { let m; while ((m = r.exec(code))) out.push(m[1]); }
    return out;
}

function parsePyImports(code: string): string[] {
    const out: string[] = [];
    const r1 = /^\s*import\s+([\w\.]+)(\s+as\s+\w+)?/gm;          // import a.b as c
    const r2 = /^\s*from\s+([\w\.]+)\s+import\s+[\w\*,\s]+/gm;   // from a.b import c
    let m; while ((m = r1.exec(code))) out.push(m[1]);
    while ((m = r2.exec(code))) out.push(m[1]);
    return out;
}

function resolveJsTs(root: string, fromFile: string, spec: string): string | undefined {
    if (!spec.startsWith('.') && !spec.startsWith('/')) return; // skip package imports for now
    const base = path.resolve(path.dirname(fromFile), spec);
    const tries = ['', '.ts', '.tsx', '.js', '.jsx', '/index.ts', '/index.tsx', '/index.js', '/index.jsx'];
    for (const t of tries) {
        const p = base + t;
        if (fs.existsSync(p)) return p;
    }
    return undefined;
}

function resolvePy(root: string, fromFile: string, mod: string): string | undefined {
    // rudimentary resolver: convert dotted module to path near project root
    // tries sibling packages and project packages; falls back to __init__.py
    const parts = mod.split('.');
    const candidates = [
        path.resolve(root, ...parts) + '.py',
        path.resolve(root, ...parts, '__init__.py')
    ];
    for (const p of candidates) if (require('fs').existsSync(p)) return p;
    return undefined;
}
```

## extension/src/lsp.ts

```typescript
﻿import * as vscode from 'vscode';

export async function getReferences(uri: vscode.Uri, position: vscode.Position) {
    const locs = await vscode.commands.executeCommand<vscode.Location[]>(
        'vscode.executeReferenceProvider', uri, position
    );
    return (locs || []).map(l => ({
        uri: l.uri.toString(),
        range: { start: l.range.start, end: l.range.end }
    }));
}

export async function getDefinition(uri: vscode.Uri, position: vscode.Position) {
    const defs = await vscode.commands.executeCommand<any>('vscode.executeDefinitionProvider', uri, position);
    return defs;
}

export async function getCallHierarchyIncoming(uri: vscode.Uri, position: vscode.Position) {
    const items = await vscode.commands.executeCommand<any>('vscode.prepareCallHierarchy', uri, position);
    if (!items || !items[0]) return [];
    const incoming = await vscode.commands.executeCommand<any>('vscode.provideIncomingCalls', items[0]);
    return incoming || [];
}

export async function getCallHierarchyOutgoing(uri: vscode.Uri, position: vscode.Position) {
    const items = await vscode.commands.executeCommand<any>('vscode.prepareCallHierarchy', uri, position);
    if (!items || !items[0]) return [];
    const outgoing = await vscode.commands.executeCommand<any>('vscode.provideOutgoingCalls', items[0]);
    return outgoing || [];
}
```

## extension/src/util.ts

```typescript
﻿import * as vscode from 'vscode';

export function htmlForWebview(panel: vscode.WebviewPanel, context: vscode.ExtensionContext) {
    const media = vscode.Uri.joinPath(context.extensionUri, 'media');
    const index = vscode.Uri.joinPath(media, 'index.html');
    let html = Buffer.from(require('fs').readFileSync(index.fsPath)).toString('utf8');

    const fix = (p: string) => panel.webview.asWebviewUri(vscode.Uri.joinPath(media, p)).toString();
    html = html
        .replace(/\"\/assets\//g, `"${fix('assets/')}`)
        .replace(/__CSP__/g, panel.webview.cspSource);
    return html;
}

export type GraphNode = { id: string; label: string; path: string; lang: 'ts' | 'js' | 'tsx' | 'jsx' | 'py' | 'other'; };
export type GraphEdge = { id: string; source: string; target: string; kind: 'import' | 'call' | 'ref'; };
export type Graph = { nodes: GraphNode[]; edges: GraphEdge[] };
```

## extension/tsconfig.json

```json
﻿{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "moduleResolution": "Node",
    "strict": true,
    "skipLibCheck": true,
    "outDir": "dist",
    "rootDir": "src",
    "types": ["vscode", "node"]
  },
  "include": ["src/**/*.ts"]
}
```

## package.json

```json
{
  "name": "code-canvas",
  "private": true,
  "version": "1.0.0",
  "description": "Code Canvas",
  "main": "index.js",
  "scripts": {
    "build": "npm -w webview run build && npm -w extension run build",
    "watch": "npm -w webview run dev & npm -w extension run watch",
    "package": "npm -w extension run package"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "workspaces": [
    "webview",
    "extension"
  ],
  "overrides": {}
}
```

## README.md

```markdown
﻿# paste: README.md
```

## webview/index.html

```html
﻿<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; img-src vscode-resource: https: data:; style-src 'unsafe-inline' __CSP__; script-src __CSP__; font-src __CSP__; connect-src __CSP__;" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Code Canvas</title>
</head>

<body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
</body>

</html>
```

## webview/package.json

```json
{
    "name": "code-canvas-webview",
    "private": true,
    "version": "0.0.1",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "vite build"
    },
    "dependencies": {
        "dagre": "^0.8.5",
        "elkjs": "^0.10.0",
        "highlight.js": "^11.9.0",
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "reactflow": "^11.11.4"
    },
    "devDependencies": {
        "@types/react": "^18.3.3",
        "@types/react-dom": "^18.3.0",
        "typescript": "^5.6",
        "vite": "^7.1.2"
    }
}
```

## webview/src/App.tsx

```text
﻿import React, { useEffect, useMemo, useRef, useState } from 'react';
import ReactFlow, { Background, Controls, MiniMap } from 'reactflow';
import 'reactflow/dist/style.css';
import { nodeTypes } from './reactflow-node-types';
import CodeCard from './code/CodeCard';
import { dagreLayout, elkLayout } from './layout';

// VS Code webview API
declare global { interface Window { acquireVsCodeApi: any } }
const vscode = window.acquireVsCodeApi?.();

type Node = { id: string; type: 'file'; position: { x: number; y: number }; data: any; style?: any };

export default function App() {
    const [graph, setGraph] = useState<{ nodes: any[]; edges: any[] }>({ nodes: [], edges: [] });
    const [nodes, setNodes] = useState<Node[]>([]);
    const [edges, setEdges] = useState<any[]>([]);
    const lastAlgo = useRef<'custom' | 'dagre' | 'elk' | 'force'>('custom');
    const [showRefs, setShowRefs] = useState(true);

    useEffect(() => {
        vscode?.postMessage({ type: 'requestGraph' });
        vscode?.postMessage({ type: 'requestChanged' });
        const listener = (e: MessageEvent) => {
            const msg = e.data;
            if (msg.type === 'graph') {
                setGraph(msg.graph);
            } else if (msg.type === 'changedFiles') {
                openFiles(msg.files);
            } else if (msg.type === 'openChanged') {
                openFiles(msg.files);
            } else if (msg.type === 'layout') {
                layout(msg.algo);
            } else if (msg.type === 'toggleRefs') {
                setShowRefs(s => !s);
            }
        };
        window.addEventListener('message', listener);
        return () => window.removeEventListener('message', listener);
    }, []);

    useEffect(() => { // build ReactFlow nodes
        const initial: Node[] = graph.nodes.map((n: any, i: number) => ({
            id: n.id,
            type: 'file',
            position: { x: (i % 5) * 400, y: Math.floor(i / 5) * 220 },
            style: { width: 360, height: 200 },
            data: { label: n.label, preview: (<div className="preview">{n.path}</div>), path: n.path, lang: n.lang }
        }));
        const e = graph.edges.map((e: any) => ({ id: e.id, source: e.source, target: e.target }));
        setNodes(initial); setEdges(e);
    }, [graph]);

    function openFiles(paths: string[]) {
        setNodes(prev => {
            const ids = new Set(prev.map(p => p.id));
            const add: Node[] = graph.nodes.filter((n: any) => paths.includes(n.path) && !ids.has(n.id)).map((n: any, i: number) => ({
                id: n.id, type: 'file', position: { x: 50 + i * 30, y: 60 + i * 30 }, style: { width: 480, height: 280 },
                data: { label: n.label, preview: <div className="preview">{n.path}</div>, path: n.path, lang: n.lang }
            }));
            return [...prev, ...add];
        });
    }

    async function layout(algo: 'custom' | 'dagre' | 'elk' | 'force') {
        lastAlgo.current = algo;
        if (algo === 'dagre') setNodes(await dagreLayout(nodes as any, edges as any) as any);
        else if (algo === 'elk') setNodes(await elkLayout(nodes as any, edges as any) as any);
        else if (algo === 'force') {
            // Simple force: jitter spread
            setNodes(nodes.map((n, i) => ({ ...n, position: { x: i * 120 % 1200, y: (i * 220) % 800 } })));
        }
    }

    function onOpenFile(n: Node) { vscode?.postMessage({ type: 'openFile', path: n.data.path }); }

    function onTokenClick({ path, line, character, token }: any) {
        if (!showRefs) return;
        vscode?.postMessage({ type: 'requestRefs', path, line, character, token });
    }

    // render code previews lazily inside each node
    const nodeTypesLocal = useMemo(() => ({
        file: (p: any) => {
            const n = p.data;
            return (
                <div className="file-node">
                    <div className="file-node-header" onDoubleClick={() => onOpenFile(p)}>{n.label}</div>
                    <CodeCard file={n.path} lang={n.lang} content={window.__CODE_CACHE?.[n.path] || n.path} onTokenClick={onTokenClick} />
                </div>
            );
        }
    }), []);

    return (
        <div className="root">
            <div className="toolbar">
                <button onClick={() => layout('custom')}>Custom (⇧1)</button>
                <button onClick={() => layout('dagre')}>Dagre (⇧2)</button>
                <button onClick={() => layout('elk')}>ELK (⇧3)</button>
                <button onClick={() => layout('force')}>Force (⇧4)</button>
                <button onClick={() => vscode?.postMessage({ type: 'requestChanged' })}>Open Changed (⇧O)</button>
                <button onClick={() => vscode?.postMessage({ type: 'toggleRefs' })}>Refs (R)</button>
            </div>
            <ReactFlow nodes={nodes as any} edges={edges} nodeTypes={nodeTypesLocal as any} fitView>
                <Background />
                <MiniMap pannable zoomable />
                <Controls />
            </ReactFlow>
        </div>
    );
}
```

## webview/src/code/CodeCard.tsx

```text
﻿import React, { useMemo } from 'react';
import { highlight } from './highlight';

export default function CodeCard({ file, lang, content, onTokenClick }: {
    file: string; lang: 'ts' | 'js' | 'py' | 'other'; content: string; onTokenClick: (payload: { path: string; line: number; character: number; token: string }) => void;
}) {
    const html = useMemo(() => highlight(content, lang), [content, lang]);

    const onClick: React.MouseEventHandler<HTMLPreElement> = (e) => {
        // lightweight token guess: find word under click using selection API
        const sel = window.getSelection();
        if (!sel || sel.toString().length === 0) return;
        const token = sel.toString();
        // estimate position: count lines and chars up to anchorNode
        const range = sel.getRangeAt(0);
        const pre = range.startContainer.ownerDocument?.getElementById(`code-${file}`);
        if (!pre) return;
        const text = pre.textContent || '';
        const before = text.slice(0, text.indexOf(token));
        const line = before.split('\n').length - 1;
        const character = before.split('\n').pop()!.length;
        onTokenClick({ path: file, line, character, token });
    };

    return (
        <div className="code-card">
            <div className="file-title">{file}</div>
            <pre id={`code-${file}`} className="hljs" onMouseUp={onClick} dangerouslySetInnerHTML={{ __html: html }} />
        </div>
    );
}
```

## webview/src/code/highlight.ts

```typescript
﻿import hljs from 'highlight.js/lib/core';
import ts from 'highlight.js/lib/languages/typescript';
import js from 'highlight.js/lib/languages/javascript';
import py from 'highlight.js/lib/languages/python';

hljs.registerLanguage('typescript', ts);
hljs.registerLanguage('javascript', js);
hljs.registerLanguage('python', py);

export function highlight(code: string, lang: 'ts' | 'js' | 'py' | 'other') {
    const l = lang === 'ts' ? 'typescript' : lang === 'js' ? 'javascript' : lang === 'py' ? 'python' : 'plaintext';
    try { return hljs.highlight(code, { language: l }).value; } catch { return hljs.highlightAuto(code).value; }
}
```

## webview/src/layout.ts

```typescript
﻿import dagre from 'dagre';
import ELK from 'elkjs/lib/elk.bundled.js';

export function dagreLayout(nodes: any[], edges: any[], direction: 'LR' | 'TB' = 'LR') {
    const g = new dagre.graphlib.Graph();
    g.setGraph({ rankdir: direction });
    g.setDefaultEdgeLabel(() => ({}));
    nodes.forEach(n => g.setNode(n.id, { width: n.style?.width || 300, height: n.style?.height || 120 }));
    edges.forEach(e => g.setEdge(e.source, e.target));
    dagre.layout(g);
    return nodes.map(n => { const p = g.node(n.id); return { ...n, position: { x: p.x, y: p.y } }; });
}

const elk = new ELK();
export async function elkLayout(nodes: any[], edges: any[]) {
    const graph = {
        id: 'root',
        layoutOptions: { 'elk.algorithm': 'layered', 'elk.direction': 'RIGHT' },
        children: nodes.map(n => ({ id: n.id, width: n.style?.width || 300, height: n.style?.height || 120 })),
        edges: edges.map(e => ({ id: e.id, sources: [e.source], targets: [e.target] }))
    } as any;
    const res = await elk.layout(graph);
    const pos: Record<string, { x: number; y: number }> = {};
    res.children?.forEach((c: any) => { pos[c.id] = { x: c.x, y: c.y }; });
    return nodes.map(n => ({ ...n, position: pos[n.id] || n.position }));
}
```

## webview/src/main.tsx

```text
﻿import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import './styles.css';

createRoot(document.getElementById('root')!).render(<App />);
```

## webview/src/reactflow-node-types.tsx

```text
﻿import React from 'react';
import { Handle, Position } from 'reactflow';

export function FileNode({ data }: any) {
    return (
        <div className="file-node">
            <div className="file-node-header">{data.label}</div>
            <div className="file-node-body">{data.preview}</div>
            <Handle type="source" position={Position.Right} />
            <Handle type="target" position={Position.Left} />
        </div>
    );
}

export const nodeTypes = { file: FileNode } as const;
```

## webview/src/styles.css

```css
﻿:root {
    color-scheme: dark;
}

body,
html,
#root {
    margin: 0;
    height: 100%;
    background: #0b0e12;
    color: #cdd6f4;
    font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Inter, sans-serif;
}

.root {
    height: 100%;
}

.toolbar {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    display: flex;
    gap: 6px;
}

.toolbar button {
    background: #111827;
    border: 1px solid #1f2937;
    color: #e5e7eb;
    padding: 6px 10px;
    border-radius: 8px;
    cursor: pointer;
}

.file-node {
    width: 100%;
    height: 100%;
    background: #0d1117;
    border: 1px solid #1f2937;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 0 0 1px #0b1220 inset;
}

.file-node-header {
    background: #0b1220;
    padding: 6px 10px;
    font-weight: 600;
    font-size: 12px;
    letter-spacing: .3px;
    border-bottom: 1px solid #1f2937;
    cursor: default;
}

.code-card {
    height: calc(100% - 30px);
    overflow: auto;
}

.code-card .file-title {
    display: none;
}

pre.hljs {
    margin: 0;
    padding: 8px 10px;
    font-size: 12px;
    line-height: 1.35;
}

.preview {
    font-size: 11px;
    opacity: .8;
    padding: 8px;
}
```

## webview/tsconfig.json

```json
﻿{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "allowJs": false,
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "useDefineForClassFields": true
  },
  "include": ["src"]
}
```

## webview/vite.config.ts

```typescript
﻿import { defineConfig } from 'vite';
import path from 'path';

export default defineConfig({
    base: '',
    build: {
        outDir: path.resolve(__dirname, '../extension/media'),
        emptyOutDir: true,
        rollupOptions: {
            input: path.resolve(__dirname, 'index.html')
        }
    }
});
```

## Statistics

- Total Files: 22
- Total Characters: 1898023
- Total Tokens: 0
````

## webview/index.html

```html
﻿<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; img-src vscode-resource: https: data:; style-src 'unsafe-inline' __CSP__; script-src __CSP__; font-src __CSP__; connect-src __CSP__;" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Code Canvas</title>
</head>

<body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
</body>

</html>
```

## webview/package.json

```json
{
    "name": "code-canvas-webview",
    "private": true,
    "version": "0.0.1",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "vite build"
    },
    "dependencies": {
        "dagre": "^0.8.5",
        "elkjs": "^0.10.0",
        "highlight.js": "^11.9.0",
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "reactflow": "^11.11.4"
    },
    "devDependencies": {
        "@types/react": "^18.3.3",
        "@types/react-dom": "^18.3.0",
        "typescript": "^5.6",
        "vite": "^7.1.2"
    }
}
```

## webview/src/App.tsx

```text
﻿import React, { useEffect, useMemo, useRef, useState } from 'react';
import ReactFlow, { Background, Controls, MiniMap, Handle, Position } from 'reactflow';
import 'reactflow/dist/style.css';
import { nodeTypes } from './reactflow-node-types';
import CodeCard from './code/CodeCard';
import { dagreLayout, elkLayout } from './layout';

// VS Code webview API
declare global { interface Window { acquireVsCodeApi: any; __CODE_CACHE?: Record<string, string> } }
const vscode = window.acquireVsCodeApi?.();

type Node = { id: string; type: 'file'; position: { x: number; y: number }; data: any; style?: any };

export default function App() {
    const [graph, setGraph] = useState<{ nodes: any[]; edges: any[] }>({ nodes: [], edges: [] });
    const [nodes, setNodes] = useState<Node[]>([]);
    const [edges, setEdges] = useState<any[]>([]);
    const [rawEdges, setRawEdges] = useState<any[]>([]);
    const [selectedIds, setSelectedIds] = useState<string[]>([]);
    const [emptyMsg, setEmptyMsg] = useState<string | undefined>(undefined);
    const [progress, setProgress] = useState<string | undefined>(undefined);
    const lastAlgo = useRef<'custom' | 'dagre' | 'elk' | 'force'>('elk');
    const [showRefs, setShowRefs] = useState(true);
    const [wrap, setWrap] = useState(false);
    const [showEdges, setShowEdges] = useState(true);
    const [focusIds, setFocusIds] = useState<Set<string> | null>(null);
    const codeCacheRef = useRef<Record<string, string>>({});
    const measuredSizeRef = useRef<Record<string, { width: number; height: number }>>({});
    const pendingMeasureRef = useRef<Record<string, { width: number; height: number }>>({});
    const rafCommitRef = useRef<number | null>(null);
    const headerHeight = 30; // matches CSS: .code-card { height: calc(100% - 30px); }
    const prePaddingTop = 8; // matches CSS: pre.hljs { padding: 8px 10px; }
    const lineHeight = 16; // approx from font-size 12px and line-height 1.35
    const linePosRef = useRef<Record<string, { line: number; top: number }[]>>({});
    const highlightRef = useRef<Record<string, number | undefined>>({});
    const scrollRef = useRef<Record<string, number | undefined>>({});

    function enqueueSizeUpdate(nodeId: string, size: { width: number; height: number }) {
        pendingMeasureRef.current[nodeId] = size;
        if (rafCommitRef.current == null) {
            rafCommitRef.current = window.requestAnimationFrame(() => {
                const updates = pendingMeasureRef.current;
                pendingMeasureRef.current = {};
                rafCommitRef.current = null;
                setNodes(prev => prev.map((x: any) => updates[x.id] ? { ...x, style: updates[x.id] } : x));
            });
        }
    }

    function computeStyleFromContent(content: string) {
        // fallback rough estimate before exact measure arrives
        const text = content || '';
        const lines = text.split('\n');
        const maxLen = lines.reduce((m, l) => Math.max(m, l.length), 0);
        const rawWidth = Math.max(480, Math.floor(maxLen * 7 + 40));
        const rawHeight = Math.max(200, lines.length * 14 + 30);
        // clamp to avoid enormous nodes that can destabilize layout/rendering
        const width = Math.min(rawWidth, 1400);
        const height = Math.min(rawHeight, 900);
        return { width, height } as const;
    }

    useEffect(() => {
        vscode?.postMessage({ type: 'requestGraph' });
        vscode?.postMessage({ type: 'requestChanged' });
        const listener = (e: MessageEvent) => {
            const msg = e.data;
            if (msg.type === 'empty') setEmptyMsg(msg.reason === 'no-workspace'
                ? 'Open a folder to analyze your code.' : 'No JS/TS/Python files found.');
            else if (msg.type === 'progress') setProgress(msg.msg || undefined);
            else if (msg.type === 'graph') {
                setEmptyMsg(undefined); setProgress(undefined); setGraph(msg.graph);
                const paths = (msg.graph?.nodes || []).map((n: any) => n.path);
                if (paths.length) vscode?.postMessage({ type: 'requestCodeMany', paths });
                setRawEdges(msg.graph?.edges || []);
            }
            else if (msg.type === 'expandResult') mergeGraph(msg.graph);
            else if (msg.type === 'changedFiles') {
                openFiles(msg.files);
            } else if (msg.type === 'openChanged') {
                openFiles(msg.files);
            } else if (msg.type === 'layout') {
                layout(msg.algo);
            } else if (msg.type === 'toggleRefs') {
                setShowRefs(s => !s);
            } else if (msg.type === 'toggleEdges') {
                setShowEdges(s => !s);
            } else if (msg.type === 'code') {
                codeCacheRef.current[msg.path] = msg.content || '';
                setNodes(prev => prev.map(n => n.data.path === msg.path ? { ...n, style: computeStyleFromContent(codeCacheRef.current[msg.path]) } : n));
            } else if (msg.type === 'codeMany') {
                const updated = new Set<string>();
                for (const { path, content } of (msg.entries || [])) {
                    codeCacheRef.current[path] = content || '';
                    updated.add(path);
                }
                if (updated.size) setNodes(prev => prev.map(n => updated.has(n.data.path) ? { ...n, style: computeStyleFromContent(codeCacheRef.current[n.data.path]) } : n));
            } else if (msg.type === 'seedFolder') {
                // The extension relays the path; filter current index graph by prefix and request code for those
                const folder: string = msg.folder;
                const selected = (graph.nodes || []).filter((n: any) => (n.path || '').startsWith(folder));
                setNodes(prev => selected.map((n: any, i: number) => ({
                    id: n.id, type: 'file', position: { x: (i % 3) * 1200, y: Math.floor(i / 3) * 1000 },
                    style: computeStyleFromContent(codeCacheRef.current[n.path] || ''), data: { label: n.label, preview: (<div className="preview">{n.path}</div>), path: n.path, lang: n.lang }
                })));
                const paths = selected.map((n: any) => n.path);
                if (paths.length) vscode?.postMessage({ type: 'requestCodeMany', paths });
            }
        };
        window.addEventListener('message', listener);
        return () => window.removeEventListener('message', listener);
    }, []);

    useEffect(() => { // build ReactFlow nodes
        const initial: Node[] = graph.nodes.map((n: any, i: number) => ({
            id: n.id,
            type: 'file',
            position: { x: (i % 3) * 1200, y: Math.floor(i / 3) * 1000 },
            style: computeStyleFromContent(codeCacheRef.current[n.path] || ''),
            data: { label: n.label, preview: (<div className="preview">{n.path}</div>), path: n.path, lang: n.lang }
        }));
        const e = (graph.edges || []).map((e: any) => ({
            id: e.id,
            source: e.source,
            target: e.target,
            data: { sourceLine: e.sourceLine, targetLine: e.targetLine },
            sourceHandle: (e.sourceLine ?? null) !== null && (e.sourceLine ?? undefined) !== undefined ? `line-${e.sourceLine}` : undefined,
            targetHandle: (e.targetLine ?? null) !== null && (e.targetLine ?? undefined) !== undefined ? `line-${e.targetLine}` : undefined
        }));
        setNodes(initial); setEdges(e);
    }, [graph]);

    function mergeGraph(g: any) {
        const newPaths: string[] = [];
        setNodes(prev => {
            const map = new Map(prev.map(n => [n.id, n]));
            for (const n of g.nodes) if (!map.has(n.id)) {
                newPaths.push(n.path);
                map.set(n.id, {
                    id: n.id, type: 'file',
                    position: { x: Math.random() * 800, y: Math.random() * 600 },
                    style: computeStyleFromContent(codeCacheRef.current[n.path] || ''),
                    data: { label: n.label, preview: <div className="preview">{n.path}</div>, path: n.path, lang: n.lang }
                } as any);
            }
            return Array.from(map.values());
        });
        setEdges(prev => {
            const ids = new Set(prev.map(e => e.id));
            const add = g.edges.filter((e: any) => !ids.has(e.id));
            return [...prev, ...add];
        });
        if (newPaths.length) vscode?.postMessage({ type: 'requestCodeMany', paths: newPaths });
        // optional: auto-layout after expand with debounce
        scheduleAutoLayout();
    }

    // Debounced auto-layout to avoid thrashing
    const autoLayoutTimer = useRef<number | null>(null);
    function scheduleAutoLayout() {
        if (autoLayoutTimer.current) {
            window.clearTimeout(autoLayoutTimer.current);
        }
        autoLayoutTimer.current = window.setTimeout(() => { layout('elk'); }, 250);
    }

    function openFiles(paths: string[]) {
        setNodes(prev => {
            const ids = new Set(prev.map(p => p.id));
            const add: Node[] = graph.nodes.filter((n: any) => paths.includes(n.path) && !ids.has(n.id)).map((n: any, i: number) => ({
                id: n.id, type: 'file', position: { x: 50 + i * 30, y: 60 + i * 30 }, style: { width: 480, height: 280 },
                data: { label: n.label, preview: <div className="preview">{n.path}</div>, path: n.path, lang: n.lang }
            }));
            return [...prev, ...add];
        });
        if (paths && paths.length) {
            vscode?.postMessage({ type: 'requestCodeMany', paths });
        }
    }

    async function layout(algo: 'custom' | 'dagre' | 'elk' | 'force') {
        lastAlgo.current = algo;
        if (algo === 'dagre') setNodes(await dagreLayout(nodes as any, edges as any) as any);
        else if (algo === 'elk') setNodes(await elkLayout(nodes as any, edges as any) as any);
        else if (algo === 'force') {
            // Simple force: jitter spread
            setNodes(nodes.map((n, i) => ({ ...n, position: { x: i * 120 % 1200, y: (i * 220) % 800 } })));
        }
        // fit after layout to avoid overlaps staying in view
        setTimeout(() => {
            try { (document.querySelector('.react-flow__controls-zoomout') as HTMLButtonElement)?.click(); } catch { }
        }, 0);
    }

    function onOpenFile(n: Node) { vscode?.postMessage({ type: 'openFile', path: n.data.path }); }

    function onTokenClick({ path, line, character, token }: any) {
        if (!showRefs) return;
        vscode?.postMessage({ type: 'requestRefs', path, line, character, token });
        vscode?.postMessage({ type: 'requestDefOpen', path, line, character });
        // Focus connected nodes to the clicked file
        const base = nodes.find(n => n.data.path === path);
        if (base) focusNodesForId(base.id);
    }

    function expandSelection() {
        const ids = selectedIds.length ? selectedIds : (nodes as any).filter((n: any) => n.selected).map((n: any) => n.id);
        if (ids.length) vscode?.postMessage({ type: 'expand', ids });
    }

    function focusNodesForId(baseId: string) {
        const neighborIds = new Set<string>([baseId]);
        for (const e of edges as any[]) {
            if (e.source === baseId) neighborIds.add(e.target);
            if (e.target === baseId) neighborIds.add(e.source);
        }
        // Build vertical positions for focus lane
        const order: string[] = [baseId, ...Array.from(neighborIds).filter(id => id !== baseId).sort()];
        let currentY = 60;
        const x = 40;
        const spacing = 20;
        const nextPos = new Map<string, { x: number; y: number }>();
        for (const id of order) {
            const n = nodes.find(n => n.id === id);
            const h = (n?.style?.height ?? measuredSizeRef.current[id]?.height ?? 280);
            nextPos.set(id, { x, y: currentY });
            currentY += h + spacing;
        }
        setFocusIds(new Set(neighborIds));
        setNodes(prev => prev.map(n => {
            const inFocus = neighborIds.has(n.id);
            const pos = nextPos.get(n.id);
            if (inFocus && pos) {
                return { ...n, position: pos, data: { ...n.data, dim: false } } as any;
            }
            return { ...n, data: { ...n.data, dim: true } } as any;
        }));
    }

    function clearFocus() {
        setFocusIds(null);
        setNodes(prev => prev.map(n => ({ ...n, data: { ...n.data, dim: false } } as any)));
    }

    useEffect(() => {
        const onKey = (e: KeyboardEvent) => { if ((e.key === 'e' || e.key === 'E')) expandSelection(); };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
    }, [nodes]);

    // render code previews lazily inside each node

    const nodeTypesLocal = useMemo(() => ({
        file: (p: any) => {
            const n = p.data;
            const content = codeCacheRef.current[n.path] ?? n.path;
            const handleLines: number[] = (() => {
                const s = new Set<number>();
                for (const e of edges as any[]) {
                    if (e.source === p.id && e.data?.sourceLine != null) s.add(e.data.sourceLine);
                    if (e.target === p.id && e.data?.targetLine != null) s.add(e.data.targetLine);
                }
                return Array.from(s).sort((a, b) => a - b).slice(0, 200);
            })();
            return (
                <div className="file-node" style={{ opacity: n.dim ? 0.25 : 1 }}>
                    <div className="file-node-header" onDoubleClick={() => onOpenFile(p)}>{n.label}</div>
                    <CodeCard
                        file={n.path}
                        lang={n.lang}
                        content={content}
                        onTokenClick={onTokenClick}
                        wrap={wrap}
                        highlightLine={highlightRef.current[p.id]}
                        scrollToLine={scrollRef.current[p.id]}
                        onLinePositions={(positions) => { linePosRef.current[p.id] = positions; }}
                        onMeasured={({ width, height }) => {
                            const last = measuredSizeRef.current[p.id];
                            if (last && last.width === width && last.height === height) return;
                            measuredSizeRef.current[p.id] = { width, height };
                            enqueueSizeUpdate(p.id, { width, height });
                        }}
                    />
                    {/* default center handles */}
                    <Handle type="source" position={Position.Right} id={`line-0`} />
                    <Handle type="target" position={Position.Left} id={`line-0`} />
                    {/* per-line handles anchored by top offset */}
                    {handleLines.map((ln) => {
                        const top = (linePosRef.current[p.id]?.find(x => x.line === ln)?.top) ?? (headerHeight + prePaddingTop + ln * lineHeight);
                        return (
                            <React.Fragment key={ln}>
                                <Handle
                                    type="source"
                                    position={Position.Right}
                                    id={`line-${ln}`}
                                    style={{ top }}
                                />
                                <Handle
                                    type="target"
                                    position={Position.Left}
                                    id={`line-${ln}`}
                                    style={{ top }}
                                />
                            </React.Fragment>
                        );
                    })}
                </div>
            );
        }
    }), [edges]);

    return (
        <div className="root">
            <div className="toolbar">
                <button onClick={() => layout('custom')}>Custom (⇧1)</button>
                <button onClick={() => layout('dagre')}>Dagre (⇧2)</button>
                <button onClick={() => layout('elk')}>ELK (⇧3)</button>
                <button onClick={() => layout('force')}>Force (⇧4)</button>
                <button onClick={() => vscode?.postMessage({ type: 'loadMore' })}>Load 25 more</button>
                <button onClick={() => vscode?.postMessage({ type: 'requestChanged' })}>Open Changed (⇧O)</button>
                <button onClick={() => vscode?.postMessage({ type: 'requestGraph' })}>Reload</button>
                <button onClick={expandSelection}>Expand (E)</button>
                <button onClick={() => vscode?.postMessage({ type: 'toggleRefs' })}>Refs (R)</button>
                <button onClick={() => setWrap(w => !w)}>{wrap ? 'Unwrap' : 'Wrap'}</button>
                <button onClick={() => setShowEdges(s => !s)}>{showEdges ? 'Hide Edges' : 'Show Edges'}</button>
                <button onClick={() => vscode?.postMessage({ type: 'toggleEdges' })}>Toggle Edges (Global)</button>
                <button onClick={() => vscode?.postMessage({ type: 'seedFolder' })}>Seed Folder…</button>
                {focusIds ? (<button onClick={clearFocus}>Clear Focus</button>) : null}
            </div>
            <ReactFlow
                nodes={nodes as any}
                edges={showEdges ? (focusIds ? (edges as any[]).filter(e => focusIds.has(e.source) && focusIds.has(e.target)) : edges) : []}
                nodeTypes={nodeTypesLocal as any}
                fitView
                onNodeClick={(_e, node: any) => focusNodesForId(node.id)}
                onEdgeClick={(_e, edge: any) => {
                    const sl = (edge?.data?.sourceLine ?? 0);
                    const tl = (edge?.data?.targetLine ?? 0);
                    if (edge?.source) {
                        highlightRef.current[edge.source] = sl;
                        scrollRef.current[edge.source] = sl;
                    }
                    if (edge?.target) {
                        highlightRef.current[edge.target] = tl;
                        scrollRef.current[edge.target] = tl;
                    }
                    // Force a refresh to pass updated props
                    setNodes(n => [...n]);
                    // Also focus on the edge's source node to reorganize
                    if (edge?.source) focusNodesForId(edge.source);
                }}
                onSelectionChange={(p: any) => setSelectedIds((p?.nodes || []).map((n: any) => n.id))}
                minZoom={0.02}
                maxZoom={8}
            >
                <Background />
                <MiniMap pannable zoomable />
                <Controls />
            </ReactFlow>
            {progress && <div style={{ position: 'absolute', inset: 0, display: 'grid', placeItems: 'center', pointerEvents: 'none', fontSize: 14, opacity: .8 }}>⚙ {progress}</div>}
            {emptyMsg && <div style={{ position: 'absolute', inset: 0, display: 'grid', placeItems: 'center', fontSize: 14, opacity: .8 }}>{emptyMsg}</div>}
        </div>
    );
}
```

## webview/src/code/CodeCard.tsx

```text
﻿import React, { useLayoutEffect, useMemo, useRef } from 'react';
import { highlight } from './highlight';

function wrapHighlightedHtmlPreserveLines(highlightedHtml: string): string {
    const container = document.createElement('div');
    container.innerHTML = highlightedHtml;

    const lines: string[] = [];
    let current = '';
    const stack: Element[] = [];

    const escapeHtml = (s: string) => s
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

    const escapeAttr = (s: string) => s
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;');

    const startTag = (el: Element) => {
        const tag = el.tagName.toLowerCase();
        let attrs = '';
        for (const attr of Array.from(el.attributes)) {
            attrs += ` ${attr.name}="${escapeAttr(attr.value)}"`;
        }
        return `<${tag}${attrs}>`;
    };
    const endTag = (el: Element) => `</${el.tagName.toLowerCase()}>`;
    const openAll = () => stack.map(startTag).join('');
    const closeAll = () => stack.slice().reverse().map(endTag).join('');

    const flushLine = () => { lines.push(current); current = ''; };

    const handleText = (text: string) => {
        const parts = text.split(/\r\n|\n/);
        for (let i = 0; i < parts.length; i++) {
            current += escapeHtml(parts[i]);
            if (i < parts.length - 1) {
                current += closeAll();
                flushLine();
                current += openAll();
            }
        }
    };

    const walk = (node: Node) => {
        if (node.nodeType === Node.TEXT_NODE) {
            handleText((node as Text).data);
            return;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
            const el = node as Element;
            current += startTag(el);
            stack.push(el);
            for (const child of Array.from(el.childNodes)) walk(child);
            stack.pop();
            current += endTag(el);
            return;
        }
        // Ignore other node types
    };

    for (const child of Array.from(container.childNodes)) walk(child);
    // Ensure at least one line
    if (current !== '' || lines.length === 0) flushLine();

    return lines
        .map((line, i) => `<span class="code-line" data-line="${i}">${line === '' ? '&nbsp;' : line}</span>`)
        .join('');
}

export default function CodeCard({ file, lang, content, onTokenClick, onMeasured, wrap, onLinePositions, highlightLine, scrollToLine }: {
    file: string; lang: 'ts' | 'js' | 'py' | 'other'; content: string; onTokenClick: (payload: { path: string; line: number; character: number; token: string }) => void; onMeasured?: (size: { width: number; height: number }) => void; wrap?: boolean;
    onLinePositions?: (positions: { line: number; top: number }[]) => void; highlightLine?: number; scrollToLine?: number;
}) {
    const rawHtml = useMemo(() => highlight(content, lang), [content, lang]);
    const html = useMemo(() => wrapHighlightedHtmlPreserveLines(rawHtml), [rawHtml]);
    const preRef = useRef<HTMLPreElement | null>(null);
    const containerRef = useRef<HTMLDivElement | null>(null);

    useLayoutEffect(() => {
        const el = preRef.current;
        if (!el) return;
        const notify = () => onMeasured?.({ width: el.scrollWidth, height: el.scrollHeight });
        notify();
        const ro = new ResizeObserver(() => {
            notify();
            computeLinePositions();
        });
        ro.observe(el);
        const cont = containerRef.current;
        const onScroll = () => computeLinePositions();
        cont?.addEventListener('scroll', onScroll, { passive: true } as any);
        return () => { ro.disconnect(); cont?.removeEventListener('scroll', onScroll as any); };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [html, onMeasured]);

    function computeLinePositions() {
        try {
            const pre = preRef.current;
            const container = containerRef.current;
            const root = container?.closest('.file-node') as HTMLElement | null;
            if (!pre || !container || !root) return;
            const rootRect = root.getBoundingClientRect();
            const spans = Array.from(pre.querySelectorAll('span.code-line')) as HTMLElement[];
            const positions = spans.map((sp, idx) => {
                const spRect = sp.getBoundingClientRect();
                const top = (spRect.top - rootRect.top) + spRect.height / 2;
                return { line: idx, top };
            });
            onLinePositions?.(positions);
        } catch { }
    }

    useLayoutEffect(() => { computeLinePositions(); }, [html]);

    useLayoutEffect(() => {
        if (highlightLine == null) return;
        const pre = preRef.current;
        const container = containerRef.current;
        if (!pre || !container) return;
        const all = pre.querySelectorAll('.code-line.highlight');
        all.forEach(n => n.classList.remove('highlight'));
        const target = pre.querySelector(`.code-line[data-line="${highlightLine}"]`) as HTMLElement | null;
        if (target) {
            target.classList.add('highlight');
        }
    }, [highlightLine]);

    useLayoutEffect(() => {
        if (scrollToLine == null) return;
        const pre = preRef.current;
        const container = containerRef.current;
        if (!pre || !container) return;
        const target = pre.querySelector(`.code-line[data-line="${scrollToLine}"]`) as HTMLElement | null;
        if (target) {
            target.scrollIntoView({ block: 'center' });
        }
    }, [scrollToLine]);

    const onClick: React.MouseEventHandler<HTMLPreElement> = () => {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0 || sel.toString().length === 0) return;
        const token = sel.toString();
        const range = sel.getRangeAt(0);
        const startNode = range.startContainer;
        const startEl: Element | null = startNode.nodeType === Node.ELEMENT_NODE ? (startNode as Element) : (startNode.parentElement);
        if (!startEl) return;
        const lineEl = startEl.closest('.code-line') as HTMLElement | null;
        if (!lineEl) return;
        const lineAttr = lineEl.getAttribute('data-line');
        const line = lineAttr ? parseInt(lineAttr, 10) : 0;
        const headRange = document.createRange();
        headRange.selectNodeContents(lineEl);
        headRange.setEnd(range.startContainer, range.startOffset);
        const character = headRange.toString().length;
        onTokenClick({ path: file, line, character, token });
    };

    return (
        <div className="code-card" ref={containerRef}>
            <div className="file-title">{file}</div>
            <pre ref={preRef} id={`code-${file}`} className={`hljs${wrap ? ' wrap' : ''}`} onMouseUp={onClick} dangerouslySetInnerHTML={{ __html: html }} />
        </div>
    );
}
```

## webview/src/code/highlight.ts

```typescript
﻿import hljs from 'highlight.js/lib/core';
import ts from 'highlight.js/lib/languages/typescript';
import js from 'highlight.js/lib/languages/javascript';
import py from 'highlight.js/lib/languages/python';
import plaintext from 'highlight.js/lib/languages/plaintext';

hljs.registerLanguage('typescript', ts);
hljs.registerLanguage('javascript', js);
hljs.registerLanguage('python', py);
hljs.registerLanguage('plaintext', plaintext);

export function highlight(code: string, lang: 'ts' | 'js' | 'py' | 'other') {
    const mapped = lang === 'ts' ? 'typescript' : lang === 'js' ? 'javascript' : lang === 'py' ? 'python' : 'plaintext';
    try {
        return hljs.highlight(code, { language: mapped, ignoreIllegals: true }).value;
    } catch {
        return hljs.highlightAuto(code).value;
    }
}
```

## webview/src/layout.ts

```typescript
﻿import dagre from 'dagre';
import ELK from 'elkjs/lib/elk.bundled.js';

export function dagreLayout(nodes: any[], edges: any[], direction: 'LR' | 'TB' = 'LR') {
    const g = new dagre.graphlib.Graph();
    g.setGraph({ rankdir: direction });
    g.setDefaultEdgeLabel(() => ({}));
    nodes.forEach(n => g.setNode(n.id, { width: n.style?.width || 300, height: n.style?.height || 120 }));
    edges.forEach(e => g.setEdge(e.source, e.target));
    dagre.layout(g);
    return nodes.map(n => { const p = g.node(n.id); return { ...n, position: { x: p.x, y: p.y } }; });
}

const elk = new ELK();
export async function elkLayout(nodes: any[], edges: any[]) {
    const graph = {
        id: 'root',
        layoutOptions: { 'elk.algorithm': 'layered', 'elk.direction': 'RIGHT' },
        children: nodes.map(n => ({ id: n.id, width: n.style?.width || 300, height: n.style?.height || 120 })),
        edges: edges.map(e => ({ id: e.id, sources: [e.source], targets: [e.target] }))
    } as any;
    const res = await elk.layout(graph);
    const pos: Record<string, { x: number; y: number }> = {};
    res.children?.forEach((c: any) => { pos[c.id] = { x: c.x, y: c.y }; });
    return nodes.map(n => ({ ...n, position: pos[n.id] || n.position }));
}
```

## webview/src/main.tsx

```text
﻿import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import './styles.css';
import 'highlight.js/styles/github-dark.css';

createRoot(document.getElementById('root')!).render(<App />);
```

## webview/src/reactflow-node-types.tsx

```text
﻿import React from 'react';
import { Handle, Position } from 'reactflow';

export function FileNode({ data }: any) {
    return (
        <div className="file-node">
            <div className="file-node-header">{data.label}</div>
            <div className="file-node-body">{data.preview}</div>
            <Handle type="source" position={Position.Right} />
            <Handle type="target" position={Position.Left} />
        </div>
    );
}

export const nodeTypes = { file: FileNode } as const;
```

## webview/src/styles.css

```css
﻿:root {
    color-scheme: dark;
}

body,
html,
#root {
    margin: 0;
    height: 100%;
    background: #0b0e12;
    color: #cdd6f4;
    font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Inter, sans-serif;
}

.root {
    height: 100%;
}

.toolbar {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    display: flex;
    gap: 6px;
}

.toolbar button {
    background: #111827;
    border: 1px solid #1f2937;
    color: #e5e7eb;
    padding: 6px 10px;
    border-radius: 8px;
    cursor: pointer;
}

.file-node {
    width: 100%;
    height: 100%;
    background: #0d1117;
    border: 1px solid #1f2937;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 0 0 1px #0b1220 inset;
}

.file-node-header {
    background: #0b1220;
    padding: 6px 10px;
    font-weight: 600;
    font-size: 12px;
    letter-spacing: .3px;
    border-bottom: 1px solid #1f2937;
    cursor: default;
}

.code-card {
    height: calc(100% - 30px);
    overflow: auto;
}

.code-card .file-title {
    display: none;
}

pre.hljs {
    margin: 0;
    padding: 8px 10px 8px 56px;
    /* leave space for gutter */
    font-size: 12px;
    line-height: 1.35;
    position: relative;
    counter-reset: line;
}

pre.hljs .code-line {
    display: block;
    counter-increment: line;
    position: relative;
}

pre.hljs .code-line::before {
    content: counter(line);
    position: absolute;
    left: -44px;
    width: 36px;
    text-align: right;
    color: #6b7280;
    opacity: 0.9;
}

pre.hljs .code-line.highlight {
    background: rgba(255, 214, 10, 0.15);
    outline: 1px solid rgba(255, 214, 10, 0.35);
}

pre.hljs.wrap {
    white-space: pre-wrap;
}

.preview {
    font-size: 11px;
    opacity: .8;
    padding: 8px;
}

/* Improve MiniMap visibility */
.react-flow__minimap {
    background: #0f1115 !important;
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.06) inset;
}

.react-flow__minimap-mask {
    fill: rgba(255, 255, 255, 0.06) !important;
}

.react-flow__minimap-node {
    fill: #4f46e5 !important;
    stroke: rgba(255, 255, 255, 0.2) !important;
}

/* Allow extreme zooming */
.react-flow__renderer,
.react-flow__viewport {
    will-change: transform;
}
```

## webview/tsconfig.json

```json
﻿{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "allowJs": false,
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "useDefineForClassFields": true
  },
  "include": ["src"]
}
```

## webview/vite.config.ts

```typescript
﻿import { defineConfig } from 'vite';
import path from 'path';

export default defineConfig({
    base: '',
    build: {
        outDir: path.resolve(__dirname, '../extension/media'),
        emptyOutDir: true,
        rollupOptions: {
            input: path.resolve(__dirname, 'index.html')
        }
    }
});
```

## Statistics

- Total Files: 25
- Total Characters: 1983449
- Total Tokens: 0
`````

## webview/index.html

```html
﻿<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; img-src vscode-resource: https: data:; style-src 'unsafe-inline' __CSP__; script-src __CSP__; font-src __CSP__; connect-src __CSP__;" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Code Canvas</title>
</head>

<body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
</body>

</html>
```

## webview/package.json

```json
{
    "name": "code-canvas-webview",
    "private": true,
    "version": "0.0.1",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "vite build"
    },
    "dependencies": {
        "dagre": "^0.8.5",
        "elkjs": "^0.10.0",
        "highlight.js": "^11.9.0",
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "reactflow": "^11.11.4"
    },
    "devDependencies": {
        "@types/react": "^18.3.3",
        "@types/react-dom": "^18.3.0",
        "typescript": "^5.6",
        "vite": "^7.1.2"
    }
}
```

## webview/src/App.tsx

```text
﻿import React, { useEffect, useMemo, useRef, useState } from 'react';
import ReactFlow, { Background, Controls, MiniMap, Handle, Position } from 'reactflow';
import 'reactflow/dist/style.css';
import { nodeTypes } from './reactflow-node-types';
import CodeCard from './code/CodeCard';
import { dagreLayout, elkLayout } from './layout';

// VS Code webview API
declare global { interface Window { acquireVsCodeApi: any; __CODE_CACHE?: Record<string, string> } }
const vscode = window.acquireVsCodeApi?.();

type Node = { id: string; type: 'file'; position: { x: number; y: number }; data: any; style?: any };

export default function App() {
    const [graph, setGraph] = useState<{ nodes: any[]; edges: any[] }>({ nodes: [], edges: [] });
    const [nodes, setNodes] = useState<Node[]>([]);
    const [edges, setEdges] = useState<any[]>([]);
    const [rawEdges, setRawEdges] = useState<any[]>([]);
    const [selectedIds, setSelectedIds] = useState<string[]>([]);
    const [emptyMsg, setEmptyMsg] = useState<string | undefined>(undefined);
    const [progress, setProgress] = useState<string | undefined>(undefined);
    const lastAlgo = useRef<'custom' | 'dagre' | 'elk' | 'force'>('elk');
    const [showRefs, setShowRefs] = useState(true);
    const [wrap, setWrap] = useState(false);
    const [showEdges, setShowEdges] = useState(true);
    const [focusIds, setFocusIds] = useState<Set<string> | null>(null);
    const codeCacheRef = useRef<Record<string, string>>({});
    const measuredSizeRef = useRef<Record<string, { width: number; height: number }>>({});
    const pendingMeasureRef = useRef<Record<string, { width: number; height: number }>>({});
    const rafCommitRef = useRef<number | null>(null);
    const headerHeight = 30; // matches CSS: .code-card { height: calc(100% - 30px); }
    const prePaddingTop = 8; // matches CSS: pre.hljs { padding: 8px 10px; }
    const lineHeight = 16; // approx from font-size 12px and line-height 1.35
    const linePosRef = useRef<Record<string, { line: number; top: number }[]>>({});
    const highlightRef = useRef<Record<string, number | undefined>>({});
    const scrollRef = useRef<Record<string, number | undefined>>({});

    function enqueueSizeUpdate(nodeId: string, size: { width: number; height: number }) {
        pendingMeasureRef.current[nodeId] = size;
        if (rafCommitRef.current == null) {
            rafCommitRef.current = window.requestAnimationFrame(() => {
                const updates = pendingMeasureRef.current;
                pendingMeasureRef.current = {};
                rafCommitRef.current = null;
                setNodes(prev => prev.map((x: any) => updates[x.id] ? { ...x, style: updates[x.id] } : x));
            });
        }
    }

    function computeStyleFromContent(content: string) {
        // fallback rough estimate before exact measure arrives
        const text = content || '';
        const lines = text.split('\n');
        const maxLen = lines.reduce((m, l) => Math.max(m, l.length), 0);
        const rawWidth = Math.max(480, Math.floor(maxLen * 7 + 40));
        const rawHeight = Math.max(200, lines.length * 14 + 30);
        // clamp to avoid enormous nodes that can destabilize layout/rendering
        const width = Math.min(rawWidth, 1400);
        const height = Math.min(rawHeight, 900);
        return { width, height } as const;
    }

    useEffect(() => {
        vscode?.postMessage({ type: 'requestGraph' });
        vscode?.postMessage({ type: 'requestChanged' });
        const listener = (e: MessageEvent) => {
            const msg = e.data;
            if (msg.type === 'empty') setEmptyMsg(msg.reason === 'no-workspace'
                ? 'Open a folder to analyze your code.' : 'No JS/TS/Python files found.');
            else if (msg.type === 'progress') setProgress(msg.msg || undefined);
            else if (msg.type === 'graph') {
                setEmptyMsg(undefined); setProgress(undefined); setGraph(msg.graph);
                const paths = (msg.graph?.nodes || []).map((n: any) => n.path);
                if (paths.length) vscode?.postMessage({ type: 'requestCodeMany', paths });
                setRawEdges(msg.graph?.edges || []);
            }
            else if (msg.type === 'expandResult') mergeGraph(msg.graph);
            else if (msg.type === 'changedFiles') {
                openFiles(msg.files);
            } else if (msg.type === 'openChanged') {
                openFiles(msg.files);
            } else if (msg.type === 'layout') {
                layout(msg.algo);
            } else if (msg.type === 'toggleRefs') {
                setShowRefs(s => !s);
            } else if (msg.type === 'toggleEdges') {
                setShowEdges(s => !s);
            } else if (msg.type === 'code') {
                codeCacheRef.current[msg.path] = msg.content || '';
                setNodes(prev => prev.map(n => n.data.path === msg.path ? { ...n, style: computeStyleFromContent(codeCacheRef.current[msg.path]) } : n));
            } else if (msg.type === 'codeMany') {
                const updated = new Set<string>();
                for (const { path, content } of (msg.entries || [])) {
                    codeCacheRef.current[path] = content || '';
                    updated.add(path);
                }
                if (updated.size) setNodes(prev => prev.map(n => updated.has(n.data.path) ? { ...n, style: computeStyleFromContent(codeCacheRef.current[n.data.path]) } : n));
            } else if (msg.type === 'seedFolder') {
                // The extension relays the path; filter current index graph by prefix and request code for those
                const folder: string = msg.folder;
                const selected = (graph.nodes || []).filter((n: any) => (n.path || '').startsWith(folder));
                setNodes(prev => selected.map((n: any, i: number) => ({
                    id: n.id, type: 'file', position: { x: (i % 3) * 1200, y: Math.floor(i / 3) * 1000 },
                    style: computeStyleFromContent(codeCacheRef.current[n.path] || ''), data: { label: n.label, preview: (<div className="preview">{n.path}</div>), path: n.path, lang: n.lang }
                })));
                const paths = selected.map((n: any) => n.path);
                if (paths.length) vscode?.postMessage({ type: 'requestCodeMany', paths });
            }
        };
        window.addEventListener('message', listener);
        return () => window.removeEventListener('message', listener);
    }, []);

    useEffect(() => { // build ReactFlow nodes
        const initial: Node[] = graph.nodes.map((n: any, i: number) => ({
            id: n.id,
            type: 'file',
            position: { x: (i % 3) * 1200, y: Math.floor(i / 3) * 1000 },
            style: computeStyleFromContent(codeCacheRef.current[n.path] || ''),
            data: { label: n.label, preview: (<div className="preview">{n.path}</div>), path: n.path, lang: n.lang }
        }));
        const e = (graph.edges || []).map((e: any) => ({
            id: e.id,
            source: e.source,
            target: e.target,
            data: { sourceLine: e.sourceLine, targetLine: e.targetLine },
            sourceHandle: (e.sourceLine ?? null) !== null && (e.sourceLine ?? undefined) !== undefined ? `line-${e.sourceLine}` : undefined,
            targetHandle: (e.targetLine ?? null) !== null && (e.targetLine ?? undefined) !== undefined ? `line-${e.targetLine}` : undefined
        }));
        setNodes(initial); setEdges(e);
    }, [graph]);

    function mergeGraph(g: any) {
        const newPaths: string[] = [];
        setNodes(prev => {
            const map = new Map(prev.map(n => [n.id, n]));
            for (const n of g.nodes) if (!map.has(n.id)) {
                newPaths.push(n.path);
                map.set(n.id, {
                    id: n.id, type: 'file',
                    position: { x: Math.random() * 800, y: Math.random() * 600 },
                    style: computeStyleFromContent(codeCacheRef.current[n.path] || ''),
                    data: { label: n.label, preview: <div className="preview">{n.path}</div>, path: n.path, lang: n.lang }
                } as any);
            }
            return Array.from(map.values());
        });
        setEdges(prev => {
            const ids = new Set(prev.map(e => e.id));
            const add = g.edges.filter((e: any) => !ids.has(e.id));
            return [...prev, ...add];
        });
        if (newPaths.length) vscode?.postMessage({ type: 'requestCodeMany', paths: newPaths });
        // optional: auto-layout after expand with debounce
        scheduleAutoLayout();
    }

    // Debounced auto-layout to avoid thrashing
    const autoLayoutTimer = useRef<number | null>(null);
    function scheduleAutoLayout() {
        if (autoLayoutTimer.current) {
            window.clearTimeout(autoLayoutTimer.current);
        }
        autoLayoutTimer.current = window.setTimeout(() => { layout('elk'); }, 250);
    }

    function openFiles(paths: string[]) {
        setNodes(prev => {
            const ids = new Set(prev.map(p => p.id));
            const add: Node[] = graph.nodes.filter((n: any) => paths.includes(n.path) && !ids.has(n.id)).map((n: any, i: number) => ({
                id: n.id, type: 'file', position: { x: 50 + i * 30, y: 60 + i * 30 }, style: { width: 480, height: 280 },
                data: { label: n.label, preview: <div className="preview">{n.path}</div>, path: n.path, lang: n.lang }
            }));
            return [...prev, ...add];
        });
        if (paths && paths.length) {
            vscode?.postMessage({ type: 'requestCodeMany', paths });
        }
    }

    async function layout(algo: 'custom' | 'dagre' | 'elk' | 'force') {
        lastAlgo.current = algo;
        if (algo === 'dagre') setNodes(await dagreLayout(nodes as any, edges as any) as any);
        else if (algo === 'elk') setNodes(await elkLayout(nodes as any, edges as any) as any);
        else if (algo === 'force') {
            // Simple force: jitter spread
            setNodes(nodes.map((n, i) => ({ ...n, position: { x: i * 120 % 1200, y: (i * 220) % 800 } })));
        }
        // fit after layout to avoid overlaps staying in view
        setTimeout(() => {
            try { (document.querySelector('.react-flow__controls-zoomout') as HTMLButtonElement)?.click(); } catch { }
        }, 0);
    }

    function onOpenFile(n: Node) { vscode?.postMessage({ type: 'openFile', path: n.data.path }); }

    function onTokenClick({ path, line, character, token }: any) {
        if (!showRefs) return;
        vscode?.postMessage({ type: 'requestRefs', path, line, character, token });
        vscode?.postMessage({ type: 'requestDefOpen', path, line, character });
        // Focus connected nodes to the clicked file
        const base = nodes.find(n => n.data.path === path);
        if (base) focusNodesForId(base.id);
    }

    function expandSelection() {
        const ids = selectedIds.length ? selectedIds : (nodes as any).filter((n: any) => n.selected).map((n: any) => n.id);
        if (ids.length) vscode?.postMessage({ type: 'expand', ids });
    }

    function focusNodesForId(baseId: string) {
        const neighborIds = new Set<string>([baseId]);
        for (const e of edges as any[]) {
            if (e.source === baseId) neighborIds.add(e.target);
            if (e.target === baseId) neighborIds.add(e.source);
        }
        // Build vertical positions for focus lane
        const order: string[] = [baseId, ...Array.from(neighborIds).filter(id => id !== baseId).sort()];
        let currentY = 60;
        const x = 40;
        const spacing = 20;
        const nextPos = new Map<string, { x: number; y: number }>();
        for (const id of order) {
            const n = nodes.find(n => n.id === id);
            const h = (n?.style?.height ?? measuredSizeRef.current[id]?.height ?? 280);
            nextPos.set(id, { x, y: currentY });
            currentY += h + spacing;
        }
        setFocusIds(new Set(neighborIds));
        setNodes(prev => prev.map(n => {
            const inFocus = neighborIds.has(n.id);
            const pos = nextPos.get(n.id);
            if (inFocus && pos) {
                return { ...n, position: pos, data: { ...n.data, dim: false } } as any;
            }
            return { ...n, data: { ...n.data, dim: true } } as any;
        }));
    }

    function clearFocus() {
        setFocusIds(null);
        setNodes(prev => prev.map(n => ({ ...n, data: { ...n.data, dim: false } } as any)));
    }

    useEffect(() => {
        const onKey = (e: KeyboardEvent) => { if ((e.key === 'e' || e.key === 'E')) expandSelection(); };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
    }, [nodes]);

    // render code previews lazily inside each node

    const nodeTypesLocal = useMemo(() => ({
        file: (p: any) => {
            const n = p.data;
            const content = codeCacheRef.current[n.path] ?? n.path;
            const handleLines: number[] = (() => {
                const s = new Set<number>();
                for (const e of edges as any[]) {
                    if (e.source === p.id && e.data?.sourceLine != null) s.add(e.data.sourceLine);
                    if (e.target === p.id && e.data?.targetLine != null) s.add(e.data.targetLine);
                }
                return Array.from(s).sort((a, b) => a - b).slice(0, 200);
            })();
            return (
                <div className="file-node" style={{ opacity: n.dim ? 0.25 : 1 }}>
                    <div className="file-node-header" onDoubleClick={() => onOpenFile(p)}>{n.label}</div>
                    <CodeCard
                        key={n.path}
                        file={n.path}
                        lang={n.lang}
                        content={content}
                        onTokenClick={onTokenClick}
                        wrap={wrap}
                        highlightLine={highlightRef.current[p.id]}
                        scrollToLine={scrollRef.current[p.id]}
                        onLinePositions={(positions) => { linePosRef.current[p.id] = positions; }}
                        onMeasured={({ width, height }) => {
                            const last = measuredSizeRef.current[p.id];
                            if (last && last.width === width && last.height === height) return;
                            measuredSizeRef.current[p.id] = { width, height };
                            enqueueSizeUpdate(p.id, { width, height });
                        }}
                    />
                    {/* default center handles */}
                    <Handle type="source" position={Position.Right} id={`line-0`} />
                    <Handle type="target" position={Position.Left} id={`line-0`} />
                    {/* per-line handles anchored by top offset */}
                    {handleLines.map((ln) => {
                        const top = (linePosRef.current[p.id]?.find(x => x.line === ln)?.top) ?? (headerHeight + prePaddingTop + ln * lineHeight);
                        return (
                            <React.Fragment key={ln}>
                                <Handle
                                    type="source"
                                    position={Position.Right}
                                    id={`line-${ln}`}
                                    style={{ top }}
                                />
                                <Handle
                                    type="target"
                                    position={Position.Left}
                                    id={`line-${ln}`}
                                    style={{ top }}
                                />
                            </React.Fragment>
                        );
                    })}
                </div>
            );
        }
    }), [edges]);

    return (
        <div className="root">
            <div className="toolbar">
                <button onClick={() => layout('custom')}>Custom (⇧1)</button>
                <button onClick={() => layout('dagre')}>Dagre (⇧2)</button>
                <button onClick={() => layout('elk')}>ELK (⇧3)</button>
                <button onClick={() => layout('force')}>Force (⇧4)</button>
                <button onClick={() => vscode?.postMessage({ type: 'loadMore' })}>Load 25 more</button>
                <button onClick={() => vscode?.postMessage({ type: 'requestChanged' })}>Open Changed (⇧O)</button>
                <button onClick={() => vscode?.postMessage({ type: 'requestGraph' })}>Reload</button>
                <button onClick={expandSelection}>Expand (E)</button>
                <button onClick={() => vscode?.postMessage({ type: 'toggleRefs' })}>Refs (R)</button>
                <button onClick={() => setWrap(w => !w)}>{wrap ? 'Unwrap' : 'Wrap'}</button>
                <button onClick={() => setShowEdges(s => !s)}>{showEdges ? 'Hide Edges' : 'Show Edges'}</button>
                <button onClick={() => vscode?.postMessage({ type: 'toggleEdges' })}>Toggle Edges (Global)</button>
                <button onClick={() => vscode?.postMessage({ type: 'seedFolder' })}>Seed Folder…</button>
                {focusIds ? (<button onClick={clearFocus}>Clear Focus</button>) : null}
            </div>
            <ReactFlow
                nodes={nodes as any}
                edges={showEdges ? (focusIds ? (edges as any[]).filter(e => focusIds.has(e.source) && focusIds.has(e.target)) : edges) : []}
                nodeTypes={nodeTypesLocal as any}
                fitView
                onNodeClick={(_e, node: any) => focusNodesForId(node.id)}
                onEdgeClick={(_e, edge: any) => {
                    const sl = (edge?.data?.sourceLine ?? 0);
                    const tl = (edge?.data?.targetLine ?? 0);
                    if (edge?.source) {
                        highlightRef.current[edge.source] = sl;
                        scrollRef.current[edge.source] = sl;
                    }
                    if (edge?.target) {
                        highlightRef.current[edge.target] = tl;
                        scrollRef.current[edge.target] = tl;
                    }
                    // Force a refresh to pass updated props
                    setNodes(n => [...n]);
                    // Also focus on the edge's source node to reorganize
                    if (edge?.source) focusNodesForId(edge.source);
                }}
                onSelectionChange={(p: any) => setSelectedIds((p?.nodes || []).map((n: any) => n.id))}
                minZoom={0.02}
                maxZoom={8}
            >
                <Background />
                <MiniMap pannable zoomable />
                <Controls />
            </ReactFlow>
            {progress && <div style={{ position: 'absolute', inset: 0, display: 'grid', placeItems: 'center', pointerEvents: 'none', fontSize: 14, opacity: .8 }}>⚙ {progress}</div>}
            {emptyMsg && <div style={{ position: 'absolute', inset: 0, display: 'grid', placeItems: 'center', fontSize: 14, opacity: .8 }}>{emptyMsg}</div>}
        </div>
    );
}
```

## webview/src/code/CodeCard.tsx

```text
﻿import React, { useLayoutEffect, useMemo, useRef } from 'react';
import { highlight } from './highlight';

function wrapHighlightedHtmlPreserveLines(highlightedHtml: string): string {
    const container = document.createElement('div');
    container.innerHTML = highlightedHtml;

    const lines: string[] = [];
    let current = '';
    const stack: Element[] = [];

    const escapeHtml = (s: string) => s
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

    const escapeAttr = (s: string) => s
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;');

    const startTag = (el: Element) => {
        const tag = el.tagName.toLowerCase();
        let attrs = '';
        for (const attr of Array.from(el.attributes)) {
            attrs += ` ${attr.name}="${escapeAttr(attr.value)}"`;
        }
        return `<${tag}${attrs}>`;
    };
    const endTag = (el: Element) => `</${el.tagName.toLowerCase()}>`;
    const openAll = () => stack.map(startTag).join('');
    const closeAll = () => stack.slice().reverse().map(endTag).join('');

    const flushLine = () => { lines.push(current); current = ''; };

    const handleText = (text: string) => {
        const parts = text.split(/\r\n|\n/);
        for (let i = 0; i < parts.length; i++) {
            current += escapeHtml(parts[i]);
            if (i < parts.length - 1) {
                current += closeAll();
                flushLine();
                current += openAll();
            }
        }
    };

    const walk = (node: Node) => {
        if (node.nodeType === Node.TEXT_NODE) {
            handleText((node as Text).data);
            return;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
            const el = node as Element;
            current += startTag(el);
            stack.push(el);
            for (const child of Array.from(el.childNodes)) walk(child);
            stack.pop();
            current += endTag(el);
            return;
        }
        // Ignore other node types
    };

    for (const child of Array.from(container.childNodes)) walk(child);
    // Ensure at least one line
    if (current !== '' || lines.length === 0) flushLine();

    return lines
        .map((line, i) => `<span class="code-line" data-line="${i}">${line === '' ? '&nbsp;' : line}</span>`)
        .join('');
}

export default function CodeCard({ file, lang, content, onTokenClick, onMeasured, wrap, onLinePositions, highlightLine, scrollToLine }: {
    file: string; lang: 'ts' | 'js' | 'py' | 'other'; content: string; onTokenClick: (payload: { path: string; line: number; character: number; token: string }) => void; onMeasured?: (size: { width: number; height: number }) => void; wrap?: boolean;
    onLinePositions?: (positions: { line: number; top: number }[]) => void; highlightLine?: number; scrollToLine?: number;
}) {
    const rawHtml = useMemo(() => highlight(content, lang), [content, lang]);
    const html = useMemo(() => wrapHighlightedHtmlPreserveLines(rawHtml), [rawHtml]);
    const preRef = useRef<HTMLPreElement | null>(null);
    const containerRef = useRef<HTMLDivElement | null>(null);

    useLayoutEffect(() => {
        const el = preRef.current;
        if (!el) return;
        const notify = () => onMeasured?.({ width: el.scrollWidth, height: el.scrollHeight });
        notify();
        const ro = new ResizeObserver(() => {
            notify();
            computeLinePositions();
        });
        ro.observe(el);
        const cont = containerRef.current;
        const onScroll = () => computeLinePositions();
        cont?.addEventListener('scroll', onScroll, { passive: true } as any);
        return () => { ro.disconnect(); cont?.removeEventListener('scroll', onScroll as any); };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [html, onMeasured]);

    function computeLinePositions() {
        try {
            const pre = preRef.current;
            const container = containerRef.current;
            const root = container?.closest('.file-node') as HTMLElement | null;
            if (!pre || !container || !root) return;
            const rootRect = root.getBoundingClientRect();
            const spans = Array.from(pre.querySelectorAll('span.code-line')) as HTMLElement[];
            const positions = spans.map((sp, idx) => {
                const spRect = sp.getBoundingClientRect();
                const top = (spRect.top - rootRect.top) + spRect.height / 2;
                return { line: idx, top };
            });
            onLinePositions?.(positions);
        } catch { }
    }

    useLayoutEffect(() => { computeLinePositions(); }, [html]);

    useLayoutEffect(() => {
        if (highlightLine == null) return;
        const pre = preRef.current;
        const container = containerRef.current;
        if (!pre || !container) return;
        const all = pre.querySelectorAll('.code-line.highlight');
        all.forEach(n => n.classList.remove('highlight'));
        const target = pre.querySelector(`.code-line[data-line="${highlightLine}"]`) as HTMLElement | null;
        if (target) {
            target.classList.add('highlight');
        }
    }, [highlightLine]);

    useLayoutEffect(() => {
        if (scrollToLine == null) return;
        const pre = preRef.current;
        const container = containerRef.current;
        if (!pre || !container) return;
        const target = pre.querySelector(`.code-line[data-line="${scrollToLine}"]`) as HTMLElement | null;
        if (target) {
            target.scrollIntoView({ block: 'center' });
        }
    }, [scrollToLine]);

    const onClick: React.MouseEventHandler<HTMLPreElement> = () => {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0 || sel.toString().length === 0) return;
        const token = sel.toString();
        const range = sel.getRangeAt(0);
        const startNode = range.startContainer;
        const startEl: Element | null = startNode.nodeType === Node.ELEMENT_NODE ? (startNode as Element) : (startNode.parentElement);
        if (!startEl) return;
        const lineEl = startEl.closest('.code-line') as HTMLElement | null;
        if (!lineEl) return;
        const lineAttr = lineEl.getAttribute('data-line');
        const line = lineAttr ? parseInt(lineAttr, 10) : 0;
        const headRange = document.createRange();
        headRange.selectNodeContents(lineEl);
        headRange.setEnd(range.startContainer, range.startOffset);
        const character = headRange.toString().length;
        onTokenClick({ path: file, line, character, token });
    };

    return (
        <div className="code-card" ref={containerRef}>
            <div className="file-title">{file}</div>
            <pre ref={preRef} id={`code-${file}`} className={`hljs${wrap ? ' wrap' : ''}`} onMouseUp={onClick} dangerouslySetInnerHTML={{ __html: html }} />
        </div>
    );
}
```

## webview/src/code/highlight.ts

```typescript
﻿import hljs from 'highlight.js/lib/core';
import ts from 'highlight.js/lib/languages/typescript';
import js from 'highlight.js/lib/languages/javascript';
import py from 'highlight.js/lib/languages/python';
import plaintext from 'highlight.js/lib/languages/plaintext';

hljs.registerLanguage('typescript', ts);
hljs.registerLanguage('javascript', js);
// Increase the maximum length before Highlight.js bails out to plaintext so large Python files still get properly highlighted.
hljs.configure({ maxHighlightLength: 500_000 } as any);
hljs.registerLanguage('python', py);
hljs.registerLanguage('plaintext', plaintext);

// A mapping object is slightly cleaner than a long ternary chain.
const languageMap = {
    ts: 'typescript',
    js: 'javascript',
    py: 'python',
    other: 'plaintext'
};

export function highlight(code: string, lang: 'ts' | 'js' | 'py' | 'other') {
    const mapped = languageMap[lang] || 'plaintext';

    // 1. First, check if the language is explicitly supported.
    if (hljs.getLanguage(mapped)) {
        try {
            // 2. Attempt to highlight with the specified language.
            return hljs.highlight(code, { language: mapped, ignoreIllegals: true }).value;
        } catch (e) {
            // This catch block will run if highlighting fails catastrophically.
            console.error(`Highlighting failed for language "${mapped}"`, e);
        }
    }

    // 3. If specific highlighting fails, fallback to auto-detection.
    // This is safer than the original implementation's catch-all.
    try {
        return hljs.highlightAuto(code).value;
    } catch (e) {
        console.error('Auto-highlighting failed', e);
        // 4. As a last resort, return the code escaped to prevent breaking HTML.
        return code.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
}
```

## webview/src/layout.ts

```typescript
﻿import dagre from 'dagre';
import ELK from 'elkjs/lib/elk.bundled.js';

export function dagreLayout(nodes: any[], edges: any[], direction: 'LR' | 'TB' = 'LR') {
    const g = new dagre.graphlib.Graph();
    g.setGraph({ rankdir: direction });
    g.setDefaultEdgeLabel(() => ({}));
    nodes.forEach(n => g.setNode(n.id, { width: n.style?.width || 300, height: n.style?.height || 120 }));
    edges.forEach(e => g.setEdge(e.source, e.target));
    dagre.layout(g);
    return nodes.map(n => { const p = g.node(n.id); return { ...n, position: { x: p.x, y: p.y } }; });
}

const elk = new ELK();
export async function elkLayout(nodes: any[], edges: any[]) {
    const graph = {
        id: 'root',
        layoutOptions: { 'elk.algorithm': 'layered', 'elk.direction': 'RIGHT' },
        children: nodes.map(n => ({ id: n.id, width: n.style?.width || 300, height: n.style?.height || 120 })),
        edges: edges.map(e => ({ id: e.id, sources: [e.source], targets: [e.target] }))
    } as any;
    const res = await elk.layout(graph);
    const pos: Record<string, { x: number; y: number }> = {};
    res.children?.forEach((c: any) => { pos[c.id] = { x: c.x, y: c.y }; });
    return nodes.map(n => ({ ...n, position: pos[n.id] || n.position }));
}
```

## webview/src/main.tsx

```text
﻿import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import './styles.css';
import 'highlight.js/styles/github-dark.css';

createRoot(document.getElementById('root')!).render(<App />);
```

## webview/src/reactflow-node-types.tsx

```text
﻿import React from 'react';
import { Handle, Position } from 'reactflow';

export function FileNode({ data }: any) {
    return (
        <div className="file-node">
            <div className="file-node-header">{data.label}</div>
            <div className="file-node-body">{data.preview}</div>
            <Handle type="source" position={Position.Right} />
            <Handle type="target" position={Position.Left} />
        </div>
    );
}

export const nodeTypes = { file: FileNode } as const;
```

## webview/src/styles.css

```css
﻿:root {
    color-scheme: dark;
}

body,
html,
#root {
    margin: 0;
    height: 100%;
    background: #0b0e12;
    color: #cdd6f4;
    font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Inter, sans-serif;
}

.root {
    height: 100%;
}

.toolbar {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    display: flex;
    gap: 6px;
}

.toolbar button {
    background: #111827;
    border: 1px solid #1f2937;
    color: #e5e7eb;
    padding: 6px 10px;
    border-radius: 8px;
    cursor: pointer;
}

.file-node {
    width: 100%;
    height: 100%;
    background: #0d1117;
    border: 1px solid #1f2937;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 0 0 1px #0b1220 inset;
}

.file-node-header {
    background: #0b1220;
    padding: 6px 10px;
    font-weight: 600;
    font-size: 12px;
    letter-spacing: .3px;
    border-bottom: 1px solid #1f2937;
    cursor: default;
}

.code-card {
    height: calc(100% - 30px);
    overflow: auto;
}

.code-card .file-title {
    display: none;
}

pre.hljs {
    margin: 0;
    padding: 8px 10px 8px 56px;
    /* leave space for gutter */
    font-size: 12px;
    line-height: 1.35;
    position: relative;
    counter-reset: line;
}

pre.hljs .code-line {
    display: block;
    counter-increment: line;
    position: relative;
}

pre.hljs .code-line::before {
    content: counter(line);
    position: absolute;
    left: -44px;
    width: 36px;
    text-align: right;
    color: #6b7280;
    opacity: 0.9;
}

pre.hljs .code-line.highlight {
    background: rgba(255, 214, 10, 0.15);
    outline: 1px solid rgba(255, 214, 10, 0.35);
}

pre.hljs.wrap {
    white-space: pre-wrap;
}

.preview {
    font-size: 11px;
    opacity: .8;
    padding: 8px;
}

/* Improve MiniMap visibility */
.react-flow__minimap {
    background: #0f1115 !important;
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.06) inset;
}

.react-flow__minimap-mask {
    fill: rgba(255, 255, 255, 0.06) !important;
}

.react-flow__minimap-node {
    fill: #4f46e5 !important;
    stroke: rgba(255, 255, 255, 0.2) !important;
}

/* Allow extreme zooming */
.react-flow__renderer,
.react-flow__viewport {
    will-change: transform;
}
```

## webview/tsconfig.json

```json
﻿{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "allowJs": false,
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "useDefineForClassFields": true
  },
  "include": ["src"]
}
```

## webview/vite.config.ts

```typescript
﻿import { defineConfig } from 'vite';
import path from 'path';

export default defineConfig({
    base: '',
    build: {
        sourcemap: 'inline',
        outDir: path.resolve(__dirname, '../extension/media'),
        emptyOutDir: true,
        rollupOptions: {
            input: path.resolve(__dirname, 'index.html')
        }
    }
});
```

## Statistics

- Total Files: 25
- Total Characters: 10253787
- Total Tokens: 0
``````

## webview/index.html

```html
﻿<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; img-src vscode-resource: https: data:; style-src 'unsafe-inline' __CSP__; script-src __CSP__; font-src __CSP__; connect-src __CSP__;" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Code Canvas</title>
</head>

<body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
</body>

</html>
```

## webview/package.json

```json
{
    "name": "code-canvas-webview",
    "private": true,
    "version": "0.0.1",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "vite build"
    },
    "dependencies": {
        "dagre": "^0.8.5",
        "elkjs": "^0.10.0",
        "highlight.js": "^11.9.0",
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "reactflow": "^11.11.4"
    },
    "devDependencies": {
        "@types/react": "^18.3.3",
        "@types/react-dom": "^18.3.0",
        "typescript": "^5.6",
        "vite": "^7.1.2"
    }
}
```

## webview/src/App.tsx

```text
﻿import React, { useEffect, useMemo, useRef, useState } from 'react';
import ReactFlow, { Background, Controls, MiniMap, Handle, Position } from 'reactflow';
import 'reactflow/dist/style.css';
import { nodeTypes } from './reactflow-node-types';
import CodeCard from './code/CodeCard';
import { dagreLayout, elkLayout } from './layout';

// VS Code webview API
declare global { interface Window { acquireVsCodeApi: any; __CODE_CACHE?: Record<string, string> } }
const vscode = window.acquireVsCodeApi?.();

type Node = { id: string; type: 'file'; position: { x: number; y: number }; data: any; style?: any };

export default function App() {
    const [graph, setGraph] = useState<{ nodes: any[]; edges: any[] }>({ nodes: [], edges: [] });
    const [nodes, setNodes] = useState<Node[]>([]);
    const [edges, setEdges] = useState<any[]>([]);
    const [rawEdges, setRawEdges] = useState<any[]>([]);
    const [selectedIds, setSelectedIds] = useState<string[]>([]);
    const [emptyMsg, setEmptyMsg] = useState<string | undefined>(undefined);
    const [progress, setProgress] = useState<string | undefined>(undefined);
    const lastAlgo = useRef<'custom' | 'dagre' | 'elk' | 'force'>('elk');
    const [showRefs, setShowRefs] = useState(true);
    const [wrap, setWrap] = useState(false);
    const [showEdges, setShowEdges] = useState(true);
    const [focusIds, setFocusIds] = useState<Set<string> | null>(null);
    const codeCacheRef = useRef<Record<string, string>>({});
    const measuredSizeRef = useRef<Record<string, { width: number; height: number }>>({});
    const pendingMeasureRef = useRef<Record<string, { width: number; height: number }>>({});
    const rafCommitRef = useRef<number | null>(null);
    const headerHeight = 30; // matches CSS: .code-card { height: calc(100% - 30px); }
    const prePaddingTop = 8; // matches CSS: pre.hljs { padding: 8px 10px; }
    const lineHeight = 16; // approx from font-size 12px and line-height 1.35
    const linePosRef = useRef<Record<string, { line: number; top: number }[]>>({});
    const highlightRef = useRef<Record<string, number | undefined>>({});
    const scrollRef = useRef<Record<string, number | undefined>>({});

    function enqueueSizeUpdate(nodeId: string, size: { width: number; height: number }) {
        pendingMeasureRef.current[nodeId] = size;
        if (rafCommitRef.current == null) {
            rafCommitRef.current = window.requestAnimationFrame(() => {
                const updates = pendingMeasureRef.current;
                pendingMeasureRef.current = {};
                rafCommitRef.current = null;
                setNodes(prev => prev.map((x: any) => updates[x.id] ? { ...x, style: updates[x.id] } : x));
            });
        }
    }

    function computeStyleFromContent(content: string) {
        // fallback rough estimate before exact measure arrives
        const text = content || '';
        const lines = text.split('\n');
        const maxLen = lines.reduce((m, l) => Math.max(m, l.length), 0);
        const rawWidth = Math.max(480, Math.floor(maxLen * 7 + 40));
        const rawHeight = Math.max(200, lines.length * 14 + 30);
        // clamp to avoid enormous nodes that can destabilize layout/rendering
        const width = Math.min(rawWidth, 1400);
        const height = Math.min(rawHeight, 900);
        return { width, height } as const;
    }

    useEffect(() => {
        vscode?.postMessage({ type: 'requestGraph' });
        vscode?.postMessage({ type: 'requestChanged' });
        const listener = (e: MessageEvent) => {
            const msg = e.data;
            if (msg.type === 'empty') setEmptyMsg(msg.reason === 'no-workspace'
                ? 'Open a folder to analyze your code.' : 'No JS/TS/Python files found.');
            else if (msg.type === 'progress') setProgress(msg.msg || undefined);
            else if (msg.type === 'graph') {
                setEmptyMsg(undefined); setProgress(undefined); setGraph(msg.graph);
                const paths = (msg.graph?.nodes || []).map((n: any) => n.path);
                if (paths.length) vscode?.postMessage({ type: 'requestCodeMany', paths });
                setRawEdges(msg.graph?.edges || []);
            }
            else if (msg.type === 'expandResult') mergeGraph(msg.graph);
            else if (msg.type === 'changedFiles') {
                openFiles(msg.files);
            } else if (msg.type === 'openChanged') {
                openFiles(msg.files);
            } else if (msg.type === 'layout') {
                layout(msg.algo);
            } else if (msg.type === 'toggleRefs') {
                setShowRefs(s => !s);
            } else if (msg.type === 'toggleEdges') {
                setShowEdges(s => !s);
            } else if (msg.type === 'code') {
                codeCacheRef.current[msg.path] = msg.content || '';
                setNodes(prev => prev.map(n => n.data.path === msg.path ? { ...n, style: computeStyleFromContent(codeCacheRef.current[msg.path]) } : n));
            } else if (msg.type === 'codeMany') {
                const updated = new Set<string>();
                for (const { path, content } of (msg.entries || [])) {
                    codeCacheRef.current[path] = content || '';
                    updated.add(path);
                }
                if (updated.size) setNodes(prev => prev.map(n => updated.has(n.data.path) ? { ...n, style: computeStyleFromContent(codeCacheRef.current[n.data.path]) } : n));
            } else if (msg.type === 'seedFolder') {
                // The extension relays the path; filter current index graph by prefix and request code for those
                const folder: string = msg.folder;
                const selected = (graph.nodes || []).filter((n: any) => (n.path || '').startsWith(folder));
                setNodes(prev => selected.map((n: any, i: number) => ({
                    id: n.id, type: 'file', position: { x: (i % 3) * 1200, y: Math.floor(i / 3) * 1000 },
                    style: computeStyleFromContent(codeCacheRef.current[n.path] || ''), data: { label: n.label, preview: (<div className="preview">{n.path}</div>), path: n.path, lang: n.lang }
                })));
                const paths = selected.map((n: any) => n.path);
                if (paths.length) vscode?.postMessage({ type: 'requestCodeMany', paths });
            }
        };
        window.addEventListener('message', listener);
        return () => window.removeEventListener('message', listener);
    }, []);

    useEffect(() => { // build ReactFlow nodes
        const initial: Node[] = graph.nodes.map((n: any, i: number) => ({
            id: n.id,
            type: 'file',
            position: { x: (i % 3) * 1200, y: Math.floor(i / 3) * 1000 },
            style: computeStyleFromContent(codeCacheRef.current[n.path] || ''),
            data: { label: n.label, preview: (<div className="preview">{n.path}</div>), path: n.path, lang: n.lang }
        }));
        const e = (graph.edges || []).map((e: any) => ({
            id: e.id,
            source: e.source,
            target: e.target,
            data: { sourceLine: e.sourceLine, targetLine: e.targetLine },
            sourceHandle: (e.sourceLine ?? null) !== null && (e.sourceLine ?? undefined) !== undefined ? `line-${e.sourceLine}` : undefined,
            targetHandle: (e.targetLine ?? null) !== null && (e.targetLine ?? undefined) !== undefined ? `line-${e.targetLine}` : undefined
        }));
        setNodes(initial); setEdges(e);
    }, [graph]);

    function mergeGraph(g: any) {
        const newPaths: string[] = [];
        setNodes(prev => {
            const map = new Map(prev.map(n => [n.id, n]));
            for (const n of g.nodes) if (!map.has(n.id)) {
                newPaths.push(n.path);
                map.set(n.id, {
                    id: n.id, type: 'file',
                    position: { x: Math.random() * 800, y: Math.random() * 600 },
                    style: computeStyleFromContent(codeCacheRef.current[n.path] || ''),
                    data: { label: n.label, preview: <div className="preview">{n.path}</div>, path: n.path, lang: n.lang }
                } as any);
            }
            return Array.from(map.values());
        });
        setEdges(prev => {
            const ids = new Set(prev.map(e => e.id));
            const add = g.edges.filter((e: any) => !ids.has(e.id));
            return [...prev, ...add];
        });
        if (newPaths.length) vscode?.postMessage({ type: 'requestCodeMany', paths: newPaths });
        // optional: auto-layout after expand with debounce
        scheduleAutoLayout();
    }

    // Debounced auto-layout to avoid thrashing
    const autoLayoutTimer = useRef<number | null>(null);
    function scheduleAutoLayout() {
        if (autoLayoutTimer.current) {
            window.clearTimeout(autoLayoutTimer.current);
        }
        autoLayoutTimer.current = window.setTimeout(() => { layout('elk'); }, 250);
    }

    function openFiles(paths: string[]) {
        setNodes(prev => {
            const ids = new Set(prev.map(p => p.id));
            const add: Node[] = graph.nodes.filter((n: any) => paths.includes(n.path) && !ids.has(n.id)).map((n: any, i: number) => ({
                id: n.id, type: 'file', position: { x: 50 + i * 30, y: 60 + i * 30 }, style: { width: 480, height: 280 },
                data: { label: n.label, preview: <div className="preview">{n.path}</div>, path: n.path, lang: n.lang }
            }));
            return [...prev, ...add];
        });
        if (paths && paths.length) {
            vscode?.postMessage({ type: 'requestCodeMany', paths });
        }
    }

    async function layout(algo: 'custom' | 'dagre' | 'elk' | 'force') {
        lastAlgo.current = algo;
        if (algo === 'dagre') setNodes(await dagreLayout(nodes as any, edges as any) as any);
        else if (algo === 'elk') setNodes(await elkLayout(nodes as any, edges as any) as any);
        else if (algo === 'force') {
            // Simple force: jitter spread
            setNodes(nodes.map((n, i) => ({ ...n, position: { x: i * 120 % 1200, y: (i * 220) % 800 } })));
        }
        // fit after layout to avoid overlaps staying in view
        setTimeout(() => {
            try { (document.querySelector('.react-flow__controls-zoomout') as HTMLButtonElement)?.click(); } catch { }
        }, 0);
    }

    function onOpenFile(n: Node) { vscode?.postMessage({ type: 'openFile', path: n.data.path }); }

    function onTokenClick({ path, line, character, token }: any) {
        if (!showRefs) return;
        vscode?.postMessage({ type: 'requestRefs', path, line, character, token });
        vscode?.postMessage({ type: 'requestDefOpen', path, line, character });
        // Focus connected nodes to the clicked file
        const base = nodes.find(n => n.data.path === path);
        if (base) focusNodesForId(base.id);
    }

    function expandSelection() {
        const ids = selectedIds.length ? selectedIds : (nodes as any).filter((n: any) => n.selected).map((n: any) => n.id);
        if (ids.length) vscode?.postMessage({ type: 'expand', ids });
    }

    function focusNodesForId(baseId: string) {
        const neighborIds = new Set<string>([baseId]);
        for (const e of edges as any[]) {
            if (e.source === baseId) neighborIds.add(e.target);
            if (e.target === baseId) neighborIds.add(e.source);
        }
        // Build vertical positions for focus lane
        const order: string[] = [baseId, ...Array.from(neighborIds).filter(id => id !== baseId).sort()];
        let currentY = 60;
        const x = 40;
        const spacing = 20;
        const nextPos = new Map<string, { x: number; y: number }>();
        for (const id of order) {
            const n = nodes.find(n => n.id === id);
            const h = (n?.style?.height ?? measuredSizeRef.current[id]?.height ?? 280);
            nextPos.set(id, { x, y: currentY });
            currentY += h + spacing;
        }
        setFocusIds(new Set(neighborIds));
        setNodes(prev => prev.map(n => {
            const inFocus = neighborIds.has(n.id);
            const pos = nextPos.get(n.id);
            if (inFocus && pos) {
                return { ...n, position: pos, data: { ...n.data, dim: false } } as any;
            }
            return { ...n, data: { ...n.data, dim: true } } as any;
        }));
    }

    function clearFocus() {
        setFocusIds(null);
        setNodes(prev => prev.map(n => ({ ...n, data: { ...n.data, dim: false } } as any)));
    }

    useEffect(() => {
        const onKey = (e: KeyboardEvent) => { if ((e.key === 'e' || e.key === 'E')) expandSelection(); };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
    }, [nodes]);

    // render code previews lazily inside each node

    const nodeTypesLocal = useMemo(() => ({
        file: (p: any) => {
            const n = p.data;
            const content = codeCacheRef.current[n.path] ?? n.path;
            const handleLines: number[] = (() => {
                const s = new Set<number>();
                for (const e of edges as any[]) {
                    if (e.source === p.id && e.data?.sourceLine != null) s.add(e.data.sourceLine);
                    if (e.target === p.id && e.data?.targetLine != null) s.add(e.data.targetLine);
                }
                return Array.from(s).sort((a, b) => a - b).slice(0, 200);
            })();
            return (
                <div className="file-node" style={{ opacity: n.dim ? 0.25 : 1 }}>
                    <div className="file-node-header" onDoubleClick={() => onOpenFile(p)}>{n.label}</div>
                    <CodeCard
                        key={n.path}
                        file={n.path}
                        lang={n.lang}
                        content={content}
                        onTokenClick={onTokenClick}
                        wrap={wrap}
                        highlightLine={highlightRef.current[p.id]}
                        scrollToLine={scrollRef.current[p.id]}
                        onLinePositions={(positions) => { linePosRef.current[p.id] = positions; }}
                        onMeasured={({ width, height }) => {
                            const last = measuredSizeRef.current[p.id];
                            if (last && last.width === width && last.height === height) return;
                            measuredSizeRef.current[p.id] = { width, height };
                            enqueueSizeUpdate(p.id, { width, height });
                        }}
                    />
                    {/* default center handles */}
                    <Handle type="source" position={Position.Right} id={`line-0`} />
                    <Handle type="target" position={Position.Left} id={`line-0`} />
                    {/* per-line handles anchored by top offset */}
                    {handleLines.map((ln) => {
                        const top = (linePosRef.current[p.id]?.find(x => x.line === ln)?.top) ?? (headerHeight + prePaddingTop + ln * lineHeight);
                        return (
                            <React.Fragment key={ln}>
                                <Handle
                                    type="source"
                                    position={Position.Right}
                                    id={`line-${ln}`}
                                    style={{ top }}
                                />
                                <Handle
                                    type="target"
                                    position={Position.Left}
                                    id={`line-${ln}`}
                                    style={{ top }}
                                />
                            </React.Fragment>
                        );
                    })}
                </div>
            );
        }
    }), [edges]);

    return (
        <div className="root">
            <div className="toolbar">
                <button onClick={() => layout('custom')}>Custom (⇧1)</button>
                <button onClick={() => layout('dagre')}>Dagre (⇧2)</button>
                <button onClick={() => layout('elk')}>ELK (⇧3)</button>
                <button onClick={() => layout('force')}>Force (⇧4)</button>
                <button onClick={() => vscode?.postMessage({ type: 'loadMore' })}>Load 25 more</button>
                <button onClick={() => vscode?.postMessage({ type: 'requestChanged' })}>Open Changed (⇧O)</button>
                <button onClick={() => vscode?.postMessage({ type: 'requestGraph' })}>Reload</button>
                <button onClick={expandSelection}>Expand (E)</button>
                <button onClick={() => vscode?.postMessage({ type: 'toggleRefs' })}>Refs (R)</button>
                <button onClick={() => setWrap(w => !w)}>{wrap ? 'Unwrap' : 'Wrap'}</button>
                <button onClick={() => setShowEdges(s => !s)}>{showEdges ? 'Hide Edges' : 'Show Edges'}</button>
                <button onClick={() => vscode?.postMessage({ type: 'toggleEdges' })}>Toggle Edges (Global)</button>
                <button onClick={() => vscode?.postMessage({ type: 'seedFolder' })}>Seed Folder…</button>
                {focusIds ? (<button onClick={clearFocus}>Clear Focus</button>) : null}
            </div>
            <ReactFlow
                nodes={nodes as any}
                edges={showEdges ? (focusIds ? (edges as any[]).filter(e => focusIds.has(e.source) && focusIds.has(e.target)) : edges) : []}
                nodeTypes={nodeTypesLocal as any}
                fitView
                onNodeClick={(_e, node: any) => focusNodesForId(node.id)}
                onEdgeClick={(_e, edge: any) => {
                    const sl = (edge?.data?.sourceLine ?? 0);
                    const linkT = (edge?.data?.links && edge.data.links.length > 0) ? edge.data.links[0]?.targetLine : undefined;
                    const tl = linkT != null ? linkT : (edge?.data?.targetLine ?? 0);
                    if (edge?.source) {
                        highlightRef.current[edge.source] = sl;
                        scrollRef.current[edge.source] = sl;
                    }
                    if (edge?.target) {
                        highlightRef.current[edge.target] = tl;
                        scrollRef.current[edge.target] = tl;
                    }
                    // Force a refresh to pass updated props
                    setNodes(n => [...n]);
                    // Also focus on the edge's source node to reorganize
                    if (edge?.source) focusNodesForId(edge.source);
                }}
                onSelectionChange={(p: any) => setSelectedIds((p?.nodes || []).map((n: any) => n.id))}
                minZoom={0.02}
                maxZoom={8}
            >
                <Background />
                <MiniMap pannable zoomable />
                <Controls />
            </ReactFlow>
            {progress && <div style={{ position: 'absolute', inset: 0, display: 'grid', placeItems: 'center', pointerEvents: 'none', fontSize: 14, opacity: .8 }}>⚙ {progress}</div>}
            {emptyMsg && <div style={{ position: 'absolute', inset: 0, display: 'grid', placeItems: 'center', fontSize: 14, opacity: .8 }}>{emptyMsg}</div>}
        </div>
    );
}
```

## webview/src/code/CodeCard.tsx

```text
﻿import React, { useLayoutEffect, useMemo, useRef } from 'react';
import { highlight } from './highlight';

function wrapHighlightedHtmlPreserveLines(highlightedHtml: string): string {
    const container = document.createElement('div');
    container.innerHTML = highlightedHtml;

    const lines: string[] = [];
    let current = '';
    const stack: Element[] = [];

    const escapeHtml = (s: string) => s
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

    const escapeAttr = (s: string) => s
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;');

    const startTag = (el: Element) => {
        const tag = el.tagName.toLowerCase();
        let attrs = '';
        for (const attr of Array.from(el.attributes)) {
            attrs += ` ${attr.name}="${escapeAttr(attr.value)}"`;
        }
        return `<${tag}${attrs}>`;
    };
    const endTag = (el: Element) => `</${el.tagName.toLowerCase()}>`;
    const openAll = () => stack.map(startTag).join('');
    const closeAll = () => stack.slice().reverse().map(endTag).join('');

    const flushLine = () => { lines.push(current); current = ''; };

    const handleText = (text: string) => {
        const parts = text.split(/\r\n|\n/);
        for (let i = 0; i < parts.length; i++) {
            current += escapeHtml(parts[i]);
            if (i < parts.length - 1) {
                current += closeAll();
                flushLine();
                current += openAll();
            }
        }
    };

    const walk = (node: Node) => {
        if (node.nodeType === Node.TEXT_NODE) {
            handleText((node as Text).data);
            return;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
            const el = node as Element;
            current += startTag(el);
            stack.push(el);
            for (const child of Array.from(el.childNodes)) walk(child);
            stack.pop();
            current += endTag(el);
            return;
        }
        // Ignore other node types
    };

    for (const child of Array.from(container.childNodes)) walk(child);
    // Ensure at least one line
    if (current !== '' || lines.length === 0) flushLine();

    return lines
        .map((line, i) => `<span class="code-line" data-line="${i}">${line === '' ? '&nbsp;' : line}</span>`)
        .join('');
}

export default function CodeCard({ file, lang, content, onTokenClick, onMeasured, wrap, onLinePositions, highlightLine, scrollToLine }: {
    file: string; lang: 'ts' | 'js' | 'py' | 'other'; content: string; onTokenClick: (payload: { path: string; line: number; character: number; token: string }) => void; onMeasured?: (size: { width: number; height: number }) => void; wrap?: boolean;
    onLinePositions?: (positions: { line: number; top: number }[]) => void; highlightLine?: number; scrollToLine?: number;
}) {
    const effectiveLang = useMemo<'ts' | 'js' | 'py' | 'other'>(() => {
        if (lang && lang !== 'other') return lang;
        const lower = (file || '').toLowerCase();
        if (lower.endsWith('.py')) return 'py';
        if (lower.endsWith('.ts') || lower.endsWith('.tsx')) return 'ts';
        if (lower.endsWith('.js') || lower.endsWith('.jsx') || lower.endsWith('.mjs') || lower.endsWith('.cjs')) return 'js';
        return 'other';
    }, [file, lang]);

    const rawHtml = useMemo(() => highlight(content, effectiveLang), [content, effectiveLang]);
    const html = useMemo(() => wrapHighlightedHtmlPreserveLines(rawHtml), [rawHtml]);
    const preRef = useRef<HTMLPreElement | null>(null);
    const containerRef = useRef<HTMLDivElement | null>(null);

    useLayoutEffect(() => {
        const el = preRef.current;
        if (!el) return;
        const notify = () => onMeasured?.({ width: el.scrollWidth, height: el.scrollHeight });
        notify();
        const ro = new ResizeObserver(() => {
            notify();
            computeLinePositions();
        });
        ro.observe(el);
        const cont = containerRef.current;
        const onScroll = () => computeLinePositions();
        cont?.addEventListener('scroll', onScroll, { passive: true } as any);
        return () => { ro.disconnect(); cont?.removeEventListener('scroll', onScroll as any); };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [html, onMeasured]);

    function computeLinePositions() {
        try {
            const pre = preRef.current;
            const container = containerRef.current;
            const root = container?.closest('.file-node') as HTMLElement | null;
            if (!pre || !container || !root) return;
            const rootRect = root.getBoundingClientRect();
            const spans = Array.from(pre.querySelectorAll('span.code-line')) as HTMLElement[];
            const positions = spans.map((sp, idx) => {
                const spRect = sp.getBoundingClientRect();
                const top = (spRect.top - rootRect.top) + spRect.height / 2;
                return { line: idx, top };
            });
            onLinePositions?.(positions);
        } catch { }
    }

    useLayoutEffect(() => { computeLinePositions(); }, [html]);

    useLayoutEffect(() => {
        if (highlightLine == null) return;
        const pre = preRef.current;
        const container = containerRef.current;
        if (!pre || !container) return;
        const all = pre.querySelectorAll('.code-line.highlight');
        all.forEach(n => n.classList.remove('highlight'));
        const target = pre.querySelector(`.code-line[data-line="${highlightLine}"]`) as HTMLElement | null;
        if (target) {
            target.classList.add('highlight');
        }
    }, [highlightLine]);

    useLayoutEffect(() => {
        if (scrollToLine == null) return;
        const pre = preRef.current;
        const container = containerRef.current;
        if (!pre || !container) return;
        const target = pre.querySelector(`.code-line[data-line="${scrollToLine}"]`) as HTMLElement | null;
        if (target) {
            target.scrollIntoView({ block: 'center' });
        }
    }, [scrollToLine]);

    const onClick: React.MouseEventHandler<HTMLPreElement> = () => {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0 || sel.toString().length === 0) return;
        const token = sel.toString();
        const range = sel.getRangeAt(0);
        const startNode = range.startContainer;
        const startEl: Element | null = startNode.nodeType === Node.ELEMENT_NODE ? (startNode as Element) : (startNode.parentElement);
        if (!startEl) return;
        const lineEl = startEl.closest('.code-line') as HTMLElement | null;
        if (!lineEl) return;
        const lineAttr = lineEl.getAttribute('data-line');
        const line = lineAttr ? parseInt(lineAttr, 10) : 0;
        const headRange = document.createRange();
        headRange.selectNodeContents(lineEl);
        headRange.setEnd(range.startContainer, range.startOffset);
        const character = headRange.toString().length;
        onTokenClick({ path: file, line, character, token });
    };

    return (
        <div className="code-card" ref={containerRef}>
            <div className="file-title">{file}</div>
            <pre ref={preRef} id={`code-${file}`} className={`hljs${wrap ? ' wrap' : ''}`} onMouseUp={onClick} dangerouslySetInnerHTML={{ __html: html }} />
        </div>
    );
}
```

## webview/src/code/highlight.ts

```typescript
﻿import hljs from 'highlight.js/lib/core';
import ts from 'highlight.js/lib/languages/typescript';
import js from 'highlight.js/lib/languages/javascript';
import py from 'highlight.js/lib/languages/python';
import plaintext from 'highlight.js/lib/languages/plaintext';

hljs.registerLanguage('typescript', ts);
hljs.registerLanguage('javascript', js);
// Increase the maximum length before Highlight.js bails out to plaintext so large Python files still get properly highlighted.
hljs.configure({ maxHighlightLength: 500_000 } as any);
hljs.registerLanguage('python', py);
hljs.registerLanguage('plaintext', plaintext);

// A mapping object is slightly cleaner than a long ternary chain.
const languageMap = {
    ts: 'typescript',
    js: 'javascript',
    py: 'python',
    other: 'plaintext'
};

export function highlight(code: string, lang: 'ts' | 'js' | 'py' | 'other') {
    const mapped = languageMap[lang] || 'plaintext';

    // 1. First, check if the language is explicitly supported.
    if (hljs.getLanguage(mapped)) {
        try {
            // 2. Attempt to highlight with the specified language.
            return hljs.highlight(code, { language: mapped, ignoreIllegals: true }).value;
        } catch (e) {
            // This catch block will run if highlighting fails catastrophically.
            console.error(`Highlighting failed for language "${mapped}"`, e);
        }
    }

    // 3. If specific highlighting fails, fallback to auto-detection.
    // This is safer than the original implementation's catch-all.
    try {
        return hljs.highlightAuto(code).value;
    } catch (e) {
        console.error('Auto-highlighting failed', e);
        // 4. As a last resort, return the code escaped to prevent breaking HTML.
        return code.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
}
```

## webview/src/layout.ts

```typescript
﻿import dagre from 'dagre';
import ELK from 'elkjs/lib/elk.bundled.js';

export function dagreLayout(nodes: any[], edges: any[], direction: 'LR' | 'TB' = 'LR') {
    const g = new dagre.graphlib.Graph();
    g.setGraph({ rankdir: direction });
    g.setDefaultEdgeLabel(() => ({}));
    nodes.forEach(n => g.setNode(n.id, { width: n.style?.width || 300, height: n.style?.height || 120 }));
    edges.forEach(e => g.setEdge(e.source, e.target));
    dagre.layout(g);
    return nodes.map(n => { const p = g.node(n.id); return { ...n, position: { x: p.x, y: p.y } }; });
}

const elk = new ELK();
export async function elkLayout(nodes: any[], edges: any[]) {
    const graph = {
        id: 'root',
        layoutOptions: { 'elk.algorithm': 'layered', 'elk.direction': 'RIGHT' },
        children: nodes.map(n => ({ id: n.id, width: n.style?.width || 300, height: n.style?.height || 120 })),
        edges: edges.map(e => ({ id: e.id, sources: [e.source], targets: [e.target] }))
    } as any;
    const res = await elk.layout(graph);
    const pos: Record<string, { x: number; y: number }> = {};
    res.children?.forEach((c: any) => { pos[c.id] = { x: c.x, y: c.y }; });
    return nodes.map(n => ({ ...n, position: pos[n.id] || n.position }));
}
```

## webview/src/main.tsx

```text
﻿import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import './styles.css';
import 'highlight.js/styles/github-dark.css';

createRoot(document.getElementById('root')!).render(<App />);
```

## webview/src/reactflow-node-types.tsx

```text
﻿import React from 'react';
import { Handle, Position } from 'reactflow';

export function FileNode({ data }: any) {
    return (
        <div className="file-node">
            <div className="file-node-header">{data.label}</div>
            <div className="file-node-body">{data.preview}</div>
            <Handle type="source" position={Position.Right} />
            <Handle type="target" position={Position.Left} />
        </div>
    );
}

export const nodeTypes = { file: FileNode } as const;
```

## webview/src/styles.css

```css
﻿:root {
    color-scheme: dark;
}

body,
html,
#root {
    margin: 0;
    height: 100%;
    background: #0b0e12;
    color: #cdd6f4;
    font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Inter, sans-serif;
}

.root {
    height: 100%;
}

.toolbar {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    display: flex;
    gap: 6px;
}

.toolbar button {
    background: #111827;
    border: 1px solid #1f2937;
    color: #e5e7eb;
    padding: 6px 10px;
    border-radius: 8px;
    cursor: pointer;
}

.file-node {
    width: 100%;
    height: 100%;
    background: #0d1117;
    border: 1px solid #1f2937;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 0 0 1px #0b1220 inset;
}

.file-node-header {
    background: #0b1220;
    padding: 6px 10px;
    font-weight: 600;
    font-size: 12px;
    letter-spacing: .3px;
    border-bottom: 1px solid #1f2937;
    cursor: default;
}

.code-card {
    height: calc(100% - 30px);
    overflow: auto;
}

.code-card .file-title {
    display: none;
}

pre.hljs {
    margin: 0;
    padding: 8px 10px 8px 56px;
    /* leave space for gutter */
    font-size: 12px;
    line-height: 1.35;
    position: relative;
    counter-reset: line;
}

pre.hljs .code-line {
    display: block;
    counter-increment: line;
    position: relative;
}

pre.hljs .code-line::before {
    content: counter(line);
    position: absolute;
    left: -44px;
    width: 36px;
    text-align: right;
    color: #6b7280;
    opacity: 0.9;
}

pre.hljs .code-line.highlight {
    background: rgba(255, 214, 10, 0.15);
    outline: 1px solid rgba(255, 214, 10, 0.35);
}

pre.hljs.wrap {
    white-space: pre-wrap;
}

.preview {
    font-size: 11px;
    opacity: .8;
    padding: 8px;
}

/* Improve MiniMap visibility */
.react-flow__minimap {
    background: #0f1115 !important;
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.06) inset;
}

.react-flow__minimap-mask {
    fill: rgba(255, 255, 255, 0.06) !important;
}

.react-flow__minimap-node {
    fill: #4f46e5 !important;
    stroke: rgba(255, 255, 255, 0.2) !important;
}

/* Allow extreme zooming */
.react-flow__renderer,
.react-flow__viewport {
    will-change: transform;
}
```

## webview/tsconfig.json

```json
﻿{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "allowJs": false,
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "useDefineForClassFields": true
  },
  "include": ["src"]
}
```

## webview/vite.config.ts

```typescript
﻿import { defineConfig } from 'vite';
import path from 'path';

export default defineConfig({
    base: '',
    build: {
        outDir: path.resolve(__dirname, '../extension/media'), // note ../
        emptyOutDir: true,
        sourcemap: 'inline',          // ← embed maps + sourcesContent
        minify: false,                // ← readable stack frames
        rollupOptions: {
            input: path.resolve(__dirname, 'index.html'),
            output: { sourcemapExcludeSources: false }
        },
        target: 'chrome120'
    }
});
```

## Statistics

- Total Files: 25
- Total Characters: 12170665
- Total Tokens: 0
```````

## webview/index.html

```html
﻿<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; img-src vscode-resource: https: data:; style-src 'unsafe-inline' __CSP__; script-src __CSP__; font-src __CSP__; connect-src __CSP__;" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Code Canvas</title>
</head>

<body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
</body>

</html>
```

## webview/package.json

```json
{
    "name": "code-canvas-webview",
    "private": true,
    "version": "0.0.1",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "vite build"
    },
    "dependencies": {
        "dagre": "^0.8.5",
        "elkjs": "^0.10.0",
        "highlight.js": "^11.9.0",
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "reactflow": "^11.11.4"
    },
    "devDependencies": {
        "@types/react": "^18.3.3",
        "@types/react-dom": "^18.3.0",
        "typescript": "^5.6",
        "vite": "^7.1.2"
    }
}
```

## webview/src/App.tsx

```text
﻿import React, { useEffect, useMemo, useRef, useState } from 'react';
import ReactFlow, { Background, Controls, MiniMap, Handle, Position, applyNodeChanges } from 'reactflow';
import 'reactflow/dist/style.css';
import { nodeTypes } from './reactflow-node-types';
import CodeCard from './code/CodeCard';

// VS Code webview API
declare global { interface Window { acquireVsCodeApi: any; __CODE_CACHE?: Record<string, string> } }
const vscode = window.acquireVsCodeApi?.();

type Node = { id: string; type: 'file'; position: { x: number; y: number }; data: any; style?: any; dragHandle?: string };

export default function App() {
    const [graph, setGraph] = useState<{ nodes: any[]; edges: any[] }>({ nodes: [], edges: [] });
    const [nodes, setNodes] = useState<Node[]>([]);
    const [edges, setEdges] = useState<any[]>([]);
    const nodesRef = useRef<Node[]>([]);
    const edgesRef = useRef<any[]>([]);
    const [rawEdges, setRawEdges] = useState<any[]>([]);
    const [selectedIds, setSelectedIds] = useState<string[]>([]);
    const [emptyMsg, setEmptyMsg] = useState<string | undefined>(undefined);
    const [progress, setProgress] = useState<string | undefined>(undefined);
    const lastAlgo = useRef<'horizontal'>('horizontal');
    const [showRefs, setShowRefs] = useState(true);
    const [wrap, setWrap] = useState(false);
    const [showEdges, setShowEdges] = useState(true);
    const [focusIds, setFocusIds] = useState<Set<string> | null>(null);
    const rfInstanceRef = useRef<any | null>(null);
    const hasFitOnceRef = useRef<boolean>(false);
    const viewportRef = useRef<{ x: number; y: number; zoom: number }>({ x: 0, y: 0, zoom: 1 });
    const [zoomOk, setZoomOk] = useState<boolean>(true);
    const codeCacheRef = useRef<Record<string, string>>({});
    const measuredSizeRef = useRef<Record<string, { width: number; height: number }>>({});
    const pendingMeasureRef = useRef<Record<string, { width: number; height: number }>>({});
    const rafCommitRef = useRef<number | null>(null);
    const headerHeight = 30; // matches CSS: .code-card { height: calc(100% - 30px); }
    const prePaddingTop = 8; // matches CSS: pre.hljs { padding: 8px 10px; }
    const lineHeight = 16; // approx from font-size 12px and line-height 1.35
    const linePosRef = useRef<Record<string, { line: number; top: number }[]>>({});
    const highlightRef = useRef<Record<string, number | undefined>>({});
    const scrollRef = useRef<Record<string, number | undefined>>({});
    const zoomSmoothTimerRef = useRef<number | null>(null);
    const moveSamplesRef = useRef<Array<{ t: number; x: number; y: number }>>([]);
    const isFlingingRef = useRef<boolean>(false);
    const flingRafRef = useRef<number | null>(null);
    const velocityRef = useRef<{ vx: number; vy: number }>({ vx: 0, vy: 0 });
    const lastInputRef = useRef<'wheel' | 'drag' | null>(null);
    const zoomLockUntilRef = useRef<number>(0);
    const zoomActiveRef = useRef<boolean>(false);

    function cancelFling(): void {
        if (flingRafRef.current != null) {
            try { cancelAnimationFrame(flingRafRef.current); } catch { }
            flingRafRef.current = null;
        }
        isFlingingRef.current = false;
    }

    function startFling(initialVx: number, initialVy: number): void {
        cancelFling();
        isFlingingRef.current = true;
        velocityRef.current = { vx: initialVx, vy: initialVy };
        let last = performance.now();
        const damping = 3.0; // s^-1 exponential decay
        const stopThreshold = 30; // px/s
        const axisStopMin = 15; // px/s per-axis stop to avoid tiny oscillations
        const step = () => {
            if (!isFlingingRef.current) return;
            const now = performance.now();
            const dt = Math.max(0, (now - last) / 1000);
            last = now;
            const v = velocityRef.current;
            const decay = Math.exp(-damping * dt);
            const prevVx = v.vx; const prevVy = v.vy;
            v.vx *= decay; v.vy *= decay;
            // Stop an axis if it crosses zero or is very small
            if (Math.sign(prevVx) !== 0 && Math.sign(prevVx) !== Math.sign(v.vx)) v.vx = 0;
            if (Math.abs(v.vx) < axisStopMin) v.vx = 0;
            if (Math.sign(prevVy) !== 0 && Math.sign(prevVy) !== Math.sign(v.vy)) v.vy = 0;
            if (Math.abs(v.vy) < axisStopMin) v.vy = 0;
            const speed = Math.hypot(v.vx, v.vy);
            const vp = viewportRef.current;
            let nextX = vp.x + v.vx * dt;
            let nextY = vp.y + v.vy * dt;
            // Snap to integer pixels near stop to reduce subpixel shimmer
            if (speed < 80) { nextX = Math.round(nextX); nextY = Math.round(nextY); }
            try { rfInstanceRef.current?.setViewport?.({ x: nextX, y: nextY, zoom: vp.zoom }); } catch { }
            viewportRef.current = { x: nextX, y: nextY, zoom: vp.zoom };
            if (speed < stopThreshold) { cancelFling(); return; }
            flingRafRef.current = requestAnimationFrame(step);
        };
        flingRafRef.current = requestAnimationFrame(step);
    }

    function enqueueSizeUpdate(nodeId: string, size: { width: number; height: number }) {
        // Avoid style writes while viewport is animated to prevent flicker
        if (isFlingingRef.current || isDraggingViewRef.current) return;
        pendingMeasureRef.current[nodeId] = size;
        if (rafCommitRef.current == null) {
            rafCommitRef.current = window.requestAnimationFrame(() => {
                const updates = pendingMeasureRef.current;
                pendingMeasureRef.current = {};
                rafCommitRef.current = null;
                setNodes(prev => prev.map((x: any) => updates[x.id] ? { ...x, style: updates[x.id] } : x));
            });
        }
    }

    function computeStyleFromContent(content: string) {
        // fallback rough estimate before exact measure arrives
        const text = content || '';
        const lines = text.split('\n');
        const maxLen = lines.reduce((m, l) => Math.max(m, l.length), 0);
        const rawWidth = Math.max(480, Math.floor(maxLen * 7 + 40));
        const rawHeight = Math.max(200, lines.length * 14 + 30);
        // clamp to avoid enormous nodes that can destabilize layout/rendering
        const width = Math.min(rawWidth, 1400);
        const height = Math.min(rawHeight, 900);
        return { width, height } as const;
    }

    useEffect(() => {
        vscode?.postMessage({ type: 'requestGraph' });
        vscode?.postMessage({ type: 'requestChanged' });
        const listener = (e: MessageEvent) => {
            const msg = e.data;
            if (msg.type === 'empty') setEmptyMsg(msg.reason === 'no-workspace'
                ? 'Open a folder to analyze your code.' : 'No JS/TS/Python files found.');
            else if (msg.type === 'progress') setProgress(msg.msg || undefined);
            else if (msg.type === 'graph') {
                setEmptyMsg(undefined); setProgress(undefined); setGraph(msg.graph);
                const paths = (msg.graph?.nodes || []).map((n: any) => n.path);
                if (paths.length) startCodeLoadBatch(paths);
                setRawEdges(msg.graph?.edges || []);
            }
            else if (msg.type === 'expandResult') mergeGraph(msg.graph);
            else if (msg.type === 'changedFiles') {
                openFiles(msg.files);
            } else if (msg.type === 'openChanged') {
                openFiles(msg.files);
            } else if (msg.type === 'layout') {
                layout('horizontal');
            } else if (msg.type === 'toggleRefs') {
                setShowRefs(s => !s);
            } else if (msg.type === 'toggleEdges') {
                setShowEdges(s => !s);
            } else if (msg.type === 'code') {
                codeCacheRef.current[msg.path] = msg.content || '';
                setNodes(prev => prev.map(n => n.data.path === msg.path ? { ...n, style: computeStyleFromContent(codeCacheRef.current[msg.path]) } : n));
                onCodeArrived([msg.path]);
            } else if (msg.type === 'codeMany') {
                const updated = new Set<string>();
                for (const { path, content } of (msg.entries || [])) {
                    codeCacheRef.current[path] = content || '';
                    updated.add(path);
                }
                if (updated.size) setNodes(prev => prev.map(n => updated.has(n.data.path) ? { ...n, style: computeStyleFromContent(codeCacheRef.current[n.data.path]) } : n));
                onCodeArrived(Array.from(updated));
            } else if (msg.type === 'seedFolder') {
                // The extension relays the path; filter current index graph by prefix and request code for those
                const folder: string = msg.folder;
                const selected = (graph.nodes || []).filter((n: any) => (n.path || '').startsWith(folder));
                setNodes(prev => selected.map((n: any, i: number) => ({
                    id: n.id, type: 'file', position: { x: (i % 3) * 1200, y: Math.floor(i / 3) * 1000 },
                    style: computeStyleFromContent(codeCacheRef.current[n.path] || ''), dragHandle: '.file-node-header', data: { label: n.label, preview: (<div className="preview">{n.path}</div>), path: n.path, lang: n.lang }
                })));
                const paths = selected.map((n: any) => n.path);
                if (paths.length) startCodeLoadBatch(paths);
            }
        };
        window.addEventListener('message', listener);
        return () => window.removeEventListener('message', listener);
    }, []);

    useEffect(() => { // build ReactFlow nodes
        const initial: Node[] = graph.nodes.map((n: any, i: number) => ({
            id: n.id,
            type: 'file',
            position: { x: (i % 3) * 1200, y: Math.floor(i / 3) * 1000 },
            style: computeStyleFromContent(codeCacheRef.current[n.path] || ''),
            dragHandle: '.file-node-header',
            data: { label: n.label, preview: (<div className="preview">{n.path}</div>), path: n.path, lang: n.lang }
        }));
        const e = (graph.edges || []).map((e: any) => ({
            id: e.id,
            source: e.source,
            target: e.target,
            data: { sourceLine: e.sourceLine, targetLine: e.targetLine },
            sourceHandle: (e.sourceLine ?? null) !== null && (e.sourceLine ?? undefined) !== undefined ? `line-${e.sourceLine}` : undefined,
            targetHandle: (e.targetLine ?? null) !== null && (e.targetLine ?? undefined) !== undefined ? `line-${e.targetLine}` : undefined
        }));
        setNodes(initial); setEdges(e);
        hasFitOnceRef.current = false;
    }, [graph]);

    useEffect(() => { nodesRef.current = nodes; }, [nodes]);
    useEffect(() => { edgesRef.current = edges; }, [edges]);

    function mergeGraph(g: any) {
        const newPaths: string[] = [];
        setNodes(prev => {
            const map = new Map(prev.map(n => [n.id, n]));
            for (const n of g.nodes) if (!map.has(n.id)) {
                newPaths.push(n.path);
                map.set(n.id, {
                    id: n.id, type: 'file',
                    position: { x: Math.random() * 800, y: Math.random() * 600 },
                    style: computeStyleFromContent(codeCacheRef.current[n.path] || ''),
                    dragHandle: '.file-node-header',
                    data: { label: n.label, preview: <div className="preview">{n.path}</div>, path: n.path, lang: n.lang }
                } as any);
            }
            return Array.from(map.values());
        });
        setEdges(prev => {
            const ids = new Set(prev.map(e => e.id));
            const add = g.edges.filter((e: any) => !ids.has(e.id));
            return [...prev, ...add];
        });
        if (newPaths.length) requestMoreCode(newPaths);
    }

    function openFiles(paths: string[]) {
        setNodes(prev => {
            const ids = new Set(prev.map(p => p.id));
            const add: Node[] = graph.nodes
                .filter((n: any) => paths.includes(n.path) && !ids.has(n.id))
                .map((n: any, i: number) => ({
                    id: n.id,
                    type: 'file',
                    position: { x: 50 + i * 30, y: 60 + i * 30 },
                    style: { width: 480, height: 280 },
                    dragHandle: '.file-node-header',
                    data: { label: n.label, preview: <div className="preview">{n.path}</div>, path: n.path, lang: n.lang }
                }));
            return [...prev, ...add];
        });
        if (paths && paths.length) requestMoreCode(paths);
    }

    // Debounced auto-layout to avoid thrashing
    const autoLayoutTimer = useRef<number | null>(null);
    function scheduleAutoLayout() {
        if (autoLayoutTimer.current) {
            window.clearTimeout(autoLayoutTimer.current);
        }
        autoLayoutTimer.current = window.setTimeout(() => { layout('horizontal'); }, 250);
    }

    // Track pending code loads and run one layout after all code in a batch has loaded
    const pendingCodePathsRef = useRef<Set<string>>(new Set());
    const afterFullLoadLayoutTimer = useRef<number | null>(null);
    const moveFrameRef = useRef<number | null>(null);
    const pendingVpRef = useRef<any | null>(null);
    const isDraggingViewRef = useRef<boolean>(false);

    function maybeRunLayoutAfterFullLoad() {
        if (pendingCodePathsRef.current.size !== 0) return;
        if (afterFullLoadLayoutTimer.current != null) {
            window.clearTimeout(afterFullLoadLayoutTimer.current);
        }
        // Give the DOM a moment so CodeCard measurements propagate before layout
        afterFullLoadLayoutTimer.current = window.setTimeout(() => {
            layout('horizontal');
            afterFullLoadLayoutTimer.current = null;
        }, 120);
    }

    function startCodeLoadBatch(paths: string[]) {
        const toRequest = (paths || []).filter(p => !codeCacheRef.current[p]);
        pendingCodePathsRef.current = new Set(toRequest);
        if (toRequest.length) {
            vscode?.postMessage({ type: 'requestCodeMany', paths: toRequest });
        } else {
            maybeRunLayoutAfterFullLoad();
        }
    }

    function requestMoreCode(paths: string[]) {
        const toRequest = (paths || []).filter(p => !codeCacheRef.current[p]);
        if (toRequest.length) {
            toRequest.forEach(p => pendingCodePathsRef.current.add(p));
            vscode?.postMessage({ type: 'requestCodeMany', paths: toRequest });
        }
    }

    function onCodeArrived(paths: string[]) {
        let any = false;
        for (const p of paths) {
            if (pendingCodePathsRef.current.delete(p)) any = true;
        }
        if (any) maybeRunLayoutAfterFullLoad();
    }

    async function layout(_algo: 'horizontal', forceFit: boolean = false) {
        lastAlgo.current = 'horizontal';
        const currentNodes = nodesRef.current as any as Node[];
        let currentX = 40;
        const y = 60;
        const spacing = 20;
        const laidOut = currentNodes.map(n => {
            const measured = measuredSizeRef.current[n.id];
            const width = (n?.style?.width ?? measured?.width ?? 480);
            const pos = { x: currentX, y };
            currentX += width + spacing;
            return { ...n, position: pos } as any;
        });
        setNodes(laidOut as any);
    }

    function onOpenFile(n: Node) { vscode?.postMessage({ type: 'openFile', path: n.data.path }); }

    function onTokenClick({ path, line, character, token }: any) {
        if (!showRefs) return;
        vscode?.postMessage({ type: 'requestRefs', path, line, character, token });
        vscode?.postMessage({ type: 'requestDefOpen', path, line, character });
        // Focus connected nodes to the clicked file
        const base = nodes.find(n => n.data.path === path);
        if (base) focusNodesForId(base.id);
    }

    function expandSelection() {
        const ids = selectedIds.length ? selectedIds : (nodes as any).filter((n: any) => n.selected).map((n: any) => n.id);
        if (ids.length) vscode?.postMessage({ type: 'expand', ids });
    }

    function focusNodesForId(baseId: string) {
        const neighborIds = new Set<string>([baseId]);
        for (const e of edges as any[]) {
            if (e.source === baseId) neighborIds.add(e.target);
            if (e.target === baseId) neighborIds.add(e.source);
        }
        // Build vertical positions for focus lane
        const order: string[] = [baseId, ...Array.from(neighborIds).filter(id => id !== baseId).sort()];
        let currentY = 60;
        const x = 40;
        const spacing = 20;
        const nextPos = new Map<string, { x: number; y: number }>();
        for (const id of order) {
            const n = nodes.find(n => n.id === id);
            const h = (n?.style?.height ?? measuredSizeRef.current[id]?.height ?? 280);
            nextPos.set(id, { x, y: currentY });
            currentY += h + spacing;
        }
        setFocusIds(new Set(neighborIds));
        setNodes(prev => prev.map(n => {
            const inFocus = neighborIds.has(n.id);
            const pos = nextPos.get(n.id);
            if (inFocus && pos) {
                return { ...n, position: pos, data: { ...n.data, dim: false } } as any;
            }
            return { ...n, data: { ...n.data, dim: true } } as any;
        }));
    }

    function clearFocus() {
        setFocusIds(null);
        setNodes(prev => prev.map(n => ({ ...n, data: { ...n.data, dim: false } } as any)));
    }

    const elevatedPairRef = useRef<{ edgeId: string | null; aId: string | null; bId: string | null }>({ edgeId: null, aId: null, bId: null });

    function getNodeWidth(id: string): number {
        const n = nodesRef.current.find(nn => nn.id === id);
        const measured = measuredSizeRef.current[id];
        return (n?.style?.width ?? measured?.width ?? 480);
    }

    function getNodeHeight(id: string): number {
        const n = nodesRef.current.find(nn => nn.id === id);
        const measured = measuredSizeRef.current[id];
        return (n?.style?.height ?? measured?.height ?? 280);
    }

    function computeRowPositions(list: Node[]): Map<string, { x: number; y: number }> {
        const pos = new Map<string, { x: number; y: number }>();
        const spacing = 20;
        let currentX = 40;
        const y = 60;
        for (const n of list) {
            pos.set(n.id, { x: currentX, y });
            const width = getNodeWidth(n.id);
            currentX += width + spacing;
        }
        return pos;
    }

    function elevateEdgePair(edge: any) {
        try {
            const aId: string | undefined = edge?.source;
            const bId: string | undefined = edge?.target;
            if (!aId || !bId) return;
            const prevPair = elevatedPairRef.current;
            const samePair = (prevPair.aId && prevPair.bId) && ((prevPair.aId === aId && prevPair.bId === bId) || (prevPair.aId === bId && prevPair.bId === aId));
            if (edge?.id && prevPair.edgeId === edge.id) return; // exact same link
            if (!edge?.id && samePair) return; // same endpoints

            const sharedIds = new Set<string>();
            if (prevPair.aId && (prevPair.aId === aId || prevPair.aId === bId)) sharedIds.add(prevPair.aId);
            if (prevPair.bId && (prevPair.bId === aId || prevPair.bId === bId)) sharedIds.add(prevPair.bId);

            const spacing = 20;
            const yRow = 60;

            // Temporarily freeze interactions; prevents internal auto panning/viewport changes during updates
            try { rfInstanceRef.current?.setInteractive?.(false); } catch { }

            setFocusIds(null);
            setNodes(prev => {
                // First: restore everyone to row positions except shared elevated node (if any)
                const posMap = computeRowPositions(prev as any);
                let next = prev.map(n => (sharedIds.has(n.id) ? n : ({ ...n, position: posMap.get(n.id)! } as any)));

                // Then: elevate the new pair
                if (sharedIds.has(aId)) {
                    const shared = next.find(n => n.id === aId)!;
                    const sharedX = (shared as any).position.x;
                    const sharedY = (shared as any).position.y;
                    const aWidth = getNodeWidth(aId);
                    const bWidth = getNodeWidth(bId);
                    const bHeight = getNodeHeight(bId);
                    const bX = sharedX + aWidth + spacing;
                    const bY = sharedY; // keep same vertical as shared for minimal movement
                    next = next.map(n => (n.id === bId ? ({ ...n, position: { x: bX, y: bY } } as any) : n));
                } else if (sharedIds.has(bId)) {
                    const shared = next.find(n => n.id === bId)!;
                    const sharedX = (shared as any).position.x;
                    const sharedY = (shared as any).position.y;
                    const aWidth = getNodeWidth(aId);
                    const aHeight = getNodeHeight(aId);
                    const aX = sharedX - aWidth - spacing;
                    const aY = sharedY;
                    next = next.map(n => (n.id === aId ? ({ ...n, position: { x: aX, y: aY } } as any) : n));
                } else {
                    // No shared node: elevate both newly, top-aligned
                    const aWidth = getNodeWidth(aId);
                    const aHeight = getNodeHeight(aId);
                    const bHeight = getNodeHeight(bId);
                    const aX = 40;
                    const topY = yRow - Math.max(aHeight, bHeight) - spacing;
                    const bX = aX + aWidth + spacing;
                    next = next.map(n => {
                        if (n.id === aId) return { ...n, position: { x: aX, y: topY } } as any;
                        if (n.id === bId) return { ...n, position: { x: bX, y: topY } } as any;
                        return n;
                    });
                }

                elevatedPairRef.current = { edgeId: edge?.id ?? `${aId}->${bId}`, aId, bId };
                return next;
            });

            // Re-enable interactions right after updates
            setTimeout(() => { try { rfInstanceRef.current?.setInteractive?.(true); } catch { } }, 0);
        } catch { }
    }

    useEffect(() => {
        const onKey = (e: KeyboardEvent) => { if ((e.key === 'e' || e.key === 'E')) expandSelection(); };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
    }, [nodes]);

    // render code previews lazily inside each node

    const VISIBLE_ZOOM_THRESHOLD = 0.65; // below this, render placeholder

    const codeRefs = useRef<Record<string, React.RefObject<import('./code/CodeCard').CodeCardHandle>>>({});
    const nodeTypesLocal = useMemo(() => ({
        file: (p: any) => {
            const n = p.data;
            const content = codeCacheRef.current[n.path] ?? n.path;
            const shouldShowCode = zoomOk;
            if (!codeRefs.current[p.id]) codeRefs.current[p.id] = React.createRef();
            const handleLines: number[] = (() => {
                const s = new Set<number>();
                for (const e of edges as any[]) {
                    if (e.source === p.id && e.data?.sourceLine != null) s.add(e.data.sourceLine);
                    if (e.target === p.id && e.data?.targetLine != null) s.add(e.data.targetLine);
                }
                return Array.from(s).sort((a, b) => a - b).slice(0, 200);
            })();
            return (
                <div className="file-node" style={{ opacity: n.dim ? 0.25 : 1 }}>
                    <div className="file-node-header" onDoubleClick={() => onOpenFile(p)}>{n.label}</div>
                    {shouldShowCode ? (
                        <CodeCard
                            ref={codeRefs.current[p.id]}
                            key={n.path}
                            file={n.path}
                            lang={n.lang}
                            content={content}
                            onTokenClick={onTokenClick}
                            wrap={wrap}
                            onLinePositions={(positions) => { linePosRef.current[p.id] = positions; }}
                            onMeasured={({ width, height }) => {
                                if (isFlingingRef.current || isDraggingViewRef.current) return;
                                const last = measuredSizeRef.current[p.id];
                                if (last && last.width === width && last.height === height) return;
                                measuredSizeRef.current[p.id] = { width, height };
                                enqueueSizeUpdate(p.id, { width, height });
                            }}
                        />
                    ) : (
                        <div className="node-placeholder-body">Zoom in to view code</div>
                    )}
                    {/* default center handles */}
                    <Handle type="source" position={Position.Right} id={`line-0`} />
                    <Handle type="target" position={Position.Left} id={`line-0`} />
                    {/* per-line handles anchored by top offset */}
                    {handleLines.map((ln) => {
                        const top = (linePosRef.current[p.id]?.find(x => x.line === ln)?.top) ?? (headerHeight + prePaddingTop + ln * lineHeight);
                        return (
                            <React.Fragment key={ln}>
                                <Handle
                                    type="source"
                                    position={Position.Right}
                                    id={`line-${ln}`}
                                    style={{ top }}
                                />
                                <Handle
                                    type="target"
                                    position={Position.Left}
                                    id={`line-${ln}`}
                                    style={{ top }}
                                />
                            </React.Fragment>
                        );
                    })}
                </div>
            );
        }
    }), [edges, zoomOk, wrap]);

    return (
        <div className="root">
            <div className="toolbar">
                <button onClick={() => layout('horizontal', true)}>Relayout</button>
                <button onClick={() => vscode?.postMessage({ type: 'loadMore' })}>Load 25 more</button>
                <button onClick={() => vscode?.postMessage({ type: 'requestChanged' })}>Open Changed (⇧O)</button>
                <button onClick={() => vscode?.postMessage({ type: 'requestGraph' })}>Reload</button>
                <button onClick={expandSelection}>Expand (E)</button>
                <button onClick={() => vscode?.postMessage({ type: 'toggleRefs' })}>Refs (R)</button>
                <button onClick={() => setWrap(w => !w)}>{wrap ? 'Unwrap' : 'Wrap'}</button>
                <button onClick={() => setShowEdges(s => !s)}>{showEdges ? 'Hide Edges' : 'Show Edges'}</button>
                <button onClick={() => vscode?.postMessage({ type: 'toggleEdges' })}>Toggle Edges (Global)</button>
                <button onClick={() => vscode?.postMessage({ type: 'seedFolder' })}>Seed Folder…</button>
                {focusIds ? (<button onClick={clearFocus}>Clear Focus</button>) : null}
            </div>
            <ReactFlow
                nodes={nodes as any}
                edges={showEdges ? (focusIds ? (edges as any[]).filter(e => focusIds.has(e.source) && focusIds.has(e.target)) : edges) : []}
                nodeTypes={nodeTypesLocal as any}
                onlyRenderVisibleElements
                onInit={(inst) => {
                    rfInstanceRef.current = inst;
                    try {
                        const vp = inst?.getViewport?.();
                        if (vp) {
                            setZoomOk(vp.zoom >= VISIBLE_ZOOM_THRESHOLD);
                            viewportRef.current = { x: vp.x, y: vp.y, zoom: vp.zoom };
                        }
                        const container = document.querySelector('.react-flow') as HTMLElement | null;
                        const onWheel = (e: WheelEvent) => {
                            try {
                                lastInputRef.current = 'wheel';
                                const vpEl = document.querySelector('.react-flow__viewport');
                                if (!vpEl) return;
                                vpEl.classList.add('zoom-smooth');
                                const now = performance.now();
                                // Lock fling logic during zoom gesture window
                                zoomLockUntilRef.current = now + 420;
                                zoomActiveRef.current = true;
                                // Clear any drag samples so zoom motion isn't used for fling
                                moveSamplesRef.current = [];
                                if (zoomSmoothTimerRef.current) window.clearTimeout(zoomSmoothTimerRef.current);
                                zoomSmoothTimerRef.current = window.setTimeout(() => {
                                    vpEl.classList.remove('zoom-smooth');
                                    zoomActiveRef.current = false;
                                    lastInputRef.current = null;
                                }, 420);
                            } catch { }
                        };
                        container?.addEventListener('wheel', onWheel, { passive: true } as any);
                        (window as any).__rf_wheel_cleanup = () => container?.removeEventListener('wheel', onWheel as any);
                    } catch { }
                }}
                onNodeClick={(_e, node: any) => { setFocusIds(null); }}
                onNodeDragStart={(_evt, node) => {
                    try {
                        const el = document.querySelector(`.react-flow__node[data-id="${node.id}"]`);
                        el?.classList.add('no-animate');
                        const vpEl = document.querySelector('.react-flow__viewport');
                        vpEl?.classList.remove('zoom-smooth');
                        isDraggingViewRef.current = true;
                        lastInputRef.current = 'drag';
                        cancelFling();
                        moveSamplesRef.current = [];
                    } catch { }
                }}
                onNodeDragStop={(_evt, node) => {
                    try {
                        const el = document.querySelector(`.react-flow__node[data-id="${node.id}"]`);
                        el?.classList.remove('no-animate');
                        isDraggingViewRef.current = false;
                    } catch { }
                }}
                onMoveStart={() => {
                    if (zoomActiveRef.current || performance.now() < zoomLockUntilRef.current) return;
                    // User begins panning
                    cancelFling();
                    moveSamplesRef.current = [];
                    try { const el = document.querySelector('.react-flow__viewport'); el?.classList.remove('zoom-smooth'); } catch { }
                    lastInputRef.current = 'drag';
                }}
                onMove={(_evt, vp) => {
                    try {
                        if (!vp) return;
                        if (isFlingingRef.current) { viewportRef.current = { x: vp.x, y: vp.y, zoom: vp.zoom }; return; }
                        if (zoomActiveRef.current || performance.now() < zoomLockUntilRef.current) { viewportRef.current = { x: vp.x, y: vp.y, zoom: vp.zoom }; return; }
                        pendingVpRef.current = vp;
                        if (moveFrameRef.current != null) return;
                        moveFrameRef.current = window.requestAnimationFrame(() => {
                            moveFrameRef.current = null;
                            const latest = pendingVpRef.current; pendingVpRef.current = null;
                            if (!latest) return;
                            const newZoom = latest.zoom;
                            const nextZoomOk = newZoom >= VISIBLE_ZOOM_THRESHOLD;
                            if (nextZoomOk !== zoomOk) setZoomOk(nextZoomOk);
                            viewportRef.current = { x: latest.x, y: latest.y, zoom: latest.zoom };
                            // Record samples for velocity estimation
                            const now = performance.now();
                            if (!zoomActiveRef.current && now >= zoomLockUntilRef.current) moveSamplesRef.current.push({ t: now, x: latest.x, y: latest.y });
                            // Keep only last ~120ms of samples
                            const cutoff = now - 120;
                            if (moveSamplesRef.current.length > 1) {
                                let i = 0; while (i < moveSamplesRef.current.length && moveSamplesRef.current[i].t < cutoff) i++;
                                if (i > 0) moveSamplesRef.current.splice(0, i);
                            }
                        });
                    } catch { }
                }}
                onMoveEnd={() => {
                    try {
                        if (zoomActiveRef.current || performance.now() < zoomLockUntilRef.current) { cancelFling(); return; }
                        // Estimate velocity from last samples
                        const samples = moveSamplesRef.current;
                        if (!samples || samples.length < 2) { cancelFling(); return; }
                        const first = samples[0];
                        const lastS = samples[samples.length - 1];
                        const dtMs = Math.max(1, lastS.t - first.t);
                        const vx = (lastS.x - first.x) / dtMs * 1000; // px/s
                        const vy = (lastS.y - first.y) / dtMs * 1000; // px/s
                        const speed = Math.hypot(vx, vy);
                        const startThreshold = 450; // px/s to start fling
                        if (speed >= startThreshold && lastInputRef.current !== 'wheel') startFling(vx, vy);
                        else { cancelFling(); }
                    } catch { }
                }}
                onEdgeClick={(_e, edge: any) => {
                    const sl = (edge?.data?.sourceLine ?? 0);
                    const tl = (edge?.data?.targetLine ?? 0);
                    if (edge?.source) {
                        try {
                            const ref = codeRefs.current[edge.source];
                            ref?.current?.highlight(sl);
                            ref?.current?.scrollTo(sl);
                        } catch { }
                    }
                    if (edge?.target) {
                        try {
                            const ref = codeRefs.current[edge.target];
                            ref?.current?.highlight(tl);
                            ref?.current?.scrollTo(tl);
                        } catch { }
                    }
                    elevateEdgePair(edge);
                }}
                onSelectionChange={(p: any) => setSelectedIds((p?.nodes || []).map((n: any) => n.id))}
                onNodesChange={(changes) => setNodes((nds: any) => applyNodeChanges(changes as any, nds as any) as any)}
                minZoom={0.02}
                maxZoom={8}
            >
                <Background />
                <MiniMap pannable zoomable />
                <Controls />
            </ReactFlow>
            {progress && <div style={{ position: 'absolute', inset: 0, display: 'grid', placeItems: 'center', pointerEvents: 'none', fontSize: 14, opacity: .8 }}>⚙ {progress}</div>}
            {emptyMsg && <div style={{ position: 'absolute', inset: 0, display: 'grid', placeItems: 'center', fontSize: 14, opacity: .8 }}>{emptyMsg}</div>}
        </div>
    );
}
```

## webview/src/code/CodeCard.tsx

```text
﻿import React, { useLayoutEffect, useMemo, useRef, useImperativeHandle } from 'react';
import { highlight } from './highlight';

export type CodeCardHandle = {
    highlight: (line: number) => void;
    scrollTo: (line: number) => void;
};

function wrapHighlightedHtmlPreserveLines(highlightedHtml: string): string {
    const container = document.createElement('div');
    container.innerHTML = highlightedHtml;

    const lines: string[] = [];
    let current = '';
    const stack: Element[] = [];

    const escapeHtml = (s: string) => s
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

    const escapeAttr = (s: string) => s
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;');

    const startTag = (el: Element) => {
        const tag = el.tagName.toLowerCase();
        let attrs = '';
        for (const attr of Array.from(el.attributes)) {
            attrs += ` ${attr.name}="${escapeAttr(attr.value)}"`;
        }
        return `<${tag}${attrs}>`;
    };
    const endTag = (el: Element) => `</${el.tagName.toLowerCase()}>`;
    const openAll = () => stack.map(startTag).join('');
    const closeAll = () => stack.slice().reverse().map(endTag).join('');

    const flushLine = () => { lines.push(current); current = ''; };

    const handleText = (text: string) => {
        const parts = text.split(/\r\n|\n/);
        for (let i = 0; i < parts.length; i++) {
            current += escapeHtml(parts[i]);
            if (i < parts.length - 1) {
                current += closeAll();
                flushLine();
                current += openAll();
            }
        }
    };

    const walk = (node: Node) => {
        if (node.nodeType === Node.TEXT_NODE) {
            handleText((node as Text).data);
            return;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
            const el = node as Element;
            current += startTag(el);
            stack.push(el);
            for (const child of Array.from(el.childNodes)) walk(child);
            stack.pop();
            current += endTag(el);
            return;
        }
        // Ignore other node types
    };

    for (const child of Array.from(container.childNodes)) walk(child);
    // Ensure at least one line
    if (current !== '' || lines.length === 0) flushLine();

    return lines
        .map((line, i) => `<span class="code-line" data-line="${i}">${line === '' ? '&nbsp;' : line}</span>`)
        .join('');
}

type Props = {
    file: string;
    lang: 'ts' | 'js' | 'py' | 'other';
    content: string;
    onTokenClick: (payload: { path: string; line: number; character: number; token: string }) => void;
    onMeasured?: (size: { width: number; height: number }) => void;
    wrap?: boolean;
    onLinePositions?: (positions: { line: number; top: number }[]) => void;
};

function CodeCardInner({ file, lang, content, onTokenClick, onMeasured, wrap, onLinePositions }: Props, ref: React.Ref<CodeCardHandle>) {
    const effectiveLang = useMemo<'ts' | 'js' | 'py' | 'other'>(() => {
        if (lang && lang !== 'other') return lang;
        const lower = (file || '').toLowerCase();
        if (lower.endsWith('.py')) return 'py';
        if (lower.endsWith('.ts') || lower.endsWith('.tsx')) return 'ts';
        if (lower.endsWith('.js') || lower.endsWith('.jsx') || lower.endsWith('.mjs') || lower.endsWith('.cjs')) return 'js';
        return 'other';
    }, [file, lang]);

    const rawHtml = useMemo(() => highlight(content, effectiveLang), [content, effectiveLang]);
    const html = useMemo(() => wrapHighlightedHtmlPreserveLines(rawHtml), [rawHtml]);
    const preRef = useRef<HTMLPreElement | null>(null);
    const containerRef = useRef<HTMLDivElement | null>(null);
    const lastHighlightedRef = useRef<number | undefined>(undefined);

    useLayoutEffect(() => {
        const el = preRef.current;
        if (!el) return;
        const notify = () => onMeasured?.({ width: el.scrollWidth, height: el.scrollHeight });
        notify();
        const ro = new ResizeObserver(() => {
            notify();
            computeLinePositions();
        });
        ro.observe(el);
        const cont = containerRef.current;
        const onScroll = () => computeLinePositions();
        cont?.addEventListener('scroll', onScroll, { passive: true } as any);
        return () => { ro.disconnect(); cont?.removeEventListener('scroll', onScroll as any); };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [html, onMeasured]);

    function computeLinePositions() {
        try {
            const pre = preRef.current;
            const container = containerRef.current;
            const root = container?.closest('.file-node') as HTMLElement | null;
            if (!pre || !container || !root) return;
            const rootRect = root.getBoundingClientRect();
            const spans = Array.from(pre.querySelectorAll('span.code-line')) as HTMLElement[];
            const positions = spans.map((sp, idx) => {
                const spRect = sp.getBoundingClientRect();
                const top = (spRect.top - rootRect.top) + spRect.height / 2;
                return { line: idx, top };
            });
            onLinePositions?.(positions);
        } catch { }
    }

    useLayoutEffect(() => { computeLinePositions(); }, [html]);

    useImperativeHandle(ref, () => ({
        highlight: (line: number) => {
            try {
                const pre = preRef.current;
                if (!pre) return;
                const all = pre.querySelectorAll('.code-line.highlight');
                all.forEach(n => n.classList.remove('highlight'));
                const target = pre.querySelector(`.code-line[data-line="${line}"]`) as HTMLElement | null;
                if (target) {
                    target.classList.add('highlight');
                    lastHighlightedRef.current = line;
                }
            } catch { }
        },
        scrollTo: (line: number) => {
            try {
                const pre = preRef.current;
                const container = containerRef.current;
                if (!pre || !container) return;
                const target = pre.querySelector(`.code-line[data-line="${line}"]`) as HTMLElement | null;
                if (target) {
                    const preTop = (pre as HTMLElement).offsetTop;
                    const targetTop = target.offsetTop;
                    const desired = preTop + targetTop - (container.clientHeight / 2) + (target.offsetHeight / 2);
                    container.scrollTo({ top: Math.max(0, desired), behavior: 'auto' });
                }
            } catch { }
        }
    }), []);

    const onClick: React.MouseEventHandler<HTMLPreElement> = () => {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0 || sel.toString().length === 0) return;
        const token = sel.toString();
        const range = sel.getRangeAt(0);
        const startNode = range.startContainer;
        const startEl: Element | null = startNode.nodeType === Node.ELEMENT_NODE ? (startNode as Element) : (startNode.parentElement);
        if (!startEl) return;
        const lineEl = startEl.closest('.code-line') as HTMLElement | null;
        if (!lineEl) return;
        const lineAttr = lineEl.getAttribute('data-line');
        const line = lineAttr ? parseInt(lineAttr, 10) : 0;
        const headRange = document.createRange();
        headRange.selectNodeContents(lineEl);
        headRange.setEnd(range.startContainer, range.startOffset);
        const character = headRange.toString().length;
        onTokenClick({ path: file, line, character, token });
    };

    return (
        <div className="code-card" ref={containerRef}>
            <div className="file-title">{file}</div>
            <pre ref={preRef} id={`code-${file}`} className={`hljs${wrap ? ' wrap' : ''}`} onMouseUp={onClick} dangerouslySetInnerHTML={{ __html: html }} />
        </div>
    );
}

const CodeCard = React.memo(React.forwardRef(CodeCardInner), (prev, next) => (
    prev.file === next.file &&
    prev.content === next.content &&
    prev.wrap === next.wrap &&
    prev.lang === next.lang
));

export default CodeCard;
```

## webview/src/code/highlight.ts

```typescript
﻿import hljs from 'highlight.js/lib/core';
import ts from 'highlight.js/lib/languages/typescript';
import js from 'highlight.js/lib/languages/javascript';
import py from 'highlight.js/lib/languages/python';
import plaintext from 'highlight.js/lib/languages/plaintext';

hljs.registerLanguage('typescript', ts);
hljs.registerLanguage('javascript', js);
// Increase the maximum length before Highlight.js bails out to plaintext so large Python files still get properly highlighted.
hljs.configure({ maxHighlightLength: 500_000 } as any);
hljs.registerLanguage('python', py);
hljs.registerLanguage('plaintext', plaintext);

// A mapping object is slightly cleaner than a long ternary chain.
const languageMap = {
    ts: 'typescript',
    js: 'javascript',
    py: 'python',
    other: 'plaintext'
};

export function highlight(code: string, lang: 'ts' | 'js' | 'py' | 'other') {
    const mapped = languageMap[lang] || 'plaintext';

    // 1. First, check if the language is explicitly supported.
    if (hljs.getLanguage(mapped)) {
        try {
            // 2. Attempt to highlight with the specified language.
            return hljs.highlight(code, { language: mapped, ignoreIllegals: true }).value;
        } catch (e) {
            // This catch block will run if highlighting fails catastrophically.
            console.error(`Highlighting failed for language "${mapped}"`, e);
        }
    }

    // 3. If specific highlighting fails, fallback to auto-detection.
    // This is safer than the original implementation's catch-all.
    try {
        return hljs.highlightAuto(code).value;
    } catch (e) {
        console.error('Auto-highlighting failed', e);
        // 4. As a last resort, return the code escaped to prevent breaking HTML.
        return code.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
}
```

## webview/src/layout.ts

```typescript
﻿export { };
```

## webview/src/main.tsx

```text
﻿import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import './styles.css';
import 'highlight.js/styles/github-dark.css';

createRoot(document.getElementById('root')!).render(<App />);
```

## webview/src/reactflow-node-types.tsx

```text
﻿import React from 'react';
import { Handle, Position } from 'reactflow';

export function FileNode({ data }: any) {
    return (
        <div className="file-node">
            <div className="file-node-header">{data.label}</div>
            <div className="file-node-body">{data.preview}</div>
            <Handle type="source" position={Position.Right} />
            <Handle type="target" position={Position.Left} />
        </div>
    );
}

export const nodeTypes = { file: FileNode } as const;
```

## webview/src/styles.css

```css
﻿:root {
    color-scheme: dark;
    --ease-smooth: cubic-bezier(0.22, 1, 0.36, 1);
    --zoom-duration: 320ms;
}

body,
html,
#root {
    margin: 0;
    height: 100%;
    background: #0b0e12;
    color: #cdd6f4;
    font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Inter, sans-serif;
}

.root {
    height: 100%;
}

.toolbar {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    display: flex;
    gap: 6px;
}

.toolbar button {
    background: #111827;
    border: 1px solid #1f2937;
    color: #e5e7eb;
    padding: 6px 10px;
    border-radius: 8px;
    cursor: pointer;
}

.file-node {
    width: 100%;
    height: 100%;
    background: #0d1117;
    border: 1px solid #1f2937;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 0 0 1px #0b1220 inset;
}

.file-node-header {
    background: #0b1220;
    padding: 6px 10px;
    font-weight: 600;
    font-size: 12px;
    letter-spacing: .3px;
    border-bottom: 1px solid #1f2937;
    cursor: grab;
}

.code-card {
    height: calc(100% - 30px);
    overflow: auto;
}

.code-card .file-title {
    display: none;
}

pre.hljs {
    margin: 0;
    padding: 8px 10px 8px 56px;
    /* leave space for gutter */
    font-size: 12px;
    line-height: 1.35;
    position: relative;
    counter-reset: line;
}

pre.hljs .code-line {
    display: block;
    counter-increment: line;
    position: relative;
}

pre.hljs .code-line::before {
    content: counter(line);
    position: absolute;
    left: -44px;
    width: 36px;
    text-align: right;
    color: #6b7280;
    opacity: 0.9;
}

pre.hljs .code-line.highlight {
    background: rgba(255, 214, 10, 0.15);
    outline: 1px solid rgba(255, 214, 10, 0.35);
}

pre.hljs.wrap {
    white-space: pre-wrap;
}

.preview {
    font-size: 11px;
    opacity: .8;
    padding: 8px;
}

/* Improve MiniMap visibility */
.react-flow__minimap {
    background: #0f1115 !important;
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.06) inset;
}

.react-flow__minimap-mask {
    fill: rgba(255, 255, 255, 0.06) !important;
}

.react-flow__minimap-node {
    fill: #4f46e5 !important;
    stroke: rgba(255, 255, 255, 0.2) !important;
}

/* Allow extreme zooming */
.react-flow__renderer,
.react-flow__viewport {
    will-change: transform;
}

/* Smooth node transitions for layout/elevation changes */
.react-flow__node {
    transition: transform 220ms cubic-bezier(0.22, 1, 0.36, 1), opacity 160ms ease;
    will-change: transform;
}

/* Disable transition while dragging to keep the interaction snappy */
.react-flow__node.no-animate {
    transition: none !important;
}

@media (prefers-reduced-motion: reduce) {
    .react-flow__node {
        transition: none !important;
    }
}

/* Smooth transform transitions for the React Flow viewport (zoom smoothing) */
.react-flow__viewport {
    transition: none;
}

.react-flow__viewport.zoom-smooth {
    transition: transform var(--zoom-duration) var(--ease-smooth);
}

/* Disable smoothing during pans/drags for snappy feel */
.react-flow__viewport.no-animate {
    transition: none !important;
}

/* Placeholder body shown when code is hidden for performance */
.node-placeholder-body {
    height: calc(100% - 30px);
    display: grid;
    place-items: center;
    color: #94a3b8;
    font-size: 12px;
    opacity: 0.9;
}

/* Defer offscreen work for heavy node content */
.code-card {
    content-visibility: auto;
    contain-intrinsic-size: 480px 280px;
    contain: layout paint size;
}

/* Promote nodes to their own layer to reduce flicker during viewport moves */
.file-node {
    backface-visibility: hidden;
    transform: translateZ(0);
}
```

## webview/tsconfig.json

```json
﻿{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "allowJs": false,
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "useDefineForClassFields": true
  },
  "include": ["src"]
}
```

## webview/vite.config.ts

```typescript
﻿import { defineConfig } from 'vite';
import path from 'path';

export default defineConfig({
    base: '',
    build: {
        outDir: path.resolve(__dirname, '../extension/media'), // note ../
        emptyOutDir: true,
        sourcemap: 'inline',          // ← embed maps + sourcesContent
        minify: false,                // ← readable stack frames
        rollupOptions: {
            input: path.resolve(__dirname, 'index.html'),
            output: { sourcemapExcludeSources: false }
        },
        target: 'chrome120'
    }
});
```

## Statistics

- Total Files: 25
- Total Characters: 2568427
- Total Tokens: 0
````````

## webview/index.html

```html
﻿<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; img-src vscode-resource: https: data:; style-src 'unsafe-inline' __CSP__; script-src __CSP__; font-src __CSP__; connect-src __CSP__;" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Code Canvas</title>
</head>

<body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
</body>

</html>
```

## webview/package.json

```json
{
    "name": "code-canvas-webview",
    "private": true,
    "version": "0.0.1",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "vite build"
    },
    "dependencies": {
        "dagre": "^0.8.5",
        "elkjs": "^0.10.0",
        "highlight.js": "^11.9.0",
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "reactflow": "^11.11.4"
    },
    "devDependencies": {
        "@types/react": "^18.3.3",
        "@types/react-dom": "^18.3.0",
        "typescript": "^5.6",
        "vite": "^7.1.2"
    }
}
```

## webview/src/App.tsx

```text
﻿import React, { useEffect, useMemo, useRef, useState } from 'react';
import ReactFlow, { Background, Controls, MiniMap, Handle, Position, applyNodeChanges } from 'reactflow';
import 'reactflow/dist/style.css';
import { nodeTypes } from './reactflow-node-types';
import CodeCard from './code/CodeCard';

// VS Code webview API
declare global { interface Window { acquireVsCodeApi: any; __CODE_CACHE?: Record<string, string> } }
const vscode = window.acquireVsCodeApi?.();

type Node = { id: string; type: 'file'; position: { x: number; y: number }; data: any; style?: any; dragHandle?: string };

export default function App() {
    const [graph, setGraph] = useState<{ nodes: any[]; edges: any[] }>({ nodes: [], edges: [] });
    const [nodes, setNodes] = useState<Node[]>([]);
    const [edges, setEdges] = useState<any[]>([]);
    const nodesRef = useRef<Node[]>([]);
    const edgesRef = useRef<any[]>([]);
    const [rawEdges, setRawEdges] = useState<any[]>([]);
    const [selectedIds, setSelectedIds] = useState<string[]>([]);
    const [emptyMsg, setEmptyMsg] = useState<string | undefined>(undefined);
    const [progress, setProgress] = useState<string | undefined>(undefined);
    const lastAlgo = useRef<'horizontal'>('horizontal');
    const [showRefs, setShowRefs] = useState(true);
    const [wrap, setWrap] = useState(false);
    const [showEdges, setShowEdges] = useState(true);
    const [focusIds, setFocusIds] = useState<Set<string> | null>(null);
    const rfInstanceRef = useRef<any | null>(null);
    const hasFitOnceRef = useRef<boolean>(false);
    const viewportRef = useRef<{ x: number; y: number; zoom: number }>({ x: 0, y: 0, zoom: 1 });
    const [zoomOk, setZoomOk] = useState<boolean>(true);
    const codeCacheRef = useRef<Record<string, string>>({});
    const measuredSizeRef = useRef<Record<string, { width: number; height: number }>>({});
    const pendingMeasureRef = useRef<Record<string, { width: number; height: number }>>({});
    const rafCommitRef = useRef<number | null>(null);
    const headerHeight = 30; // matches CSS: .code-card { height: calc(100% - 30px); }
    const prePaddingTop = 8; // matches CSS: pre.hljs { padding: 8px 10px; }
    const lineHeight = 16; // approx from font-size 12px and line-height 1.35
    const linePosRef = useRef<Record<string, { line: number; top: number }[]>>({});
    const highlightRef = useRef<Record<string, number | undefined>>({});
    const scrollRef = useRef<Record<string, number | undefined>>({});
    const zoomSmoothTimerRef = useRef<number | null>(null);
    const moveSamplesRef = useRef<Array<{ t: number; x: number; y: number }>>([]);
    const isFlingingRef = useRef<boolean>(false);
    const flingRafRef = useRef<number | null>(null);
    const velocityRef = useRef<{ vx: number; vy: number }>({ vx: 0, vy: 0 });
    const lastInputRef = useRef<'wheel' | 'drag' | null>(null);
    const zoomLockUntilRef = useRef<number>(0);
    const zoomActiveRef = useRef<boolean>(false);

    function cancelFling(): void {
        if (flingRafRef.current != null) {
            try { cancelAnimationFrame(flingRafRef.current); } catch { }
            flingRafRef.current = null;
        }
        isFlingingRef.current = false;
    }

    function startFling(initialVx: number, initialVy: number): void {
        cancelFling();
        isFlingingRef.current = true;
        velocityRef.current = { vx: initialVx, vy: initialVy };
        let last = performance.now();
        const damping = 3.0; // s^-1 exponential decay
        const stopThreshold = 30; // px/s
        const axisStopMin = 15; // px/s per-axis stop to avoid tiny oscillations
        const step = () => {
            if (!isFlingingRef.current) return;
            const now = performance.now();
            const dt = Math.max(0, (now - last) / 1000);
            last = now;
            const v = velocityRef.current;
            const decay = Math.exp(-damping * dt);
            const prevVx = v.vx; const prevVy = v.vy;
            v.vx *= decay; v.vy *= decay;
            // Stop an axis if it crosses zero or is very small
            if (Math.sign(prevVx) !== 0 && Math.sign(prevVx) !== Math.sign(v.vx)) v.vx = 0;
            if (Math.abs(v.vx) < axisStopMin) v.vx = 0;
            if (Math.sign(prevVy) !== 0 && Math.sign(prevVy) !== Math.sign(v.vy)) v.vy = 0;
            if (Math.abs(v.vy) < axisStopMin) v.vy = 0;
            const speed = Math.hypot(v.vx, v.vy);
            const vp = viewportRef.current;
            let nextX = vp.x + v.vx * dt;
            let nextY = vp.y + v.vy * dt;
            // Snap to integer pixels near stop to reduce subpixel shimmer
            if (speed < 80) { nextX = Math.round(nextX); nextY = Math.round(nextY); }
            try { rfInstanceRef.current?.setViewport?.({ x: nextX, y: nextY, zoom: vp.zoom }); } catch { }
            viewportRef.current = { x: nextX, y: nextY, zoom: vp.zoom };
            if (speed < stopThreshold) { cancelFling(); return; }
            flingRafRef.current = requestAnimationFrame(step);
        };
        flingRafRef.current = requestAnimationFrame(step);
    }

    function enqueueSizeUpdate(nodeId: string, size: { width: number; height: number }) {
        // Avoid style writes while viewport is animated to prevent flicker
        if (isFlingingRef.current || isDraggingViewRef.current) return;
        pendingMeasureRef.current[nodeId] = size;
        if (rafCommitRef.current == null) {
            rafCommitRef.current = window.requestAnimationFrame(() => {
                const updates = pendingMeasureRef.current;
                pendingMeasureRef.current = {};
                rafCommitRef.current = null;
                setNodes(prev => prev.map((x: any) => updates[x.id] ? { ...x, style: updates[x.id] } : x));
            });
        }
    }

    function computeStyleFromContent(content: string) {
        // fallback rough estimate before exact measure arrives
        const text = content || '';
        const lines = text.split('\n');
        const maxLen = lines.reduce((m, l) => Math.max(m, l.length), 0);
        const rawWidth = Math.max(480, Math.floor(maxLen * 7 + 40));
        const rawHeight = Math.max(200, lines.length * 14 + 30);
        // clamp to avoid enormous nodes that can destabilize layout/rendering
        const width = Math.min(rawWidth, 1400);
        const height = Math.min(rawHeight, 900);
        return { width, height } as const;
    }

    useEffect(() => {
        vscode?.postMessage({ type: 'requestGraph' });
        vscode?.postMessage({ type: 'requestChanged' });
        const listener = (e: MessageEvent) => {
            const msg = e.data;
            if (msg.type === 'empty') setEmptyMsg(msg.reason === 'no-workspace'
                ? 'Open a folder to analyze your code.' : 'No JS/TS/Python files found.');
            else if (msg.type === 'progress') setProgress(msg.msg || undefined);
            else if (msg.type === 'graph') {
                setEmptyMsg(undefined); setProgress(undefined); setGraph(msg.graph);
                const paths = (msg.graph?.nodes || []).map((n: any) => n.path);
                if (paths.length) startCodeLoadBatch(paths);
                setRawEdges(msg.graph?.edges || []);
            }
            else if (msg.type === 'expandResult') mergeGraph(msg.graph);
            else if (msg.type === 'changedFiles') {
                openFiles(msg.files);
            } else if (msg.type === 'openChanged') {
                openFiles(msg.files);
            } else if (msg.type === 'layout') {
                layout('horizontal');
            } else if (msg.type === 'toggleRefs') {
                setShowRefs(s => !s);
            } else if (msg.type === 'toggleEdges') {
                setShowEdges(s => !s);
            } else if (msg.type === 'code') {
                codeCacheRef.current[msg.path] = msg.content || '';
                setNodes(prev => prev.map(n => n.data.path === msg.path ? { ...n, style: computeStyleFromContent(codeCacheRef.current[msg.path]) } : n));
                onCodeArrived([msg.path]);
            } else if (msg.type === 'codeMany') {
                const updated = new Set<string>();
                for (const { path, content } of (msg.entries || [])) {
                    codeCacheRef.current[path] = content || '';
                    updated.add(path);
                }
                if (updated.size) setNodes(prev => prev.map(n => updated.has(n.data.path) ? { ...n, style: computeStyleFromContent(codeCacheRef.current[n.data.path]) } : n));
                onCodeArrived(Array.from(updated));
            } else if (msg.type === 'seedFolder') {
                // The extension relays the path; filter current index graph by prefix and request code for those
                const folder: string = msg.folder;
                const selected = (graph.nodes || []).filter((n: any) => (n.path || '').startsWith(folder));
                setNodes(prev => selected.map((n: any, i: number) => ({
                    id: n.id, type: 'file', position: { x: (i % 3) * 1200, y: Math.floor(i / 3) * 1000 },
                    style: computeStyleFromContent(codeCacheRef.current[n.path] || ''), dragHandle: '.file-node-header', data: { label: n.label, preview: (<div className="preview">{n.path}</div>), path: n.path, lang: n.lang }
                })));
                const paths = selected.map((n: any) => n.path);
                if (paths.length) startCodeLoadBatch(paths);
            }
        };
        window.addEventListener('message', listener);
        return () => window.removeEventListener('message', listener);
    }, []);

    useEffect(() => { // build ReactFlow nodes
        const initial: Node[] = graph.nodes.map((n: any, i: number) => ({
            id: n.id,
            type: 'file',
            position: { x: (i % 3) * 1200, y: Math.floor(i / 3) * 1000 },
            style: computeStyleFromContent(codeCacheRef.current[n.path] || ''),
            dragHandle: '.file-node-header',
            data: { label: n.label, preview: (<div className="preview">{n.path}</div>), path: n.path, lang: n.lang }
        }));
        const e = (graph.edges || []).map((e: any) => ({
            id: e.id,
            source: e.source,
            target: e.target,
            data: { sourceLine: e.sourceLine, targetLine: e.targetLine },
            sourceHandle: (e.sourceLine ?? null) !== null && (e.sourceLine ?? undefined) !== undefined ? `line-${e.sourceLine}` : undefined,
            targetHandle: (e.targetLine ?? null) !== null && (e.targetLine ?? undefined) !== undefined ? `line-${e.targetLine}` : undefined
        }));
        setNodes(initial); setEdges(e);
        hasFitOnceRef.current = false;
    }, [graph]);

    useEffect(() => { nodesRef.current = nodes; }, [nodes]);
    useEffect(() => { edgesRef.current = edges; }, [edges]);

    function mergeGraph(g: any) {
        const newPaths: string[] = [];
        setNodes(prev => {
            const map = new Map(prev.map(n => [n.id, n]));
            for (const n of g.nodes) if (!map.has(n.id)) {
                newPaths.push(n.path);
                map.set(n.id, {
                    id: n.id, type: 'file',
                    position: { x: Math.random() * 800, y: Math.random() * 600 },
                    style: computeStyleFromContent(codeCacheRef.current[n.path] || ''),
                    dragHandle: '.file-node-header',
                    data: { label: n.label, preview: <div className="preview">{n.path}</div>, path: n.path, lang: n.lang }
                } as any);
            }
            return Array.from(map.values());
        });
        setEdges(prev => {
            const ids = new Set(prev.map(e => e.id));
            const add = g.edges.filter((e: any) => !ids.has(e.id));
            return [...prev, ...add];
        });
        if (newPaths.length) requestMoreCode(newPaths);
    }

    function openFiles(paths: string[]) {
        setNodes(prev => {
            const ids = new Set(prev.map(p => p.id));
            const add: Node[] = graph.nodes
                .filter((n: any) => paths.includes(n.path) && !ids.has(n.id))
                .map((n: any, i: number) => ({
                    id: n.id,
                    type: 'file',
                    position: { x: 50 + i * 30, y: 60 + i * 30 },
                    style: { width: 480, height: 280 },
                    dragHandle: '.file-node-header',
                    data: { label: n.label, preview: <div className="preview">{n.path}</div>, path: n.path, lang: n.lang }
                }));
            return [...prev, ...add];
        });
        if (paths && paths.length) requestMoreCode(paths);
    }

    // Debounced auto-layout to avoid thrashing
    const autoLayoutTimer = useRef<number | null>(null);
    function scheduleAutoLayout() {
        if (autoLayoutTimer.current) {
            window.clearTimeout(autoLayoutTimer.current);
        }
        autoLayoutTimer.current = window.setTimeout(() => { layout('horizontal'); }, 250);
    }

    // Track pending code loads and run one layout after all code in a batch has loaded
    const pendingCodePathsRef = useRef<Set<string>>(new Set());
    const afterFullLoadLayoutTimer = useRef<number | null>(null);
    const moveFrameRef = useRef<number | null>(null);
    const pendingVpRef = useRef<any | null>(null);
    const isDraggingViewRef = useRef<boolean>(false);

    function maybeRunLayoutAfterFullLoad() {
        if (pendingCodePathsRef.current.size !== 0) return;
        if (afterFullLoadLayoutTimer.current != null) {
            window.clearTimeout(afterFullLoadLayoutTimer.current);
        }
        // Give the DOM a moment so CodeCard measurements propagate before layout
        afterFullLoadLayoutTimer.current = window.setTimeout(() => {
            layout('horizontal');
            afterFullLoadLayoutTimer.current = null;
        }, 120);
    }

    function startCodeLoadBatch(paths: string[]) {
        const toRequest = (paths || []).filter(p => !codeCacheRef.current[p]);
        pendingCodePathsRef.current = new Set(toRequest);
        if (toRequest.length) {
            vscode?.postMessage({ type: 'requestCodeMany', paths: toRequest });
        } else {
            maybeRunLayoutAfterFullLoad();
        }
    }

    function requestMoreCode(paths: string[]) {
        const toRequest = (paths || []).filter(p => !codeCacheRef.current[p]);
        if (toRequest.length) {
            toRequest.forEach(p => pendingCodePathsRef.current.add(p));
            vscode?.postMessage({ type: 'requestCodeMany', paths: toRequest });
        }
    }

    function onCodeArrived(paths: string[]) {
        let any = false;
        for (const p of paths) {
            if (pendingCodePathsRef.current.delete(p)) any = true;
        }
        if (any) maybeRunLayoutAfterFullLoad();
    }

    async function layout(_algo: 'horizontal', forceFit: boolean = false) {
        lastAlgo.current = 'horizontal';
        const currentNodes = nodesRef.current as any as Node[];
        let currentX = 40;
        const y = 60;
        const spacing = 20;
        const laidOut = currentNodes.map(n => {
            const measured = measuredSizeRef.current[n.id];
            const width = (n?.style?.width ?? measured?.width ?? 480);
            const pos = { x: currentX, y };
            currentX += width + spacing;
            return { ...n, position: pos } as any;
        });
        setNodes(laidOut as any);
    }

    function onOpenFile(n: Node) { vscode?.postMessage({ type: 'openFile', path: n.data.path }); }

    function onTokenClick({ path, line, character, token }: any) {
        if (!showRefs) return;
        vscode?.postMessage({ type: 'requestRefs', path, line, character, token });
        vscode?.postMessage({ type: 'requestDefOpen', path, line, character });
        // Focus connected nodes to the clicked file
        const base = nodes.find(n => n.data.path === path);
        if (base) focusNodesForId(base.id);
    }

    function expandSelection() {
        const ids = selectedIds.length ? selectedIds : (nodes as any).filter((n: any) => n.selected).map((n: any) => n.id);
        if (ids.length) vscode?.postMessage({ type: 'expand', ids });
    }

    function focusNodesForId(baseId: string) {
        const neighborIds = new Set<string>([baseId]);
        for (const e of edges as any[]) {
            if (e.source === baseId) neighborIds.add(e.target);
            if (e.target === baseId) neighborIds.add(e.source);
        }
        // Build vertical positions for focus lane
        const order: string[] = [baseId, ...Array.from(neighborIds).filter(id => id !== baseId).sort()];
        let currentY = 60;
        const x = 40;
        const spacing = 20;
        const nextPos = new Map<string, { x: number; y: number }>();
        for (const id of order) {
            const n = nodes.find(n => n.id === id);
            const h = (n?.style?.height ?? measuredSizeRef.current[id]?.height ?? 280);
            nextPos.set(id, { x, y: currentY });
            currentY += h + spacing;
        }
        setFocusIds(new Set(neighborIds));
        setNodes(prev => prev.map(n => {
            const inFocus = neighborIds.has(n.id);
            const pos = nextPos.get(n.id);
            if (inFocus && pos) {
                return { ...n, position: pos, data: { ...n.data, dim: false } } as any;
            }
            return { ...n, data: { ...n.data, dim: true } } as any;
        }));
    }

    function clearFocus() {
        setFocusIds(null);
        setNodes(prev => prev.map(n => ({ ...n, data: { ...n.data, dim: false } } as any)));
    }

    const elevatedPairRef = useRef<{ edgeId: string | null; aId: string | null; bId: string | null }>({ edgeId: null, aId: null, bId: null });

    function getNodeWidth(id: string): number {
        const n = nodesRef.current.find(nn => nn.id === id);
        const measured = measuredSizeRef.current[id];
        return (n?.style?.width ?? measured?.width ?? 480);
    }

    function getNodeHeight(id: string): number {
        const n = nodesRef.current.find(nn => nn.id === id);
        const measured = measuredSizeRef.current[id];
        return (n?.style?.height ?? measured?.height ?? 280);
    }

    function computeRowPositions(list: Node[]): Map<string, { x: number; y: number }> {
        const pos = new Map<string, { x: number; y: number }>();
        const spacing = 20;
        let currentX = 40;
        const y = 60;
        for (const n of list) {
            pos.set(n.id, { x: currentX, y });
            const width = getNodeWidth(n.id);
            currentX += width + spacing;
        }
        return pos;
    }

    function elevateEdgePair(edge: any) {
        try {
            const aId: string | undefined = edge?.source;
            const bId: string | undefined = edge?.target;
            if (!aId || !bId) return;
            const prevPair = elevatedPairRef.current;
            const samePair = (prevPair.aId && prevPair.bId) && ((prevPair.aId === aId && prevPair.bId === bId) || (prevPair.aId === bId && prevPair.bId === aId));
            if (edge?.id && prevPair.edgeId === edge.id) return; // exact same link
            if (!edge?.id && samePair) return; // same endpoints

            const sharedIds = new Set<string>();
            if (prevPair.aId && (prevPair.aId === aId || prevPair.aId === bId)) sharedIds.add(prevPair.aId);
            if (prevPair.bId && (prevPair.bId === aId || prevPair.bId === bId)) sharedIds.add(prevPair.bId);

            const spacing = 20;
            const yRow = 60;

            // Temporarily freeze interactions; prevents internal auto panning/viewport changes during updates
            try { rfInstanceRef.current?.setInteractive?.(false); } catch { }

            setFocusIds(null);
            setNodes(prev => {
                // First: restore everyone to row positions except shared elevated node (if any)
                const posMap = computeRowPositions(prev as any);
                let next = prev.map(n => (sharedIds.has(n.id) ? n : ({ ...n, position: posMap.get(n.id)! } as any)));

                // Then: elevate the new pair
                if (sharedIds.has(aId)) {
                    const shared = next.find(n => n.id === aId)!;
                    const sharedX = (shared as any).position.x;
                    const sharedY = (shared as any).position.y;
                    const aWidth = getNodeWidth(aId);
                    const bWidth = getNodeWidth(bId);
                    const bHeight = getNodeHeight(bId);
                    const bX = sharedX + aWidth + spacing;
                    const bY = sharedY; // keep same vertical as shared for minimal movement
                    next = next.map(n => (n.id === bId ? ({ ...n, position: { x: bX, y: bY } } as any) : n));
                } else if (sharedIds.has(bId)) {
                    const shared = next.find(n => n.id === bId)!;
                    const sharedX = (shared as any).position.x;
                    const sharedY = (shared as any).position.y;
                    const aWidth = getNodeWidth(aId);
                    const aHeight = getNodeHeight(aId);
                    const aX = sharedX - aWidth - spacing;
                    const aY = sharedY;
                    next = next.map(n => (n.id === aId ? ({ ...n, position: { x: aX, y: aY } } as any) : n));
                } else {
                    // No shared node: elevate both newly, top-aligned
                    const aWidth = getNodeWidth(aId);
                    const aHeight = getNodeHeight(aId);
                    const bHeight = getNodeHeight(bId);
                    const aX = 40;
                    const topY = yRow - Math.max(aHeight, bHeight) - spacing;
                    const bX = aX + aWidth + spacing;
                    next = next.map(n => {
                        if (n.id === aId) return { ...n, position: { x: aX, y: topY } } as any;
                        if (n.id === bId) return { ...n, position: { x: bX, y: topY } } as any;
                        return n;
                    });
                }

                elevatedPairRef.current = { edgeId: edge?.id ?? `${aId}->${bId}`, aId, bId };
                return next;
            });

            // Re-enable interactions right after updates
            setTimeout(() => { try { rfInstanceRef.current?.setInteractive?.(true); } catch { } }, 0);
        } catch { }
    }

    useEffect(() => {
        const onKey = (e: KeyboardEvent) => { if ((e.key === 'e' || e.key === 'E')) expandSelection(); };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
    }, [nodes]);

    // render code previews lazily inside each node

    const VISIBLE_ZOOM_THRESHOLD = 0.65; // below this, render placeholder

    const codeRefs = useRef<Record<string, React.RefObject<import('./code/CodeCard').CodeCardHandle>>>({});
    const nodeTypesLocal = useMemo(() => ({
        file: (p: any) => {
            const n = p.data;
            const content = codeCacheRef.current[n.path] ?? n.path;
            const shouldShowCode = zoomOk;
            if (!codeRefs.current[p.id]) codeRefs.current[p.id] = React.createRef();
            const handleLines: number[] = (() => {
                const s = new Set<number>();
                for (const e of edges as any[]) {
                    if (e.source === p.id && e.data?.sourceLine != null) s.add(e.data.sourceLine);
                    if (e.target === p.id && e.data?.targetLine != null) s.add(e.data.targetLine);
                }
                return Array.from(s).sort((a, b) => a - b).slice(0, 200);
            })();
            return (
                <div className="file-node" style={{ opacity: n.dim ? 0.25 : 1 }}>
                    <div className="file-node-header" onDoubleClick={() => onOpenFile(p)}>{n.label}</div>
                    {shouldShowCode ? (
                        <CodeCard
                            ref={codeRefs.current[p.id]}
                            key={n.path}
                            file={n.path}
                            lang={n.lang}
                            content={content}
                            onTokenClick={onTokenClick}
                            wrap={wrap}
                            onLinePositions={(positions) => { linePosRef.current[p.id] = positions; }}
                            onMeasured={({ width, height }) => {
                                if (isFlingingRef.current || isDraggingViewRef.current) return;
                                const last = measuredSizeRef.current[p.id];
                                if (last && last.width === width && last.height === height) return;
                                measuredSizeRef.current[p.id] = { width, height };
                                enqueueSizeUpdate(p.id, { width, height });
                            }}
                        />
                    ) : (
                        <div className="node-placeholder-body">Zoom in to view code</div>
                    )}
                    {/* default center handles */}
                    <Handle type="source" position={Position.Right} id={`line-0`} />
                    <Handle type="target" position={Position.Left} id={`line-0`} />
                    {/* per-line handles anchored by top offset */}
                    {handleLines.map((ln) => {
                        const top = (linePosRef.current[p.id]?.find(x => x.line === ln)?.top) ?? (headerHeight + prePaddingTop + ln * lineHeight);
                        return (
                            <React.Fragment key={ln}>
                                <Handle
                                    type="source"
                                    position={Position.Right}
                                    id={`line-${ln}`}
                                    style={{ top }}
                                />
                                <Handle
                                    type="target"
                                    position={Position.Left}
                                    id={`line-${ln}`}
                                    style={{ top }}
                                />
                            </React.Fragment>
                        );
                    })}
                </div>
            );
        }
    }), [edges, zoomOk, wrap]);

    return (
        <div className="root">
            <div className="toolbar">
                <button onClick={() => layout('horizontal', true)}>Relayout</button>
                <button onClick={() => vscode?.postMessage({ type: 'loadMore' })}>Load 25 more</button>
                <button onClick={() => vscode?.postMessage({ type: 'requestChanged' })}>Open Changed (⇧O)</button>
                <button onClick={() => vscode?.postMessage({ type: 'requestGraph' })}>Reload</button>
                <button onClick={expandSelection}>Expand (E)</button>
                <button onClick={() => vscode?.postMessage({ type: 'toggleRefs' })}>Refs (R)</button>
                <button onClick={() => setWrap(w => !w)}>{wrap ? 'Unwrap' : 'Wrap'}</button>
                <button onClick={() => setShowEdges(s => !s)}>{showEdges ? 'Hide Edges' : 'Show Edges'}</button>
                <button onClick={() => vscode?.postMessage({ type: 'toggleEdges' })}>Toggle Edges (Global)</button>
                <button onClick={() => vscode?.postMessage({ type: 'seedFolder' })}>Seed Folder…</button>
                {focusIds ? (<button onClick={clearFocus}>Clear Focus</button>) : null}
            </div>
            <ReactFlow
                nodes={nodes as any}
                edges={showEdges ? (focusIds ? (edges as any[]).filter(e => focusIds.has(e.source) && focusIds.has(e.target)) : edges) : []}
                nodeTypes={nodeTypesLocal as any}
                onlyRenderVisibleElements
                onInit={(inst) => {
                    rfInstanceRef.current = inst;
                    try {
                        const vp = inst?.getViewport?.();
                        if (vp) {
                            setZoomOk(vp.zoom >= VISIBLE_ZOOM_THRESHOLD);
                            viewportRef.current = { x: vp.x, y: vp.y, zoom: vp.zoom };
                        }
                        const container = document.querySelector('.react-flow') as HTMLElement | null;
                        const onWheel = (e: WheelEvent) => {
                            try {
                                lastInputRef.current = 'wheel';
                                const vpEl = document.querySelector('.react-flow__viewport');
                                if (!vpEl) return;
                                vpEl.classList.add('zoom-smooth');
                                const now = performance.now();
                                // Lock fling logic during zoom gesture window
                                zoomLockUntilRef.current = now + 420;
                                zoomActiveRef.current = true;
                                // Clear any drag samples so zoom motion isn't used for fling
                                moveSamplesRef.current = [];
                                if (zoomSmoothTimerRef.current) window.clearTimeout(zoomSmoothTimerRef.current);
                                zoomSmoothTimerRef.current = window.setTimeout(() => {
                                    vpEl.classList.remove('zoom-smooth');
                                    zoomActiveRef.current = false;
                                    lastInputRef.current = null;
                                }, 420);
                            } catch { }
                        };
                        container?.addEventListener('wheel', onWheel, { passive: true } as any);
                        (window as any).__rf_wheel_cleanup = () => container?.removeEventListener('wheel', onWheel as any);
                    } catch { }
                }}
                onNodeClick={(_e, node: any) => { setFocusIds(null); }}
                onNodeDragStart={(_evt, node) => {
                    try {
                        const el = document.querySelector(`.react-flow__node[data-id="${node.id}"]`);
                        el?.classList.add('no-animate');
                        const vpEl = document.querySelector('.react-flow__viewport');
                        vpEl?.classList.remove('zoom-smooth');
                        isDraggingViewRef.current = true;
                        lastInputRef.current = 'drag';
                        cancelFling();
                        moveSamplesRef.current = [];
                    } catch { }
                }}
                onNodeDragStop={(_evt, node) => {
                    try {
                        const el = document.querySelector(`.react-flow__node[data-id="${node.id}"]`);
                        el?.classList.remove('no-animate');
                        isDraggingViewRef.current = false;
                    } catch { }
                }}
                onMoveStart={() => {
                    if (zoomActiveRef.current || performance.now() < zoomLockUntilRef.current) return;
                    // User begins panning
                    cancelFling();
                    moveSamplesRef.current = [];
                    try { const el = document.querySelector('.react-flow__viewport'); el?.classList.remove('zoom-smooth'); } catch { }
                    lastInputRef.current = 'drag';
                }}
                onMove={(_evt, vp) => {
                    try {
                        if (!vp) return;
                        if (isFlingingRef.current) { viewportRef.current = { x: vp.x, y: vp.y, zoom: vp.zoom }; return; }
                        if (zoomActiveRef.current || performance.now() < zoomLockUntilRef.current) { viewportRef.current = { x: vp.x, y: vp.y, zoom: vp.zoom }; return; }
                        pendingVpRef.current = vp;
                        if (moveFrameRef.current != null) return;
                        moveFrameRef.current = window.requestAnimationFrame(() => {
                            moveFrameRef.current = null;
                            const latest = pendingVpRef.current; pendingVpRef.current = null;
                            if (!latest) return;
                            const newZoom = latest.zoom;
                            const nextZoomOk = newZoom >= VISIBLE_ZOOM_THRESHOLD;
                            if (nextZoomOk !== zoomOk) setZoomOk(nextZoomOk);
                            viewportRef.current = { x: latest.x, y: latest.y, zoom: latest.zoom };
                            // Record samples for velocity estimation
                            const now = performance.now();
                            if (!zoomActiveRef.current && now >= zoomLockUntilRef.current) moveSamplesRef.current.push({ t: now, x: latest.x, y: latest.y });
                            // Keep only last ~120ms of samples
                            const cutoff = now - 120;
                            if (moveSamplesRef.current.length > 1) {
                                let i = 0; while (i < moveSamplesRef.current.length && moveSamplesRef.current[i].t < cutoff) i++;
                                if (i > 0) moveSamplesRef.current.splice(0, i);
                            }
                        });
                    } catch { }
                }}
                onMoveEnd={() => {
                    try {
                        if (zoomActiveRef.current || performance.now() < zoomLockUntilRef.current) { cancelFling(); return; }
                        // Estimate velocity from last samples
                        const samples = moveSamplesRef.current;
                        if (!samples || samples.length < 2) { cancelFling(); return; }
                        const first = samples[0];
                        const lastS = samples[samples.length - 1];
                        const dtMs = Math.max(1, lastS.t - first.t);
                        const vx = (lastS.x - first.x) / dtMs * 1000; // px/s
                        const vy = (lastS.y - first.y) / dtMs * 1000; // px/s
                        const speed = Math.hypot(vx, vy);
                        const startThreshold = 450; // px/s to start fling
                        if (speed >= startThreshold && lastInputRef.current !== 'wheel') startFling(vx, vy);
                        else { cancelFling(); }
                    } catch { }
                }}
                onEdgeClick={(_e, edge: any) => {
                    const sl = (edge?.data?.sourceLine ?? 0);
                    const tl = (edge?.data?.targetLine ?? 0);
                    if (edge?.source) {
                        try {
                            const ref = codeRefs.current[edge.source];
                            ref?.current?.highlight(sl);
                            ref?.current?.scrollTo(sl);
                        } catch { }
                    }
                    if (edge?.target) {
                        try {
                            const ref = codeRefs.current[edge.target];
                            ref?.current?.highlight(tl);
                            ref?.current?.scrollTo(tl);
                        } catch { }
                    }
                    elevateEdgePair(edge);
                }}
                onSelectionChange={(p: any) => setSelectedIds((p?.nodes || []).map((n: any) => n.id))}
                onNodesChange={(changes) => setNodes((nds: any) => applyNodeChanges(changes as any, nds as any) as any)}
                minZoom={0.02}
                maxZoom={8}
            >
                <Background />
                <MiniMap pannable zoomable />
                <Controls />
            </ReactFlow>
            {progress && <div style={{ position: 'absolute', inset: 0, display: 'grid', placeItems: 'center', pointerEvents: 'none', fontSize: 14, opacity: .8 }}>⚙ {progress}</div>}
            {emptyMsg && <div style={{ position: 'absolute', inset: 0, display: 'grid', placeItems: 'center', fontSize: 14, opacity: .8 }}>{emptyMsg}</div>}
        </div>
    );
}
```

## webview/src/code/CodeCard.tsx

```text
﻿import React, { useLayoutEffect, useMemo, useRef, useImperativeHandle } from 'react';
import { highlight } from './highlight';

export type CodeCardHandle = {
    highlight: (line: number) => void;
    scrollTo: (line: number) => void;
};

function wrapHighlightedHtmlPreserveLines(highlightedHtml: string): string {
    const container = document.createElement('div');
    container.innerHTML = highlightedHtml;

    const lines: string[] = [];
    let current = '';
    const stack: Element[] = [];

    const escapeHtml = (s: string) => s
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

    const escapeAttr = (s: string) => s
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;');

    const startTag = (el: Element) => {
        const tag = el.tagName.toLowerCase();
        let attrs = '';
        for (const attr of Array.from(el.attributes)) {
            attrs += ` ${attr.name}="${escapeAttr(attr.value)}"`;
        }
        return `<${tag}${attrs}>`;
    };
    const endTag = (el: Element) => `</${el.tagName.toLowerCase()}>`;
    const openAll = () => stack.map(startTag).join('');
    const closeAll = () => stack.slice().reverse().map(endTag).join('');

    const flushLine = () => { lines.push(current); current = ''; };

    const handleText = (text: string) => {
        const parts = text.split(/\r\n|\n/);
        for (let i = 0; i < parts.length; i++) {
            current += escapeHtml(parts[i]);
            if (i < parts.length - 1) {
                current += closeAll();
                flushLine();
                current += openAll();
            }
        }
    };

    const walk = (node: Node) => {
        if (node.nodeType === Node.TEXT_NODE) {
            handleText((node as Text).data);
            return;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
            const el = node as Element;
            current += startTag(el);
            stack.push(el);
            for (const child of Array.from(el.childNodes)) walk(child);
            stack.pop();
            current += endTag(el);
            return;
        }
        // Ignore other node types
    };

    for (const child of Array.from(container.childNodes)) walk(child);
    // Ensure at least one line
    if (current !== '' || lines.length === 0) flushLine();

    return lines
        .map((line, i) => `<span class="code-line" data-line="${i}">${line === '' ? '&nbsp;' : line}</span>`)
        .join('');
}

type Props = {
    file: string;
    lang: 'ts' | 'js' | 'py' | 'other';
    content: string;
    onTokenClick: (payload: { path: string; line: number; character: number; token: string }) => void;
    onMeasured?: (size: { width: number; height: number }) => void;
    wrap?: boolean;
    onLinePositions?: (positions: { line: number; top: number }[]) => void;
};

function CodeCardInner({ file, lang, content, onTokenClick, onMeasured, wrap, onLinePositions }: Props, ref: React.Ref<CodeCardHandle>) {
    const effectiveLang = useMemo<'ts' | 'js' | 'py' | 'other'>(() => {
        if (lang && lang !== 'other') return lang;
        const lower = (file || '').toLowerCase();
        if (lower.endsWith('.py')) return 'py';
        if (lower.endsWith('.ts') || lower.endsWith('.tsx')) return 'ts';
        if (lower.endsWith('.js') || lower.endsWith('.jsx') || lower.endsWith('.mjs') || lower.endsWith('.cjs')) return 'js';
        return 'other';
    }, [file, lang]);

    const rawHtml = useMemo(() => highlight(content, effectiveLang), [content, effectiveLang]);
    const html = useMemo(() => wrapHighlightedHtmlPreserveLines(rawHtml), [rawHtml]);
    const preRef = useRef<HTMLPreElement | null>(null);
    const containerRef = useRef<HTMLDivElement | null>(null);
    const lastHighlightedRef = useRef<number | undefined>(undefined);

    useLayoutEffect(() => {
        const el = preRef.current;
        if (!el) return;
        const notify = () => onMeasured?.({ width: el.scrollWidth, height: el.scrollHeight });
        notify();
        const ro = new ResizeObserver(() => {
            notify();
            computeLinePositions();
        });
        ro.observe(el);
        const cont = containerRef.current;
        const onScroll = () => computeLinePositions();
        cont?.addEventListener('scroll', onScroll, { passive: true } as any);
        return () => { ro.disconnect(); cont?.removeEventListener('scroll', onScroll as any); };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [html, onMeasured]);

    function computeLinePositions() {
        try {
            const pre = preRef.current;
            const container = containerRef.current;
            const root = container?.closest('.file-node') as HTMLElement | null;
            if (!pre || !container || !root) return;
            const rootRect = root.getBoundingClientRect();
            const spans = Array.from(pre.querySelectorAll('span.code-line')) as HTMLElement[];
            const positions = spans.map((sp, idx) => {
                const spRect = sp.getBoundingClientRect();
                const top = (spRect.top - rootRect.top) + spRect.height / 2;
                return { line: idx, top };
            });
            onLinePositions?.(positions);
        } catch { }
    }

    useLayoutEffect(() => { computeLinePositions(); }, [html]);

    useImperativeHandle(ref, () => ({
        highlight: (line: number) => {
            try {
                const pre = preRef.current;
                if (!pre) return;
                const all = pre.querySelectorAll('.code-line.highlight');
                all.forEach(n => n.classList.remove('highlight'));
                const target = pre.querySelector(`.code-line[data-line="${line}"]`) as HTMLElement | null;
                if (target) {
                    target.classList.add('highlight');
                    lastHighlightedRef.current = line;
                }
            } catch { }
        },
        scrollTo: (line: number) => {
            try {
                const pre = preRef.current;
                const container = containerRef.current;
                if (!pre || !container) return;
                const target = pre.querySelector(`.code-line[data-line="${line}"]`) as HTMLElement | null;
                if (target) {
                    const preTop = (pre as HTMLElement).offsetTop;
                    const targetTop = target.offsetTop;
                    const desired = preTop + targetTop - (container.clientHeight / 2) + (target.offsetHeight / 2);
                    container.scrollTo({ top: Math.max(0, desired), behavior: 'auto' });
                }
            } catch { }
        }
    }), []);

    const onClick: React.MouseEventHandler<HTMLPreElement> = () => {
        const sel = window.getSelection();
        if (!sel || sel.rangeCount === 0 || sel.toString().length === 0) return;
        const token = sel.toString();
        const range = sel.getRangeAt(0);
        const startNode = range.startContainer;
        const startEl: Element | null = startNode.nodeType === Node.ELEMENT_NODE ? (startNode as Element) : (startNode.parentElement);
        if (!startEl) return;
        const lineEl = startEl.closest('.code-line') as HTMLElement | null;
        if (!lineEl) return;
        const lineAttr = lineEl.getAttribute('data-line');
        const line = lineAttr ? parseInt(lineAttr, 10) : 0;
        const headRange = document.createRange();
        headRange.selectNodeContents(lineEl);
        headRange.setEnd(range.startContainer, range.startOffset);
        const character = headRange.toString().length;
        onTokenClick({ path: file, line, character, token });
    };

    return (
        <div className="code-card" ref={containerRef}>
            <div className="file-title">{file}</div>
            <pre ref={preRef} id={`code-${file}`} className={`hljs${wrap ? ' wrap' : ''}`} onMouseUp={onClick} dangerouslySetInnerHTML={{ __html: html }} />
        </div>
    );
}

const CodeCard = React.memo(React.forwardRef(CodeCardInner), (prev, next) => (
    prev.file === next.file &&
    prev.content === next.content &&
    prev.wrap === next.wrap &&
    prev.lang === next.lang
));

export default CodeCard;
```

## webview/src/code/highlight.ts

```typescript
﻿import hljs from 'highlight.js/lib/core';
import ts from 'highlight.js/lib/languages/typescript';
import js from 'highlight.js/lib/languages/javascript';
import py from 'highlight.js/lib/languages/python';
import plaintext from 'highlight.js/lib/languages/plaintext';

hljs.registerLanguage('typescript', ts);
hljs.registerLanguage('javascript', js);
// Increase the maximum length before Highlight.js bails out to plaintext so large Python files still get properly highlighted.
hljs.configure({ maxHighlightLength: 500_000 } as any);
hljs.registerLanguage('python', py);
hljs.registerLanguage('plaintext', plaintext);

// A mapping object is slightly cleaner than a long ternary chain.
const languageMap = {
    ts: 'typescript',
    js: 'javascript',
    py: 'python',
    other: 'plaintext'
};

export function highlight(code: string, lang: 'ts' | 'js' | 'py' | 'other') {
    const mapped = languageMap[lang] || 'plaintext';

    // 1. First, check if the language is explicitly supported.
    if (hljs.getLanguage(mapped)) {
        try {
            // 2. Attempt to highlight with the specified language.
            return hljs.highlight(code, { language: mapped, ignoreIllegals: true }).value;
        } catch (e) {
            // This catch block will run if highlighting fails catastrophically.
            console.error(`Highlighting failed for language "${mapped}"`, e);
        }
    }

    // 3. If specific highlighting fails, fallback to auto-detection.
    // This is safer than the original implementation's catch-all.
    try {
        return hljs.highlightAuto(code).value;
    } catch (e) {
        console.error('Auto-highlighting failed', e);
        // 4. As a last resort, return the code escaped to prevent breaking HTML.
        return code.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
}
```

## webview/src/layout.ts

```typescript
﻿export { };
```

## webview/src/main.tsx

```text
﻿import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import './styles.css';
import 'highlight.js/styles/github-dark.css';

createRoot(document.getElementById('root')!).render(<App />);
```

## webview/src/reactflow-node-types.tsx

```text
﻿import React from 'react';
import { Handle, Position } from 'reactflow';

export function FileNode({ data }: any) {
    return (
        <div className="file-node">
            <div className="file-node-header">{data.label}</div>
            <div className="file-node-body">{data.preview}</div>
            <Handle type="source" position={Position.Right} />
            <Handle type="target" position={Position.Left} />
        </div>
    );
}

export const nodeTypes = { file: FileNode } as const;
```

## webview/src/styles.css

```css
﻿:root {
    color-scheme: dark;
    --ease-smooth: cubic-bezier(0.22, 1, 0.36, 1);
    --zoom-duration: 320ms;
}

body,
html,
#root {
    margin: 0;
    height: 100%;
    background: #0b0e12;
    color: #cdd6f4;
    font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Inter, sans-serif;
}

.root {
    height: 100%;
}

.toolbar {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    display: flex;
    gap: 6px;
}

.toolbar button {
    background: #111827;
    border: 1px solid #1f2937;
    color: #e5e7eb;
    padding: 6px 10px;
    border-radius: 8px;
    cursor: pointer;
}

.file-node {
    width: 100%;
    height: 100%;
    background: #0d1117;
    border: 1px solid #1f2937;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 0 0 1px #0b1220 inset;
}

.file-node-header {
    background: #0b1220;
    padding: 6px 10px;
    font-weight: 600;
    font-size: 12px;
    letter-spacing: .3px;
    border-bottom: 1px solid #1f2937;
    cursor: grab;
}

.code-card {
    height: calc(100% - 30px);
    overflow: auto;
}

.code-card .file-title {
    display: none;
}

pre.hljs {
    margin: 0;
    padding: 8px 10px 8px 56px;
    /* leave space for gutter */
    font-size: 12px;
    line-height: 1.35;
    position: relative;
    counter-reset: line;
}

pre.hljs .code-line {
    display: block;
    counter-increment: line;
    position: relative;
}

pre.hljs .code-line::before {
    content: counter(line);
    position: absolute;
    left: -44px;
    width: 36px;
    text-align: right;
    color: #6b7280;
    opacity: 0.9;
}

pre.hljs .code-line.highlight {
    background: rgba(255, 214, 10, 0.15);
    outline: 1px solid rgba(255, 214, 10, 0.35);
}

pre.hljs.wrap {
    white-space: pre-wrap;
}

.preview {
    font-size: 11px;
    opacity: .8;
    padding: 8px;
}

/* Improve MiniMap visibility */
.react-flow__minimap {
    background: #0f1115 !important;
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.06) inset;
}

.react-flow__minimap-mask {
    fill: rgba(255, 255, 255, 0.06) !important;
}

.react-flow__minimap-node {
    fill: #4f46e5 !important;
    stroke: rgba(255, 255, 255, 0.2) !important;
}

/* Allow extreme zooming */
.react-flow__renderer,
.react-flow__viewport {
    will-change: transform;
}

/* Smooth node transitions for layout/elevation changes */
.react-flow__node {
    transition: transform 220ms cubic-bezier(0.22, 1, 0.36, 1), opacity 160ms ease;
    will-change: transform;
}

/* Disable transition while dragging to keep the interaction snappy */
.react-flow__node.no-animate {
    transition: none !important;
}

@media (prefers-reduced-motion: reduce) {
    .react-flow__node {
        transition: none !important;
    }
}

/* Smooth transform transitions for the React Flow viewport (zoom smoothing) */
.react-flow__viewport {
    transition: none;
}

.react-flow__viewport.zoom-smooth {
    transition: transform var(--zoom-duration) var(--ease-smooth);
}

/* Disable smoothing during pans/drags for snappy feel */
.react-flow__viewport.no-animate {
    transition: none !important;
}

/* Placeholder body shown when code is hidden for performance */
.node-placeholder-body {
    height: calc(100% - 30px);
    display: grid;
    place-items: center;
    color: #94a3b8;
    font-size: 12px;
    opacity: 0.9;
}

/* Defer offscreen work for heavy node content */
.code-card {
    content-visibility: auto;
    contain-intrinsic-size: 480px 280px;
    contain: layout paint size;
}

/* Promote nodes to their own layer to reduce flicker during viewport moves */
.file-node {
    backface-visibility: hidden;
    transform: translateZ(0);
}
```

## webview/tsconfig.json

```json
﻿{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "allowJs": false,
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "useDefineForClassFields": true
  },
  "include": ["src"]
}
```

## webview/vite.config.ts

```typescript
﻿import { defineConfig } from 'vite';
import path from 'path';

export default defineConfig({
    base: '',
    build: {
        outDir: path.resolve(__dirname, '../extension/media'), // note ../
        emptyOutDir: true,
        sourcemap: 'inline',          // ← embed maps + sourcesContent
        minify: false,                // ← readable stack frames
        rollupOptions: {
            input: path.resolve(__dirname, 'index.html'),
            output: { sourcemapExcludeSources: false }
        },
        target: 'chrome120'
    }
});
```

## Statistics

- Total Files: 25
- Total Characters: 2674338
- Total Tokens: 0
